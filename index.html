<html><head><script class="env" src="//code.jquery.com/jquery-1.10.1.min.js"></script><script class="env" src="javascripts/envweb.js"></script></head><body style=""><script>
  ENV = {
    "$root": $('body'),
    "gist": {
      files: {"app.coffee":{"content":"@App = \n  width: 800\n  height: 450\n","filename":"app.coffee"},"arena.haml":{"content":"%canvas(width=800 height=450)","filename":"arena.haml"},"blade.coffee":{"content":"@Blade = (I={}) ->\n  Object.defaults I,\n    color: \"white\"\n    damage: 100\n    duration: 0.05\n    radius: 10\n\n  self = GameObject(I)\n  \n  self.include \"Damager\"\n\n  return self\n","filename":"blade.coffee"},"damager.coffee":{"content":"@Damager = (I={}, self) ->\n  Object.defaults I,\n    selfDamage: false\n  \n  hit: (target, dt) ->\n    return if (target is I.source) and !I.selfDamage\n    \n    target.I.health -= I.damage * dt\n","filename":"damager.coffee"},"explosion.coffee":{"content":"@Explosion = (I={}) ->\n  Object.defaults I,\n    damage: 50 # Per second\n    duration: 0.3\n    radiusMax: 100\n    radius: 0\n\n  self = GameObject(I)\n  \n  self.include \"Damager\"\n\n  self.unbind \"draw\"\n  self.on \"draw\", (canvas) ->\n    canvas.drawCircle\n      x: 0\n      y: 0\n      radius: I.radius\n      color: \"yellow\"\n  \n  self.on \"update\", ->\n    I.radius = I.radiusMax * I.age / I.duration\n  \n  return self\n","filename":"explosion.coffee"},"gamelib.js":{"content":"// Generated by CoffeeScript 1.6.3\n/**\nThe ActiveBounds module automatically destroys objects that\nare outside of the specified bounds. The default bounds are\nthe dimensions of your game. Useful for bullet type objects.\n\n    bullet = GameObject\n      x: 10\n      y: 50\n      width: 20\n      height: 20\n      velocity: Point(120, 0)\n\n    bullet.include ActiveBounds\n\n    # => bullet will be removed when it\n         goes outside of the game bounds.\n\n    bullet2 = GameObject\n      x: 50\n      y: 50\n      width: 30\n      height: 20\n      activeBounds: Rectangle\n        x: 30\n        y: 20\n        width: 100\n        height 100\n\n    # => bullet2 will be removed unless 30 <= I.x <= 130\n         and 20 <= I.y <= 120\n\n@name ActiveBounds\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\nvar CameraTarget,\n  __slice = [].slice;\n\nthis.ActiveBounds = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    activeBounds: Rectangle({\n      x: 0,\n      y: 0,\n      width: App.width,\n      height: App.height\n    })\n  });\n  return self.bind('update', function() {\n    var _ref, _ref1;\n    if (!((I.activeBounds.left <= (_ref = I.x) && _ref <= I.activeBounds.right))) {\n      self.destroy();\n    }\n    if (!((I.activeBounds.top <= (_ref1 = I.y) && _ref1 <= I.activeBounds.bottom))) {\n      return self.destroy();\n    }\n  });\n};\n\n/**\nThe Ageable module handles keeping track of an object's age.\n\n    player = GameObject()\n\n    player.update(1)\n\n    #=> player.I.age == 1\n\n@name Ageable\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Ageable = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    age: 0\n  });\n  self.bind('afterUpdate', function(dt) {\n    return I.age += dt;\n  });\n  return {};\n};\n\n/**\nThe Bounded module is used to provide basic data about the\nlocation and dimensions of the including object. This module is included\nby default in `GameObject`.\n\n    player = Core\n      x: 10\n      y: 50\n      width: 20\n      height: 20\n      other: \"stuff\"\n      more: \"properties\"\n\n    player.position()\n    # => Uncaught TypeError: Object has no method 'position'\n\n    player.include(Bounded)\n\n    # now player has all the methods provided by this module\n    player.position()\n    # => {x: 10, y: 50}\n\n@see GameObject\n\nBounded module\n@name Bounded\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Bounded = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    x: 0,\n    y: 0,\n    width: 8,\n    height: 8,\n    collisionMargin: Point(0, 0)\n  });\n  return {\n    /**\n    Get the object closest to this one.\n    \n    @name closest\n    @methodOf Bounded#\n    @param {Object|Array|String} selector An object or set of objects to find the closest from.\n    */\n\n    closest: function(selector) {\n      var position;\n      if (Object.isString(selector)) {\n        selector = engine.find(selector);\n      } else {\n        selector = [].concat(selector);\n      }\n      position = self.position();\n      return selector.sort(function(a, b) {\n        return Point.distanceSquared(position, a.position()) - Point.distanceSquared(position, b.position());\n      }).first();\n    },\n    /**\n    Distance between two objects. Proxies to Point.distance.\n    In order for this to work, `otherObj` must have a\n    position method.\n    \n        player = GameObject\n          x: 50\n          y: 50\n          width: 10\n          height: 10\n    \n        player.include Bounded\n    \n        enemy = GameObject\n          x: 110\n          y: 120\n          width: 7\n          height: 20\n    \n        player.distance(enemy)\n        # => 92.19544457292888\n    \n    @name distance\n    @methodOf Bounded#\n    @see Point.distance\n    @returns {Number} Distance between the two objects\n    */\n\n    distance: function(otherObj) {\n      return Point.distance(self.position(), otherObj.position());\n    },\n    /**\n    The position of this game object. By default it is the top left point.\n    Redefining the center method will change the relative position.\n    \n        player = Core\n          x: 50\n          y: 40\n    \n        player.include(Bounded)\n    \n        player.position()\n        # => {x: 50, y: 40}\n    \n    @name position\n    @methodOf Bounded#\n    @returns {Point} The position of this object\n    */\n\n    position: function(newPosition) {\n      if (newPosition != null) {\n        I.x = newPosition.x;\n        return I.y = newPosition.y;\n      } else {\n        return Point(I.x, I.y);\n      }\n    },\n    changePosition: function(delta) {\n      I.x += delta.x;\n      I.y += delta.y;\n      return self;\n    },\n    /**\n    Does a check to see if this object is overlapping\n    with the bounds passed in.\n    \n        player = Core\n          x: 4\n          y: 6\n          width: 20\n          height: 20\n    \n        player.include(Bounded)\n    \n        player.collides({x: 5, y: 7, width: 20, height: 20})\n        # => true\n    \n    @name collides\n    @methodOf Bounded#\n    @returns {Point} The position of this object\n    */\n\n    collides: function(bounds) {\n      return Collision.rectangular(self.bounds(), bounds);\n    },\n    /**\n    This returns a modified bounds based on the collision margin.\n    The area of the bounds is reduced if collision margin is positive\n    and increased if collision margin is negative.\n    \n        player = Core\n          collisionMargin:\n            x: -2\n            y: -4\n          x: 50\n          y: 50\n          width: 20\n          height: 20\n    \n        player.include(Bounded)\n    \n        player.collisionBounds()\n        # => {x: 38, y: 36, height: 28, width: 24}\n    \n        player.collisionBounds(10, 10)\n        # => {x: 48, y: 46, height: 28, width: 24}\n    \n    @name collisionBounds\n    @methodOf Bounded#\n    @param {Number} xOffset the amount to shift the x position\n    @param {Number} yOffset the amount to shift the y position\n    @returns {Object} The collision bounds\n    */\n\n    collisionBounds: function(xOffset, yOffset) {\n      var bounds;\n      bounds = self.bounds(xOffset, yOffset);\n      bounds.x += I.collisionMargin.x;\n      bounds.y += I.collisionMargin.y;\n      bounds.width -= 2 * I.collisionMargin.x;\n      bounds.height -= 2 * I.collisionMargin.y;\n      return bounds;\n    },\n    /**\n    Returns infomation about the location of the object and its dimensions with optional offsets.\n    \n        player = Core\n          x: 3\n          y: 6\n          width: 2\n          height: 2\n    \n        player.include(Bounded)\n    \n        player.bounds()\n        # => {x: 3, y: 6, width: 2, height: 2}\n    \n        player.bounds(7, 4)\n        # => {x: 10, y: 10, width: 2, height: 2}\n    \n    @name bounds\n    @methodOf Bounded#\n    @param {Number} xOffset the amount to shift the x position\n    @param {Number} yOffset the amount to shift the y position\n    */\n\n    bounds: function(xOffset, yOffset) {\n      var center;\n      center = self.center();\n      return {\n        x: center.x - I.width / 2 + (xOffset || 0),\n        y: center.y - I.height / 2 + (yOffset || 0),\n        width: I.width,\n        height: I.height\n      };\n    },\n    /**\n    The centeredBounds method returns infomation about the center\n    of the object along with the midpoint of the width and height.\n    \n        player = Core\n          x: 3\n          y: 6\n          width: 2\n          height: 2\n    \n        player.include(Bounded)\n    \n        player.centeredBounds()\n        # => {x: 4, y: 7, xw: 1, yw: 1}\n    \n    @name centeredBounds\n    @methodOf Bounded#\n    */\n\n    centeredBounds: function() {\n      var center;\n      center = self.center();\n      return {\n        x: center.x,\n        y: center.y,\n        xw: I.width / 2,\n        yw: I.height / 2\n      };\n    },\n    /**\n    The center method returns the {@link Point} that is\n    the center of the object.\n    \n        player = Core\n          x: 50\n          y: 40\n          width: 10\n          height: 30\n    \n        player.include(Bounded)\n    \n        player.center()\n        # => {x: 30, y: 35}\n    \n    @name center\n    @methodOf Bounded#\n    @returns {Point} The middle of the calling object\n    */\n\n    center: function(newCenter) {\n      return self.position(newCenter);\n    },\n    /**\n    Return the circular bounds of the object. The circle is\n    centered at the midpoint of the object.\n    \n        player = Core\n          radius: 5\n          x: 50\n          y: 50\n          other: \"stuff\"\n    \n        player.include(Bounded)\n    \n        player.circle()\n        # => {radius: 5, x: 50, y: 50}\n    \n    @name circle\n    @methodOf Bounded#\n    @returns {Object} An object with a position and a radius\n    */\n\n    circle: function() {\n      var circle;\n      circle = self.center();\n      circle.radius = I.radius || I.width / 2 || I.height / 2;\n      return circle;\n    }\n  };\n};\n\nthis.Camera = function(I) {\n  var currentObject, currentType, focusOn, followTypes, moduleName, objectFilters, self, transformFilters, _i, _len, _ref;\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    cameraBounds: Rectangle({\n      x: 0,\n      y: 0,\n      width: App.width,\n      height: App.height\n    }),\n    screen: Rectangle({\n      x: 0,\n      y: 0,\n      width: App.width,\n      height: App.height\n    }),\n    deadzone: Point(0, 0),\n    zoom: 1,\n    transform: Matrix(),\n    x: App.width / 2,\n    y: App.height / 2,\n    velocity: Point.ZERO,\n    maxSpeed: 750,\n    t90: 2\n  });\n  currentType = \"centered\";\n  currentObject = null;\n  objectFilters = [];\n  transformFilters = [];\n  focusOn = function(object, elapsedTime) {\n    var c, dampingFactor, delta, force, objectCenter, target;\n    dampingFactor = 2;\n    c = elapsedTime * 3.75 / I.t90;\n    if (c >= 1) {\n      self.position(target);\n      return I.velocity = Point.ZERO;\n    } else {\n      objectCenter = object.center();\n      target = objectCenter;\n      delta = target.subtract(self.position());\n      force = delta.subtract(I.velocity.scale(dampingFactor));\n      self.changePosition(I.velocity.scale(c).clamp(I.maxSpeed));\n      return I.velocity = I.velocity.add(force.scale(c));\n    }\n  };\n  followTypes = {\n    centered: function(object, elapsedTime) {\n      I.deadzone = Point(0, 0);\n      return focusOn(object, elapsedTime);\n    },\n    topdown: function(object, elapsedTime) {\n      var helper;\n      helper = Math.max(I.screen.width, I.screen.height) / 4;\n      I.deadzone = Point(helper, helper);\n      return focusOn(object, elapsedTime);\n    },\n    platformer: function(object, elapsedTime) {\n      var height, width;\n      width = I.screen.width / 8;\n      height = I.screen.height / 3;\n      I.deadzone = Point(width, height);\n      return focusOn(object, elapsedTime);\n    }\n  };\n  self = Core(I).extend({\n    follow: function(object, type) {\n      if (type == null) {\n        type = \"centered\";\n      }\n      currentObject = object;\n      return currentType = type;\n    },\n    objectFilterChain: function(fn) {\n      return objectFilters.push(fn);\n    },\n    transformFilterChain: function(fn) {\n      return transformFilters.push(fn);\n    },\n    screenToWorld: function(point) {\n      return self.transform().inverse().transformPoint(point);\n    }\n  });\n  self.attrAccessor(\"transform\");\n  self.bind(\"afterUpdate\", function(elapsedTime) {\n    if (currentObject) {\n      followTypes[currentType](currentObject, elapsedTime);\n    }\n    I.x = I.x.clamp(I.cameraBounds.left + I.screen.width / 2, I.cameraBounds.right - I.screen.width / 2);\n    I.y = I.y.clamp(I.cameraBounds.top + I.screen.height / 2, I.cameraBounds.bottom - I.screen.height / 2);\n    return I.transform = Matrix.translate(I.screen.width / 2 - I.x.floor(), I.screen.height / 2 - I.y.floor());\n  });\n  self.bind(\"draw\", function(canvas, objects) {\n    return canvas.withTransform(Matrix.translate(I.screen.x, I.screen.y), function(canvas) {\n      var transform;\n      canvas.clip(0, 0, I.screen.width, I.screen.height);\n      objects = objectFilters.pipeline(objects);\n      transform = transformFilters.pipeline(self.transform().copy());\n      canvas.withTransform(transform, function(canvas) {\n        self.trigger(\"beforeDraw\", canvas);\n        return objects.invoke(\"draw\", canvas);\n      });\n      return self.trigger('flash', canvas);\n    });\n  });\n  self.bind(\"overlay\", function(canvas, objects) {\n    return canvas.withTransform(Matrix.translate(I.screen.x, I.screen.y), function(canvas) {\n      canvas.clip(0, 0, I.screen.width, I.screen.height);\n      objects = objectFilters.pipeline(objects);\n      return objects.invoke(\"trigger\", \"overlay\", canvas);\n    });\n  });\n  self.include(\"Ageable\", \"Bounded\");\n  _ref = Camera.defaultModules;\n  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n    moduleName = _ref[_i];\n    self.include(\"Camera.\" + moduleName);\n  }\n  return self;\n};\n\nCamera.defaultModules = [\"ZSort\", \"Zoom\", \"Rotate\", \"Shake\", \"Flash\", \"Fade\", \"Transition\"];\n\n/**\nThe <code>Fade</code> module provides convenience methods for accessing common Engine.Flash presets.\n\n@name Fade\n@fieldOf Camera\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n@see Camera.Flash\n*/\n\n\nCamera.Fade = function(I, self) {\n  var configureFade, fadeInDefaults, fadeOutDefaults;\n  fadeInDefaults = {\n    alpha: 0,\n    color: 'black',\n    duration: 30\n  };\n  fadeOutDefaults = {\n    alpha: 1,\n    color: 'transparent',\n    duration: 30\n  };\n  configureFade = function(duration, color, alpha) {\n    I.flashDuration = duration;\n    I.flashCooldown = duration;\n    I.flashColor = Color(color);\n    return I.flashTargetAlpha = alpha;\n  };\n  return {\n    /**\n    A convenient way to set the flash effect instance variables. This provides a shorthand for fading the screen in \n    from a given color over a specified duration.\n    \n        engine.fadeIn()\n        # => Sets the effect variables to their default state. This will the screen to go from black to transparent over the next 30 frames.\n      \n        engine.fadeIn('blue', 50)\n        # => This effect will start off blue and fade to transparent over 50 frames.\n    \n    @name fadeIn\n    @methodOf Camera#\n    @param {Number} [duration=30] How long the effect lasts\n    @param {Color} [color=\"black\"] The color to fade from\n    */\n\n    fadeIn: function(options) {\n      var alpha, color, duration, _ref;\n      if (options == null) {\n        options = {};\n      }\n      _ref = Object.reverseMerge(options, fadeInDefaults), alpha = _ref.alpha, color = _ref.color, duration = _ref.duration;\n      return configureFade(duration, color, alpha);\n    },\n    /**\n    A convenient way to set the flash effect instance variables. This provides a shorthand for fading \n    the screen to a given color over a specified duration.\n    \n        camera.fadeOut()\n        # => Sets the effect variables to their default state. This will the screen to fade from ransparent to black over the next 30 frames.\n        \n        camera.fadeOut\n          color: blue\n          duration: 30\n        # => This effect will start off transparent and change to blue over 50 frames.\n    \n    @name fadeOut\n    @methodOf Camera#\n    @param {Number} [duration=30] How long the effect lasts\n    @param {Color} [color=\"transparent\"] The color to fade to\n    */\n\n    fadeOut: function(options) {\n      var alpha, color, duration, _ref;\n      if (options == null) {\n        options = {};\n      }\n      _ref = Object.reverseMerge(options, fadeOutDefaults), alpha = _ref.alpha, color = _ref.color, duration = _ref.duration;\n      return configureFade(duration, color, alpha);\n    }\n  };\n};\n\n/**\nThe <code>Flash</code> module allows you to flash a color onscreen and then fade to transparent over a time period. \nThis is nice for lightning type effects or to accentuate major game events.\n\n@name Flash\n@fieldOf Camera\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the camera\n*/\n\n\nCamera.Flash = function(I, self) {\n  var defaultParams;\n  Object.reverseMerge(I, {\n    flashColor: Color(0, 0, 0, 0),\n    flashDuration: 12,\n    flashCooldown: 0,\n    flashTargetAlpha: 0\n  });\n  defaultParams = {\n    color: 'white',\n    duration: 12,\n    targetAlpha: 0\n  };\n  self.bind('afterUpdate', function() {\n    if (I.flashCooldown > 0) {\n      I.flashColor.a = I.flashColor.a.approach(I.flashTargetAlpha, 1 / I.flashDuration).clamp(0, 1);\n      if (I.flashColor.a < 0.00001) {\n        I.flashColor.a = 0;\n      }\n      if (I.flashColor.a > 0.9999) {\n        I.flashColor.a = 1;\n      }\n      return I.flashCooldown = I.flashCooldown.approach(0, 1);\n    }\n  });\n  self.bind('flash', function(canvas) {\n    return canvas.fill(I.flashColor);\n  });\n  return {\n    /**\n    A convenient way to set the flash effect instance variables. Alternatively, you can modify them by hand, but\n    using Camera#flash is the suggested approach.\n    \n        camera.flash()\n        # => Sets the flash effect variables to their default state. This will cause a white flash that will turn transparent in the next 12 frames.\n      \n        camera.flash\n          color: 'green'\n          duration: 30\n        # => This flash effect will start off green and fade to transparent over 30 frames.\n      \n        camera.flash\n          color: Color(255, 0, 0, 0)\n          duration: 20\n          targetAlpha: 1\n        # => This flash effect will start off transparent and move toward red over 20 frames \n    \n    @name flash\n    @methodOf Camera#\n    @param {Color} [color=\"white\"] The flash color\n    @param {Number} [duration=12] How long the effect lasts\n    @param {Number} [targetAlpha=0] The alpha value to fade to. By default, this is set to 0, which fades the color to transparent.\n    */\n\n    flash: function(options) {\n      var color, duration, targetAlpha;\n      if (options == null) {\n        options = {};\n      }\n      Object.reverseMerge(options, defaultParams);\n      color = options.color, duration = options.duration, targetAlpha = options.targetAlpha;\n      I.flashColor = Color(color);\n      I.flashTargetAlpha = targetAlpha;\n      I.flashCooldown = duration;\n      I.flashDuration = duration;\n      return self;\n    }\n  };\n};\n\nCamera.Rotate = function(I, self) {\n  Object.reverseMerge(I, {\n    rotation: 0\n  });\n  self.transformFilterChain(function(transform) {\n    return transform.rotate(I.rotation, self.position());\n  });\n  self.attrAccessor(\"rotation\");\n  return {\n    rotate: function(amount) {\n      return self.rotation(I.rotation + amount);\n    }\n  };\n};\n\nCamera.Shake = function(I, self) {\n  var defaultParams;\n  Object.reverseMerge(I, {\n    shakeIntensity: 20,\n    shakeCooldown: 0\n  });\n  defaultParams = {\n    duration: 10,\n    intensity: 20\n  };\n  self.bind(\"afterUpdate\", function() {\n    return I.shakeCooldown = I.shakeCooldown.approach(0, 1);\n  });\n  self.transformFilterChain(function(transform) {\n    if (I.shakeCooldown > 0) {\n      transform.tx += signedRand(I.shakeIntensity);\n      transform.ty += signedRand(I.shakeIntensity);\n    }\n    return transform;\n  });\n  return {\n    shake: function(options) {\n      var duration, intensity, _ref;\n      if (options == null) {\n        options = {};\n      }\n      _ref = Object.reverseMerge(options, defaultParams), duration = _ref.duration, intensity = _ref.intensity;\n      I.shakeCooldown = duration * I.zoom;\n      I.shakeIntensity = intensity * I.zoom;\n      return self;\n    }\n  };\n};\n\nCameraTarget = function(I) {\n  var self;\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    target: \"Player.controller=0\",\n    lead: 1.25\n  });\n  self = GameObject(I).extend({\n    draw: function() {}\n  });\n  self.on(\"update\", function(canvas) {\n    var position, target, targetPosition, targetVelocity;\n    if (target = engine.first(I.target)) {\n      targetPosition = target.position();\n      targetVelocity = target.velocity();\n      position = targetPosition.add(targetVelocity.scale(I.lead));\n      I.x = position.x;\n      return I.y = position.y;\n    }\n  });\n  return self;\n};\n\nCamera.Transition = function(I, self) {\n  var defaultOptions, transitionProgress, transitions;\n  Object.reverseMerge(I, {\n    transitionActive: null,\n    transitionStart: null,\n    transitionEnd: null\n  });\n  defaultOptions = {\n    color: \"white\"\n  };\n  transitionProgress = function() {\n    return ((I.age - I.transitionStart) / (I.transitionEnd - I.transitionStart)).clamp(0, 1);\n  };\n  transitions = {\n    angle: function(_arg) {\n      var canvas, color, p0, p1, p2, p3, p4, screenSize, t;\n      canvas = _arg.canvas, t = _arg.t, screenSize = _arg.screenSize, color = _arg.color;\n      p0 = Point(t * (screenSize.x * 2), screenSize.y / 2);\n      p1 = p0.subtract(Point(screenSize.x, screenSize.y / 2));\n      p2 = p1.subtract(Point(screenSize.x, 0));\n      p3 = p2.add(Point(0, screenSize.y));\n      p4 = p3.add(Point(screenSize.x, 0));\n      return canvas.drawPoly({\n        points: [p0, p1, p2, p3, p4],\n        color: color\n      });\n    },\n    square: function(_arg) {\n      var canvas, color, height, screenSize, t, width;\n      canvas = _arg.canvas, t = _arg.t, screenSize = _arg.screenSize, color = _arg.color;\n      width = 50;\n      height = 50;\n      return (screenSize.y / height).ceil().times(function(y) {\n        return (screenSize.x / width).ceil().times(function(x) {\n          var cellProgress;\n          cellProgress = (2 * t - (x + y).mod(2)).clamp(0, 1);\n          return canvas.drawRect({\n            x: x * width,\n            y: y * height,\n            width: width,\n            height: height * cellProgress,\n            color: color\n          });\n        });\n      });\n    },\n    line: function(_arg) {\n      var canvas, color, height, screenSize, t;\n      canvas = _arg.canvas, t = _arg.t, screenSize = _arg.screenSize, color = _arg.color;\n      height = 50;\n      return (screenSize.y / height).ceil().times(function(y) {\n        return canvas.drawRect({\n          x: 0,\n          y: y * height,\n          width: screenSize.x,\n          height: height * t,\n          color: color\n        });\n      });\n    }\n  };\n  self.on(\"overlay\", function(canvas) {\n    var transitionName;\n    if (transitionName = I.transitionActive) {\n      return transitions[transitionName](Object.extend({\n        canvas: canvas,\n        screenSize: Point(I.screen.width, I.screen.height),\n        t: transitionProgress()\n      }, I.transitionOptions));\n    }\n  });\n  return {\n    transition: function(_arg) {\n      var duration, name, options, _ref;\n      _ref = _arg != null ? _arg : {}, name = _ref.name, duration = _ref.duration, options = _ref.options;\n      if (name == null) {\n        name = \"angle\";\n      }\n      if (duration == null) {\n        duration = 1;\n      }\n      I.transitionActive = name;\n      I.transitionStart = I.age;\n      I.transitionEnd = I.age + duration;\n      return I.transitionOptions = Object.extend({}, defaultOptions, options);\n    }\n  };\n};\n\nCamera.Zoom = function(I, self) {\n  var clampZoom;\n  Object.reverseMerge(I, {\n    maxZoom: 10,\n    minZoom: 0.1,\n    zoom: 1\n  });\n  self.transformFilterChain(function(transform) {\n    return transform.scale(I.zoom, I.zoom, self.position());\n  });\n  clampZoom = function(value) {\n    return value.clamp(I.minZoom, I.maxZoom);\n  };\n  return {\n    zoomIn: function(percentage) {\n      return self.zoom(clampZoom(I.zoom * (1 + percentage)));\n    },\n    zoomOut: function(percentage) {\n      return self.zoom(clampZoom(I.zoom * (1 - percentage)));\n    },\n    zoom: function(value) {\n      if (value != null) {\n        I.zoom = clampZoom(value);\n        return self;\n      } else {\n        return I.zoom;\n      }\n    }\n  };\n};\n\nCamera.ZSort = function(I, self) {\n  Object.reverseMerge(I, {\n    zSort: true\n  });\n  self.objectFilterChain(function(objects) {\n    if (I.zSort) {\n      objects.sort(function(a, b) {\n        return a.I.zIndex - b.I.zIndex;\n      });\n    }\n    return objects;\n  });\n  return {};\n};\n\n/**\nThe `Clampable` module provides helper methods to clamp object properties. This module is included by default in `GameObject`\n\n    player = GameObject\n      x: 40\n      y: 30\n\n    player.include Clampable\n\n@name Clampable\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Clampable = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    clampData: {}\n  });\n  self.bind(\"afterUpdate\", function() {\n    var data, property, _ref, _results;\n    _ref = I.clampData;\n    _results = [];\n    for (property in _ref) {\n      data = _ref[property];\n      _results.push(I[property] = I[property].clamp(data.min, data.max));\n    }\n    return _results;\n  });\n  return {\n    /**\n    Keep an objects attributes within a given range.\n    \n        # Player's health will be within [0, 100] at the end of every update\n        player.clamp\n          health:\n            min: 0\n            max: 100\n    \n        # Score can only be positive\n        player.clamp\n          score:\n            min: 0\n    \n    @name clamp\n    @methodOf Clampable#\n    @param {Object} data\n    */\n\n    clamp: function(data) {\n      return Object.extend(I.clampData, data);\n    },\n    /**\n    Helper to clamp the `x` and `y` properties of the object to be within a given bounds.\n    \n    @name clampToBounds\n    @methodOf Clampable#\n    @param {Rectangle} [bounds] The bounds to clamp the object's position within. Defaults to the app size if none given.\n    */\n\n    clampToBounds: function(bounds) {\n      bounds || (bounds = Rectangle({\n        x: 0,\n        y: 0,\n        width: App.width,\n        height: App.height\n      }));\n      return self.clamp({\n        x: {\n          min: bounds.x + I.width / 2,\n          max: bounds.width - I.width / 2\n        },\n        y: {\n          min: bounds.y + I.height / 2,\n          max: bounds.height - I.height / 2\n        }\n      });\n    }\n  };\n};\n\n(function() {\n  var ANY, CEILING, Collidable, DOWN, FLOOR, LEFT, NONE, RIGHT, UP, WALL, _ref, _ref1;\n  Collidable = function(I, self) {\n    Object.reverseMerge(I, {\n      allowCollisions: ANY,\n      immovable: false,\n      touching: NONE,\n      velocity: Point(0, 0),\n      mass: 1,\n      elasticity: 0\n    });\n    self.attrAccessor(\"immovable\", \"velocity\", \"mass\", \"elasticity\");\n    return {\n      solid: function(newSolid) {\n        if (newSolid != null) {\n          if (newSolid) {\n            return I.allowCollisions = ANY;\n          } else {\n            return I.allowCollisions = NONE;\n          }\n        } else {\n          return I.allowCollisions;\n        }\n      }\n    };\n  };\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"Collidable\"] = Collidable;\n  _ref = Object.extend(Collidable, {\n    NONE: 0x0000,\n    LEFT: 0x0001,\n    RIGHT: 0x0010,\n    UP: 0x0100,\n    DOWN: 0x1000\n  }), NONE = _ref.NONE, LEFT = _ref.LEFT, RIGHT = _ref.RIGHT, UP = _ref.UP, DOWN = _ref.DOWN;\n  _ref1 = Object.extend(Collidable, {\n    FLOOR: DOWN,\n    WALL: LEFT | RIGHT,\n    CEILING: UP,\n    ANY: LEFT | RIGHT | UP | DOWN\n  }), ANY = _ref1.ANY, FLOOR = _ref1.FLOOR, WALL = _ref1.WALL, CEILING = _ref1.CEILING;\n  return Object.extend(Collidable, {\n    separate: function(a, b) {\n      var aBounds, aMass, aVelocity, average, bBounds, bMass, bVelocity, deltaVelocity, normal, overlap, pushA, pushB, relativeVelocity, totalMass;\n      if (a.immovable() && b.immovable()) {\n        return;\n      }\n      aBounds = a.bounds();\n      bBounds = b.bounds();\n      aVelocity = a.velocity();\n      bVelocity = b.velocity();\n      deltaVelocity = aVelocity.subtract(bVelocity);\n      overlap = Point(0, 0);\n      if (Collision.rectangular(aBounds, bBounds)) {\n        if (deltaVelocity.x > 0) {\n          overlap.x = aBounds.x + aBounds.width - bBounds.x;\n          if (!(a.I.allowCollisions & RIGHT) || !(b.I.allowCollisions & LEFT)) {\n            overlap.x = 0;\n          } else {\n            a.I.touching |= RIGHT;\n            b.I.touching |= LEFT;\n          }\n        } else if (deltaVelocity.x < 0) {\n          overlap.x = aBounds.x - bBounds.width - bBounds.x;\n          if (!(a.I.allowCollisions & LEFT) || !(b.I.allowCollisions & RIGHT)) {\n            overlap.x = 0;\n          } else {\n            a.I.touching |= LEFT;\n            b.I.touching |= RIGHT;\n          }\n        }\n        if (deltaVelocity.y > 0) {\n          overlap.y = aBounds.y + aBounds.height - bBounds.y;\n          if (!(a.I.allowCollisions & DOWN) || !(b.I.allowCollisions & UP)) {\n            overlap.y = 0;\n          } else {\n            a.I.touching |= DOWN;\n            b.I.touching |= UP;\n          }\n        } else if (deltaVelocity.y < 0) {\n          overlap.y = aBounds.y - bBounds.height - bBounds.y;\n          if (!(a.I.allowCollisions & UP) || !(b.I.allowCollisions & DOWN)) {\n            overlap.y = 0;\n          } else {\n            a.I.touching |= UP;\n            b.I.touching |= DOWN;\n          }\n        }\n      }\n      if (!overlap.equal(Point.ZERO)) {\n        if (!a.immovable() && !b.immovable()) {\n          a.changePosition(overlap.scale(-0.5));\n          b.changePosition(overlap.scale(+0.5));\n          relativeVelocity = aVelocity.subtract(bVelocity);\n          aMass = a.mass();\n          bMass = b.mass();\n          totalMass = bMass + aMass;\n          normal = overlap.norm();\n          pushA = normal.scale(-2 * (relativeVelocity.dot(normal) * (bMass / totalMass)));\n          pushB = normal.scale(+2 * (relativeVelocity.dot(normal) * (aMass / totalMass)));\n          average = pushA.add(pushB).scale(0.5);\n          pushA.subtract$(average).scale(a.elasticity());\n          pushB.subtract$(average).scale(b.elasticity());\n          a.I.velocity = average.add(pushA);\n          b.I.velocity = average.add(pushB);\n        } else if (!a.immovable()) {\n          a.changePosition(overlap.scale(-1));\n          a.I.velocity = bVelocity.subtract(aVelocity.scale(a.elasticity()));\n        } else if (!b.immovable()) {\n          b.changePosition(overlap);\n          b.I.velocity = aVelocity.subtract(bVelocity.scale(b.elasticity()));\n        }\n        return true;\n      }\n    }\n  });\n})();\n\n(function() {\n  var Collision, collides;\n  collides = function(a, b) {\n    return Collision.rectangular(a.bounds(), b.bounds());\n  };\n  /**\n  Collision holds many useful class methods for checking geometric overlap of various objects.\n  \n  @name Collision\n  @namespace\n  */\n\n  Collision = {\n    /**\n    Collision holds many useful class methods for checking geometric overlap of various objects.\n    \n        player = engine.add\n          class: \"Player\"\n          x: 0\n          y: 0\n          width: 10\n          height: 10\n    \n        enemy = engine.add\n          class: \"Enemy\"\n          x: 5\n          y: 5\n          width: 10\n          height: 10\n    \n        enemy2 = engine.add\n          class: \"Enemy\"\n          x: -5\n          y: -5\n          width: 10\n          height: 10\n    \n        Collision.collide(player, enemy, (p, e) -> ...)\n        # => callback is called once\n    \n        Collision.collide(player, [enemy, enemy2], (p, e) -> ...)\n        # => callback is called twice\n    \n        Collision.collide(\"Player\", \"Enemy\", (p, e) -> ...)\n        # => callback is also called twice\n    \n    @name collide\n    @methodOf Collision\n    @param {Object|Array|String} groupA An object or set of objects to check collisions with\n    @param {Object|Array|String} groupB An object or set of objects to check collisions with\n    @param {Function} callback The callback to call when an object of groupA collides\n    with an object of groupB: (a, b) ->\n    @param {Function} [detectionMethod] An optional detection method to determine when two \n    objects are colliding.\n    */\n\n    collide: function(groupA, groupB, callback, detectionMethod) {\n      if (detectionMethod == null) {\n        detectionMethod = collides;\n      }\n      if (Object.isString(groupA)) {\n        groupA = engine.find(groupA);\n      } else {\n        groupA = [].concat(groupA);\n      }\n      if (Object.isString(groupB)) {\n        groupB = engine.find(groupB);\n      } else {\n        groupB = [].concat(groupB);\n      }\n      return groupA.each(function(a) {\n        return groupB.each(function(b) {\n          if (detectionMethod(a, b)) {\n            return callback(a, b);\n          }\n        });\n      });\n    },\n    /**\n    Takes two bounds objects and returns true if they collide (overlap), false otherwise.\n    Bounds objects have x, y, width and height properties.\n    \n        player = GameObject\n          x: 0\n          y: 0\n          width: 10\n          height: 10\n    \n        enemy = GameObject\n          x: 5\n          y: 5\n          width: 10\n          height: 10\n    \n        Collision.rectangular(player, enemy)\n        # => true\n    \n        Collision.rectangular(player, {x: 50, y: 40, width: 30, height: 30})\n        # => false\n    \n    @name rectangular\n    @methodOf Collision\n    @param {Object} a The first rectangle\n    @param {Object} b The second rectangle\n    @returns {Boolean} true if the rectangles overlap, false otherwise\n    */\n\n    rectangular: function(a, b) {\n      return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;\n    },\n    /**\n    Takes two circle objects and returns true if they collide (overlap), false otherwise.\n    Circle objects have x, y, and radius.\n    \n        player = GameObject\n          x: 5\n          y: 5\n          radius: 10\n    \n        enemy = GameObject\n          x: 10\n          y: 10\n          radius: 10\n    \n        farEnemy = GameObject\n          x: 500\n          y: 500\n          radius: 30\n    \n        Collision.circular(player, enemy)\n        # => true\n    \n        Collision.circular(player, farEnemy)\n        # => false\n    \n    @name circular\n    @methodOf Collision\n    @param {Object} a The first circle\n    @param {Object} b The second circle\n    @returns {Boolean} true is the circles overlap, false otherwise\n    */\n\n    circular: function(a, b) {\n      var dx, dy, r;\n      r = a.radius + b.radius;\n      dx = b.x - a.x;\n      dy = b.y - a.y;\n      return r * r >= dx * dx + dy * dy;\n    },\n    /**\n    Detects whether a line intersects a circle.\n    \n        circle = engine.add\n          class: \"circle\"\n          x: 50\n          y: 50\n          radius: 10\n    \n        Collision.rayCircle(Point(0, 0), Point(1, 0), circle)\n        # => true\n    \n    @name rayCircle\n    @methodOf Collision\n    @param {Point} source The starting position\n    @param {Point} direction A vector from the point\n    @param {Object} target The circle \n    @returns {Boolean} true if the line intersects the circle, false otherwise\n    */\n\n    rayCircle: function(source, direction, target) {\n      var dt, hit, intersection, intersectionToTarget, intersectionToTargetLength, laserToTarget, projection, projectionLength, radius;\n      radius = target.radius();\n      target = target.position();\n      laserToTarget = target.subtract(source);\n      projectionLength = direction.dot(laserToTarget);\n      if (projectionLength < 0) {\n        return false;\n      }\n      projection = direction.scale(projectionLength);\n      intersection = source.add(projection);\n      intersectionToTarget = target.subtract(intersection);\n      intersectionToTargetLength = intersectionToTarget.length();\n      if (intersectionToTargetLength < radius) {\n        hit = true;\n      }\n      if (hit) {\n        dt = Math.sqrt(radius * radius - intersectionToTargetLength * intersectionToTargetLength);\n        return hit = direction.scale(projectionLength - dt).add(source);\n      }\n    },\n    /**\n    Detects whether a line intersects a rectangle.\n    \n        rect = engine.add\n          class: \"circle\"\n          x: 50\n          y: 50\n          width: 20\n          height: 20\n    \n        Collision.rayRectangle(Point(0, 0), Point(1, 0), rect)\n        # => true\n    \n    @name rayRectangle\n    @methodOf Collision\n    @param {Point} source The starting position\n    @param {Point} direction A vector from the point\n    @param {Object} target The rectangle\n    @returns {Boolean} true if the line intersects the rectangle, false otherwise\n    */\n\n    rayRectangle: function(source, direction, target) {\n      var areaPQ0, areaPQ1, hit, p0, p1, t, tX, tY, xval, xw, yval, yw, _ref, _ref1;\n      if (!((target.xw != null) && (target.yw != null))) {\n        if ((target.width != null) && (target.height != null)) {\n          xw = target.width / 2;\n          yw = target.height / 2;\n          return Collision.rayRectangle(source, direction, {\n            x: target.x + xw,\n            y: target.y + yw,\n            xw: xw,\n            yw: yw\n          });\n        } else {\n          error(\"Bounds object isn't a rectangle\");\n          return;\n        }\n      }\n      xw = target.xw;\n      yw = target.yw;\n      if (source.x < target.x) {\n        xval = target.x - xw;\n      } else {\n        xval = target.x + xw;\n      }\n      if (source.y < target.y) {\n        yval = target.y - yw;\n      } else {\n        yval = target.y + yw;\n      }\n      if (direction.x === 0) {\n        p0 = Point(target.x - xw, yval);\n        p1 = Point(target.x + xw, yval);\n        t = (yval - source.y) / direction.y;\n      } else if (direction.y === 0) {\n        p0 = Point(xval, target.y - yw);\n        p1 = Point(xval, target.y + yw);\n        t = (xval - source.x) / direction.x;\n      } else {\n        tX = (xval - source.x) / direction.x;\n        tY = (yval - source.y) / direction.y;\n        if ((tX < tY || ((-xw < (_ref = source.x - target.x) && _ref < xw))) && !((-yw < (_ref1 = source.y - target.y) && _ref1 < yw))) {\n          p0 = Point(target.x - xw, yval);\n          p1 = Point(target.x + xw, yval);\n          t = tY;\n        } else {\n          p0 = Point(xval, target.y - yw);\n          p1 = Point(xval, target.y + yw);\n          t = tX;\n        }\n      }\n      if (t > 0) {\n        areaPQ0 = direction.cross(p0.subtract(source));\n        areaPQ1 = direction.cross(p1.subtract(source));\n        if (areaPQ0 * areaPQ1 < 0) {\n          return hit = direction.scale(t).add(source);\n        }\n      }\n    }\n  };\n  return (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"Collision\"] = Collision;\n})();\n\nthis.CollisionResponse = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  self.unbind(\".Movable\");\n  self.bind('update.Movable', function(elapsedTime) {\n    var t, unit;\n    t = (elapsedTime * I.velocity.x).abs();\n    unit = I.velocity.x.sign();\n    t.times(function() {\n      if (self.collide(unit, 0, \".solid\")) {\n        return I.velocity.x = 0;\n      } else {\n        return I.x += unit;\n      }\n    });\n    t = (elapsedTime * I.velocity.y).abs();\n    unit = I.velocity.y.sign();\n    return t.times(function() {\n      if (self.collide(0, unit, \".solid\")) {\n        return I.velocity.y = 0;\n      } else {\n        return I.y += unit;\n      }\n    });\n  });\n  return self.extend({\n    collide: function(xOffset, yOffset, className) {\n      return engine.find(className).inject(false, function(hit, block) {\n        return hit || Collision.rectangular(self.bounds(xOffset, yOffset), block.bounds());\n      });\n    }\n  });\n};\n\n(function() {\n  var Color, channelize, hslParser, hslToRgb, hsvToRgb, parseHSL, parseRGB, rgbParser;\n  rgbParser = /^rgba?\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3}),?\\s*(\\d?\\.?\\d*)?\\)$/;\n  hslParser = /^hsla?\\((\\d{1,3}),\\s*(\\d?\\.?\\d*),\\s*(\\d?\\.?\\d*),?\\s*(\\d?\\.?\\d*)?\\)$/;\n  parseRGB = function(colorString) {\n    var channel, channels, parsedColor;\n    if (!(channels = rgbParser.exec(colorString))) {\n      return void 0;\n    }\n    parsedColor = (function() {\n      var _i, _len, _ref, _results;\n      _ref = channels.slice(1, 5);\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        channel = _ref[_i];\n        _results.push(parseFloat(channel));\n      }\n      return _results;\n    })();\n    if (isNaN(parsedColor[3])) {\n      parsedColor[3] = 1;\n    }\n    return parsedColor;\n  };\n  parseHSL = function(colorString) {\n    var channel, channels, parsedColor;\n    if (!(channels = hslParser.exec(colorString))) {\n      return void 0;\n    }\n    parsedColor = (function() {\n      var _i, _len, _ref, _results;\n      _ref = channels.slice(1, 5);\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        channel = _ref[_i];\n        _results.push(parseFloat(channel));\n      }\n      return _results;\n    })();\n    if (isNaN(parsedColor[3])) {\n      parsedColor[3] = 1;\n    }\n    return hslToRgb(parsedColor);\n  };\n  hsvToRgb = function(hsv) {\n    var a, b, f, g, h, i, p, q, r, rgb, s, t, v;\n    r = g = b = null;\n    h = hsv[0], s = hsv[1], v = hsv[2], a = hsv[3];\n    if (a == null) {\n      a = 1;\n    }\n    i = (h / 60).floor();\n    f = h / 60 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch (i % 6) {\n      case 0:\n        r = v;\n        g = t;\n        b = p;\n        break;\n      case 1:\n        r = q;\n        g = v;\n        b = p;\n        break;\n      case 2:\n        r = p;\n        g = v;\n        b = t;\n        break;\n      case 3:\n        r = p;\n        g = q;\n        b = v;\n        break;\n      case 4:\n        r = t;\n        g = p;\n        b = v;\n        break;\n      case 5:\n        r = v;\n        g = p;\n        b = q;\n    }\n    rgb = [(r * 255).round(), (g * 255).round(), (b * 255).round()];\n    return rgb.concat(a);\n  };\n  hslToRgb = function(hsl) {\n    var a, b, channel, g, h, hueToRgb, l, p, q, r, rgbMap, s;\n    h = hsl[0], s = hsl[1], l = hsl[2], a = hsl[3];\n    h = h % 360;\n    if (a == null) {\n      a = 1;\n    }\n    r = g = b = null;\n    hueToRgb = function(p, q, hue) {\n      hue = hue.mod(360);\n      if (hue < 60) {\n        return p + (q - p) * (hue / 60);\n      }\n      if (hue < 180) {\n        return q;\n      }\n      if (hue < 240) {\n        return p + (q - p) * ((240 - hue) / 60);\n      }\n      return p;\n    };\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\n      p = 2 * l - q;\n      r = hueToRgb(p, q, h + 120);\n      g = hueToRgb(p, q, h);\n      b = hueToRgb(p, q, h - 120);\n    }\n    rgbMap = (function() {\n      var _i, _len, _ref, _results;\n      _ref = [r, g, b];\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        channel = _ref[_i];\n        _results.push((channel * 255).round());\n      }\n      return _results;\n    })();\n    return rgbMap.concat(a);\n  };\n  channelize = function(color, alpha) {\n    var channel, result;\n    if (color.channels != null) {\n      return color.channels();\n    }\n    if (Object.isArray(color)) {\n      if (alpha != null) {\n        alpha = parseFloat(alpha);\n      } else if (color[3] != null) {\n        alpha = parseFloat(color[3]);\n      } else {\n        alpha = 1;\n      }\n      result = ((function() {\n        var _i, _len, _ref, _results;\n        _ref = color.slice(0, 3);\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          channel = _ref[_i];\n          _results.push(parseFloat(channel));\n        }\n        return _results;\n      })()).concat(alpha);\n    } else {\n      result = (typeof Color.lookup === \"function\" ? Color.lookup(color) : void 0) || color.parseHex() || parseRGB(color) || parseHSL(color);\n      if (alpha != null) {\n        result[3] = parseFloat(alpha);\n      }\n    }\n    return result;\n  };\n  /**\n  Create a new color. The constructor is very flexible. It accepts individual r, g, b, a values,\n  arrays of r, g, b values, hex strings, rgb strings, hsl strings, other Color objects, \n  and even the named colors from the xkcd survey: http://blog.xkcd.com/2010/05/03/color-survey-results/. \n  If no arguments are given, defaults to transparent.\n  \n      individualRgb = Color(23, 56, 49, 0.4)\n    \n      arrayRgb = Color([59, 100, 230])\n    \n      hex = Color('#ff0000')\n    \n      rgb = Color('rgb(0, 255, 0)')\n    \n      hsl = Color('hsl(180, 1, 0.5)')\n    \n      anotherColor = Color('blue')\n    \n      Color(anotherColor)\n      # => a new color with the same r, g, b, and alpha values as `anotherColor`\n    \n      # You have access to all sorts of weird colors.\n      # We give you all the named colors the browser recognizes\n      # and the ones from this survey \n      # http://blog.xkcd.com/2010/05/03/color-survey-results/\n      namedBrown = Color('Fuzzy Wuzzy Brown')\n    \n      # Uutput color in Hex format \n      namedBrown.toHex()\n      # => '#c45655'\n    \n      # Default behavior\n      transparent = Color()\n    \n      transparent.toString()\n      # => 'rgba(0, 0, 0, 0)' \n    \n      # let's print out the colors on a canvas to see what they look like\n      canvas.font('14px Helvetica')\n      for color, index in ['individualRgb', 'arrayRgb', 'hex', 'rgb', 'hsl', 'anotherColor', 'namedBrown']\n        canvas.centerText\n          color: eval(color)\n          text: color\n          y: 20 * (index + 1)  \n  \n  @name Color\n  @param {Array|Number|String|Color} args... An Array, r, g, b values, \n  a sequence of numbers defining r, g, b values, a hex or hsl string, another Color object, or a named color\n  @constructor\n  */\n\n  Color = function() {\n    var args, parsedColor;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    parsedColor = (function() {\n      switch (args.length) {\n        case 0:\n          return [0, 0, 0, 0];\n        case 1:\n          return channelize(args.first());\n        case 2:\n          return channelize(args.first(), args.last());\n        default:\n          return channelize(args);\n      }\n    })();\n    if (!parsedColor) {\n      throw \"\" + (args.join(',')) + \" is an unknown color\";\n    }\n    return {\n      __proto__: Color.prototype,\n      r: parsedColor[0].round(),\n      g: parsedColor[1].round(),\n      b: parsedColor[2].round(),\n      a: parsedColor[3]\n    };\n  };\n  Color.prototype = {\n    /**\n    Returns the rgba color channels in an array.\n    \n        transparent =  Color()\n    \n        transparent.channels()\n        # => [0, 0, 0, 0]\n    \n        red = Color(\"#FF0000\")\n    \n        red.channels()\n        # => [255, 0, 0, 1]\n    \n        rgb = Color(200, 34, 2)\n    \n        rgb.channels()\n        # => [200, 34, 2, 1]\n    \n    @name channels\n    @methodOf Color#\n    \n    @returns {Array} Array of r, g, b, and alpha values of the color\n    */\n\n    channels: function() {\n      return [this.r, this.g, this.b, this.a];\n    },\n    /**\n    A copy of the calling color that is its complementary color on the color wheel.\n    \n        red = Color(255, 0, 0)\n    \n        cyan = red.complement()\n    \n        # to see what they look like\n        for color, index in [red, cyan]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60         \n    \n    @name complement\n    @methodOf Color#\n    \n    @returns {Color} new color that is a copy of the calling color with its hue shifted by 180 degrees on the color wheel\n    */\n\n    complement: function() {\n      return this.copy().complement$();\n    },\n    /**\n    Modifies the calling color to make it the complement of its previous value.\n    \n        red = Color(255, 0, 0)\n    \n        # modifies red in place to make it into cyan\n        red.complement$()\n    \n        red.toString()\n        # => 'rgba(0, 255, 255, 1)'\n    \n    @name complement$\n    @methodOf Color#\n    \n    @returns {Color} the color hue shifted by 180 degrees on the color wheel. Modifies the existing color.\n    */\n\n    complement$: function() {\n      return this.shiftHue$(180);\n    },\n    /**\n    A copy of the calling color.\n    \n        color = Color(0, 100, 200)\n    \n        copy = color.copy()\n    \n        color == copy\n        # => false\n    \n        color.equal(copy)\n        # => true\n    \n    @name copy\n    @methodOf Color#\n    \n    @returns {Color} A new color. A copy of the calling color\n    */\n\n    copy: function() {\n      return Color(this.r, this.g, this.b, this.a);\n    },\n    /**\n    Returns a copy of the calling color darkened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n        green = Color(0, 255, 0)\n    \n        darkGreen = green.darken(0.3)\n    \n        # to see what they look like\n        for color, index in [green, darkGreen]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60         \n    \n    @name darken\n    @methodOf Color#\n    @param {Number} amount Amount to darken color by (between 0 - 1)\n    \n    @returns {Color} A new color. The lightness value is reduced by `amount` from the original.\n    */\n\n    darken: function(amount) {\n      return this.copy().darken$(amount);\n    },\n    /**\n    Modifies the color so that it is darkened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n        green = Color(0, 255, 0)\n    \n        # Modifies green to be darkGreen\n        green.darken$(0.3)\n    \n        green.toString()\n        # => 'rgba(0, 102, 0, 1)'\n    \n    @name darken$\n    @methodOf Color#\n    @param {Number} amount Amount to darken color by (between 0 - 1)\n    \n    @returns {Color} the color with the lightness value reduced by `amount`\n    */\n\n    darken$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[2] -= amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },\n    /**\n    A copy of the calling color with its saturation reduced by `amount`.\n    \n        blue = Color(0, 0, 255)\n    \n        desaturatedBlue = blue.desaturate(0.4)\n    \n        # to see what they look like\n        for color, index in [blue, desaturatedBlue]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60  \n    \n    @name desaturate\n    @methodOf Color#\n    @param {Number} amount Amount to reduce color saturation by (between 0 and 1)\n    \n    @returns {Color} A copy of the color with the saturation value reduced by `amount`\n    */\n\n    desaturate: function(amount) {\n      return this.copy().desaturate$(amount);\n    },\n    /**\n    The modified color with its saturation reduced by `amount`.\n    \n        blue = Color(0, 0, 255)\n    \n        # modifies blue to be desaturatedBlue\n        blue.desaturate$(0.4)\n    \n        blue.toString()\n        # => 'rgba(38, 38, 217, 1)'\n    \n    @name desaturate$\n    @methodOf Color#\n    @param {Number} amount Amount to reduce color saturation by (between 0 and 1)\n    \n    @returns {Color} the color with the saturation value reduced by `amount`\n    */\n\n    desaturate$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[1] -= amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },\n    /**\n    Determine whether two colors are equal. Compares their r, g, b, and alpha values.\n    \n        hex = Color('#ffff00')\n        rgb = Color(255, 255, 0)\n    \n        hex == rgb\n        # => false\n    \n        hex.equal(rgb)\n        # => true\n    \n    @name equal\n    @methodOf Color#\n    @param {Color} other the color to compare to the calling color\n    \n    @returns {Boolean} true if the r, g, b, a values of the colors agree, false otherwise\n    */\n\n    equal: function(other) {\n      return other.r === this.r && other.g === this.g && other.b === this.b && other.a === this.a;\n    },\n    /**\n    A copy of the calling color converted to grayscale.\n    \n        yellow = Color(255, 255, 0)\n    \n        gray = yellow.grayscale()\n    \n        # to see what they look like\n        for color, index in [yellow, gray]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60 \n    \n    @name grayscale\n    @methodOf Color#\n    \n    @returns {Color} A copy of the calling color converted to grayscale.\n    */\n\n    grayscale: function() {\n      return this.copy().grayscale$();\n    },\n    /**\n    The calling color converted to grayscale.\n    \n        color = Color(255, 255, 0)\n    \n        # modifies color into gray\n        color.grayscale$()\n    \n        color.toString()\n        # => 'rgba(128, 128, 128, 1)'\n    \n    @name grayscale$\n    @methodOf Color#\n    \n    @returns {Color} The calling color converted to grayscale.\n    */\n\n    grayscale$: function() {\n      var g, hsl;\n      hsl = this.toHsl();\n      g = (hsl[2] * 255).round();\n      this.r = this.g = this.b = g;\n      return this;\n    },\n    /**\n    A getter / setter for the hue value of the color. Passing no argument returns the \n    current hue value. Passing a value will set the hue to that value and return the color.\n    \n        magenta = Color(255, 0, 255)\n    \n        magenta.hue()\n        # => 300\n    \n        # modifies the color to be yellow\n        magenta.hue(60)\n    \n        # to see what it looks like\n        canvas.drawRect\n          color: magenta\n          x: 50 \n          y: 30 \n          width: 80\n          height: 80 \n    \n    @name hue\n    @methodOf Color#\n    @param {Number} [newVal] the new hue value\n    \n    @returns {Color|Number} returns the color object if you pass a new hue value and returns the hue otherwise\n    */\n\n    hue: function(newVal) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      if (newVal != null) {\n        hsl[0] = newVal;\n        _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n        return this;\n      } else {\n        return hsl[0];\n      }\n    },\n    /**\n    A getter / setter for the lightness value of the color. Passing no argument returns the \n    current lightness value. Passing a value will set the lightness to that value and return the color.\n    \n        magenta = Color(255, 0, 255)\n    \n        magenta.lightness()\n        # => 0.9\n    \n        # modifies magenta in place to be lighter\n        magenta.lightness(0.75)\n    \n        # to see what it looks like\n        canvas.drawRect\n          color: magenta\n          x: 50 \n          y: 30 \n          width: 80\n          height: 80 \n    \n    @name lightness\n    @methodOf Color#\n    @param {Number} [newVal] the new lightness value\n    \n    @returns {Color|Number} returns the color object if you pass a new lightness value and returns the lightness otherwise\n    */\n\n    lightness: function(newVal) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      if (newVal != null) {\n        hsl[2] = newVal;\n        _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n        return this;\n      } else {\n        return hsl[2];\n      }\n    },\n    value: function(newVal) {\n      var hsv, _ref;\n      hsv = this.toHsv();\n      if (newVal != null) {\n        hsv[2] = newVal;\n        _ref = hsvToRgb(hsv), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n        return this;\n      } else {\n        return hsv[2];\n      }\n    },\n    /**\n    A copy of the calling color with its hue shifted by `degrees`. This differs from the hue setter in that it adds to the existing hue value and will wrap around 0 and 360.\n    \n        magenta = Color(255, 0, 255)\n    \n        magenta.hue()\n        # => 300\n    \n        yellow = magenta.shiftHue(120)\n    \n        # since magenta's hue is 300 we have wrapped\n        # around 360 to end up at 60\n        yellow.hue()\n        # => 60\n    \n        # to see what they look like\n        for color, index in [magenta, yellow]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60 \n    \n    @name shiftHue\n    @methodOf Color#\n    @param {Number} degrees number of degrees to shift the hue on the color wheel.\n    \n    @returns {Color} A copy of the color with its hue shifted by `degrees`\n    */\n\n    shiftHue: function(degrees) {\n      return this.copy().shiftHue$(degrees);\n    },\n    /**\n    The calling color with its hue shifted by `degrees`. This differs from the hue setter in that it adds to the existing hue value and will wrap around 0 and 360.\n    \n        magenta = Color(255, 0, 255)\n    \n        magenta.hue()\n        # => 300\n    \n        magenta.shiftHue$(120)\n    \n        # since magenta's hue is 300 we have wrapped\n        # around 360 to end up at 60. Also we have \n        # modified magenta in place to become yellow\n        magenta.hue()\n        # => 60\n    \n        magenta.toString()\n        # => 'rgba(255, 255, 0, 1)'\n    \n    @name shiftHue$\n    @methodOf Color#\n    @param {Number} degrees number of degrees to shift the hue on the color wheel.\n    \n    @returns {Color} The color with its hue shifted by `degrees`\n    */\n\n    shiftHue$: function(degrees) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[0] = (hsl[0] + degrees.round()).mod(360);\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },\n    /**\n    Returns a copy of the calling color lightened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n        green = Color(0, 255, 0)\n    \n        lightGreen = green.lighten(0.3)\n    \n        # to see what they look like\n        for color, index in [green, lightGreen]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60 \n    \n    @name lighten\n    @methodOf Color#\n    @param {Number} amount Amount to lighten color by (between 0 to 1)\n    \n    @returns {Color} A new color. The lightness value is increased by `amount` from the original.\n    */\n\n    lighten: function(amount) {\n      return this.copy().lighten$(amount);\n    },\n    /**\n    The calling color lightened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n        green = Color(0, 255, 0)\n    \n        green.lighten$(0.2)\n    \n        # we have modified green in place\n        # to become lightGreen\n        green.toString()\n        # => 'rgba(102, 255, 102, 1)'\n    \n    @name lighten$\n    @methodOf Color#\n    @param {Number} amount Amount to lighten color by (between 0 - 1)\n    \n    @returns {Color} The calling color with its lightness value increased by `amount`.\n    */\n\n    lighten$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[2] += amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },\n    /**\n    A copy of the calling color mixed with `other` using `amount` as the \n    mixing ratio. If amount is not passed, then the colors are mixed evenly.\n    \n        red = Color(255, 0, 0)\n        yellow = Color(255, 255, 0)\n    \n        # With no amount argument the colors are mixed evenly\n        orange = red.mixWith(yellow)\n    \n        # With an amount of 0.3 we are mixing the color 30% red and 70% yellow\n        somethingCloseToOrange = red.mixWith(yellow, 0.3)\n    \n        # to see what they look like\n        for color, index in [red, yellow, orange, somethingCloseToOrange]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * (index % 2))\n            y: 20 + (60 * (if index > 1 then 1 else 0))\n            width: 60\n            height: 60 \n    \n    @name mixWith\n    @methodOf Color#\n    @param {Color} other the other color to mix\n    @param {Number} [amount] the mixing ratio of the calling color to `other`\n    \n    @returns {Color} A new color that is a mix of the calling color and `other`\n    */\n\n    mixWith: function(other, amount) {\n      return this.copy().mixWith$(other, amount);\n    },\n    /**\n    A copy of the calling color mixed with `other` using `amount` as the \n    mixing ratio. If amount is not passed, then the colors are mixed evenly.\n    \n        red = Color(255, 0, 0)\n        yellow = Color(255, 255, 0)\n        anotherRed = Color(255, 0, 0)\n    \n        # With no amount argument the colors are mixed evenly\n        red.mixWith$(yellow)\n    \n        # We have modified red in place to be orange \n        red.toString()\n        # => 'rgba(255, 128, 0, 1)'    \n    \n        # With an amount of 0.3 we are mixing the color 30% red and 70% yellow\n        anotherRed.mixWith$(yellow, 0.3)\n    \n        # We have modified `anotherRed` in place to be somethingCloseToOrange \n        anotherRed.toString()\n        # => rgba(255, 179, 0, 1)\n    \n    @name mixWith$\n    @methodOf Color#\n    @param {Color} other the other color to mix\n    @param {Number} [amount] the mixing ratio of the calling color to `other`\n    \n    @returns {Color} The modified calling color after mixing it with `other`\n    */\n\n    mixWith$: function(other, amount) {\n      var _ref, _ref1;\n      amount || (amount = 0.5);\n      _ref = [this.r, this.g, this.b, this.a].zip([other.r, other.g, other.b, other.a]).map(function(array) {\n        return (array[0] * amount) + (array[1] * (1 - amount));\n      }), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      _ref1 = [this.r, this.g, this.b].map(function(color) {\n        return color.round();\n      }), this.r = _ref1[0], this.g = _ref1[1], this.b = _ref1[2];\n      return this;\n    },\n    /**\n    A copy of the calling color with its saturation increased by `amount`.\n    \n        color = Color(50, 50, 200)\n    \n        color.saturation()\n        # => 0.6\n    \n        saturatedColor = color.saturate(0.2)\n    \n        saturatedColor.saturation()\n        # => 0.8\n    \n        # to see what they look like\n        for color, index in [color, saturatedColor]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60 \n    \n    @name saturate\n    @methodOf Color#\n    @param {Number} amount the amount to increase saturation by\n    \n    @returns {Color} A copy of the calling color with its saturation increased by `amount`\n    */\n\n    saturate: function(amount) {\n      return this.copy().saturate$(amount);\n    },\n    /**\n    The calling color with its saturation increased by `amount`.\n    \n        color = Color(50, 50, 200)\n    \n        color.saturation()\n        # => 0.6\n    \n        color.saturate$(0.2)\n    \n        # We have modified color in place and increased its saturation to 0.8\n        color.saturation()\n        # => 0.8\n    \n        color.toString()\n        # => rgba(25, 25, 225, 1)\n    \n    @name saturate$\n    @methodOf Color#\n    @param {Number} amount the amount to increase saturation by\n    \n    @returns {Color} The calling color with its saturation increased by `amount`\n    */\n\n    saturate$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[1] += amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },\n    /**\n    A getter / setter for the saturation value of the color. Passing no argument returns the \n    current saturation value. Passing a value will set the saturation to that value and return the color.\n    \n        yellow = Color('hsl(60, 0.5, 0.5)')\n    \n        yellow.saturation()\n        # => 0.5\n    \n        yellow.saturation(0.8)\n    \n        # to see what it looks like\n        canvas.drawRect\n          color: yellow\n          x: 50 \n          y: 30 \n          width: 80\n          height: 80     \n    \n    @name saturation\n    @methodOf Color#\n    @param {Number} [newVal] the new saturation value\n    \n    @returns {Color|Number} returns the color object if you pass a new saturation value and returns the saturation otherwise\n    */\n\n    saturation: function(newVal, mode) {\n      var hsl, hsv, _ref, _ref1;\n      if (mode === 'hsv') {\n        hsv = this.toHsv();\n        if (newVal != null) {\n          hsv[1] = newVal;\n          _ref = hsvToRgb(hsv), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n          return this;\n        } else {\n          return hsv[1];\n        }\n      } else {\n        hsl = this.toHsl();\n        if (newVal != null) {\n          hsl[1] = newVal;\n          _ref1 = hslToRgb(hsl), this.r = _ref1[0], this.g = _ref1[1], this.b = _ref1[2], this.a = _ref1[3];\n          return this;\n        } else {\n          return hsl[1];\n        }\n      }\n    },\n    /**\n    returns the Hex representation of the color. Exclude the leading `#` by passing false. \n    \n        color = Color('hsl(60, 1, 0.5)')\n    \n        # passing nothing will leave the `#` intact\n        color.toHex()\n        # => '#ffff00'\n    \n        # passing false will remove the `#`\n        color.toHex(false)\n        # => 'ffff00'\n    \n    @name toHex\n    @methodOf Color#\n    @param {Boolean} [leadingHash] if passed as false excludes the leading `#` from the string\n    \n    @returns {String} returns the Hex representation of the color\n    */\n\n    toHex: function(leadingHash) {\n      var hexFromNumber, padString;\n      padString = function(hexString) {\n        var pad;\n        if (hexString.length === 1) {\n          pad = \"0\";\n        } else {\n          pad = \"\";\n        }\n        return pad + hexString;\n      };\n      hexFromNumber = function(number) {\n        return padString(number.toString(16));\n      };\n      if (leadingHash === false) {\n        return \"\" + (hexFromNumber(this.r)) + (hexFromNumber(this.g)) + (hexFromNumber(this.b));\n      } else {\n        return \"#\" + (hexFromNumber(this.r)) + (hexFromNumber(this.g)) + (hexFromNumber(this.b));\n      }\n    },\n    /**\n    returns an array of the hue, saturation, lightness, and alpha values of the color. \n    \n        magenta = Color(255, 0, 255)\n    \n        magenta.toHsl()\n        # => [300, 1, 0.5, 1]\n    \n    @name toHsl\n    @methodOf Color#\n    \n    @returns {Array} An array of the hue, saturation, lightness, and alpha values of the color.\n    */\n\n    toHsl: function() {\n      var b, channel, chroma, g, hue, lightness, max, min, r, saturation, _ref, _ref1;\n      _ref = (function() {\n        var _i, _len, _ref, _results;\n        _ref = [this.r, this.g, this.b];\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          channel = _ref[_i];\n          _results.push(channel / 255);\n        }\n        return _results;\n      }).call(this), r = _ref[0], g = _ref[1], b = _ref[2];\n      _ref1 = [r, g, b].extremes(), min = _ref1.min, max = _ref1.max;\n      hue = saturation = lightness = (max + min) / 2;\n      chroma = max - min;\n      if (chroma.abs() < 0.00001) {\n        hue = saturation = 0;\n      } else {\n        saturation = lightness > 0.5 ? chroma / (1 - lightness) : chroma / lightness;\n        saturation /= 2;\n        switch (max) {\n          case r:\n            hue = ((g - b) / chroma) + 0;\n            break;\n          case g:\n            hue = ((b - r) / chroma) + 2;\n            break;\n          case b:\n            hue = ((r - g) / chroma) + 4;\n        }\n        hue = (hue * 60).mod(360);\n      }\n      return [hue, saturation, lightness, this.a];\n    },\n    toHsv: function() {\n      var b, d, g, h, max, min, r, s, v, _ref;\n      r = this.r / 255;\n      g = this.g / 255;\n      b = this.b / 255;\n      _ref = [r, g, b].extremes(), min = _ref.min, max = _ref.max;\n      h = s = v = max;\n      d = max - min;\n      s = (max === 0 ? 0 : d / max);\n      if (max === min) {\n        h = 0;\n      } else {\n        switch (max) {\n          case r:\n            h = (g - b) / d + (g < b ? 6 : 0);\n            break;\n          case g:\n            h = (b - r) / d + 2;\n            break;\n          case b:\n            h = (r - g) / d + 4;\n        }\n        h *= 60;\n      }\n      return [h, s, v];\n    },\n    /**\n    returns string rgba representation of the color. \n    \n        red = Color('#ff0000')\n    \n        red.toString()\n        # => 'rgba(255, 0, 0, 1)'\n    \n    @name toString\n    @methodOf Color#\n    \n    @returns {String} The rgba string representation of the color\n    */\n\n    toString: function() {\n      return \"rgba(\" + this.r + \", \" + this.g + \", \" + this.b + \", \" + this.a + \")\";\n    },\n    /**\n    A copy of the calling color with its alpha reduced by `amount`.\n    \n        color = Color(0, 0, 0, 1)\n    \n        color.a\n        # => 1\n    \n        transparentColor = color.transparentize(0.5)\n    \n        transparentColor.a\n        # => 0.5\n    \n        # to see what they look like\n        for color, index in [color, transparentColor]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60     \n    \n    @name transparentize\n    @methodOf Color#\n    \n    @returns {Color} A copy of the calling color with its alpha reduced by `amount`\n    */\n\n    transparentize: function(amount) {\n      return this.copy().transparentize$(amount);\n    },\n    /**\n    The calling color with its alpha reduced by `amount`.\n    \n        color = Color(0, 0, 0, 1)\n    \n        color.a\n        # => 1\n    \n        # We modify color in place\n        color.transparentize$(0.5)\n    \n        color.a\n        # => 0.5\n    \n    @name transparentize$\n    @methodOf Color#\n    \n    @returns {Color} The calling color with its alpha reduced by `amount`\n    */\n\n    transparentize$: function(amount) {\n      this.a = (this.a - amount).clamp(0, 1);\n      return this;\n    },\n    /**\n    A copy of the calling color with its alpha increased by `amount`.\n    \n        color = Color(0, 0, 0, 0.25)\n    \n        color.a\n        # => 0.25\n    \n        opaqueColor = color.opacify(0.5)\n    \n        opaqueColor.a\n        # => 0.75\n    \n        # to see what they look like\n        for color, index in [color, opaqueColor]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60     \n    \n    @name opacify\n    @methodOf Color#\n    \n    @returns {Color} A copy of the calling color with its alpha increased by `amount`\n    */\n\n    opacify: function(amount) {\n      return this.copy().opacify$(amount);\n    },\n    /**\n    The calling color with its alpha increased by `amount`.\n    \n        color = Color(0, 0, 0, 0)\n    \n        color.a\n        # => 0\n    \n        # We modify color in place\n        color.opacify$(0.25)\n    \n        color.a\n        # => 0.25\n    \n    @name opacify$\n    @methodOf Color#\n    \n    @returns {Color} The calling color with its alpha increased by `amount`\n    */\n\n    opacify$: function(amount) {\n      this.a = (this.a + amount).clamp(0, 1);\n      return this;\n    }\n  };\n  /**\n  returns a random color.\n  \n      Color.random().toString()\n      # => 'rgba(213, 144, 202, 1)'\n    \n      Color.random().toString()\n      # => 'rgba(1, 211, 24, 1)'\n  \n  @name random\n  @methodOf Color\n  \n  @returns {Color} A random color.\n  */\n\n  Color.random = function() {\n    return Color(rand(256), rand(256), rand(256));\n  };\n  /**\n  Mix two colors. Behaves just like `#mixWith` except that you are passing two colors.\n  \n      red = Color(255, 0, 0)\n      yellow = Color(255, 255, 0)\n    \n      # With no amount argument the colors are mixed evenly\n      orange = Color.mix(red, yellow)\n    \n      orange.toString()\n      # => 'rgba(255, 128, 0, 1)'    \n    \n      # With an amount of 0.3 we are mixing the color 30% red and 70% yellow\n      somethingCloseToOrange = Color.mix(red, yellow, 0.3)\n    \n      somethingCloseToOrange.toString()\n      # => rgba(255, 179, 0, 1)\n  \n  @name mix\n  @methodOf Color\n  @see Color#mixWith\n  @param {Color} color1 the first color to mix\n  @param {Color} color2 the second color to mix\n  @param {Number} amount the ratio to mix the colors \n  \n  @returns {Color} A new color that is the two colors mixed at the ratio defined by `amount`\n  */\n\n  Color.mix = function(color1, color2, amount) {\n    var newColors;\n    amount || (amount = 0.5);\n    newColors = [color1.r, color1.g, color1.b, color1.a].zip([color2.r, color2.g, color2.b, color2.a]).map(function(array) {\n      return (array[0] * amount) + (array[1] * (1 - amount));\n    });\n    return Color(newColors);\n  };\n  return (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"Color\"] = Color;\n})();\n\n(function() {\n  var lookup, names, normalizeKey;\n  names = [[\"000000\", \"Black\"], [\"000080\", \"Navy Blue\"], [\"0000C8\", \"Dark Blue\"], [\"0000FF\", \"Blue\"], [\"000741\", \"Stratos\"], [\"001B1C\", \"Swamp\"], [\"002387\", \"Resolution Blue\"], [\"002900\", \"Deep Fir\"], [\"002E20\", \"Burnham\"], [\"002FA7\", \"International Klein Blue\"], [\"003153\", \"Prussian Blue\"], [\"003366\", \"Midnight Blue\"], [\"003399\", \"Smalt\"], [\"003532\", \"Deep Teal\"], [\"003E40\", \"Cyprus\"], [\"004620\", \"Kaitoke Green\"], [\"0047AB\", \"Cobalt\"], [\"004816\", \"Crusoe\"], [\"004950\", \"Sherpa Blue\"], [\"0056A7\", \"Endeavour\"], [\"00581A\", \"Camarone\"], [\"0066CC\", \"Science Blue\"], [\"0066FF\", \"Blue Ribbon\"], [\"00755E\", \"Tropical Rain Forest\"], [\"0076A3\", \"Allports\"], [\"007BA7\", \"Deep Cerulean\"], [\"007EC7\", \"Lochmara\"], [\"007FFF\", \"Azure Radiance\"], [\"008080\", \"Teal\"], [\"0095B6\", \"Bondi Blue\"], [\"009DC4\", \"Pacific Blue\"], [\"00A693\", \"Persian Green\"], [\"00A86B\", \"Jade\"], [\"00CC99\", \"Caribbean Green\"], [\"00CCCC\", \"Robin's Egg Blue\"], [\"00FF00\", \"Green\"], [\"00FF7F\", \"Spring Green\"], [\"00FFFF\", \"Cyan / Aqua\"], [\"010D1A\", \"Blue Charcoal\"], [\"011635\", \"Midnight\"], [\"011D13\", \"Holly\"], [\"012731\", \"Daintree\"], [\"01361C\", \"Cardin Green\"], [\"01371A\", \"County Green\"], [\"013E62\", \"Astronaut Blue\"], [\"013F6A\", \"Regal Blue\"], [\"014B43\", \"Aqua Deep\"], [\"015E85\", \"Orient\"], [\"016162\", \"Blue Stone\"], [\"016D39\", \"Fun Green\"], [\"01796F\", \"Pine Green\"], [\"017987\", \"Blue Lagoon\"], [\"01826B\", \"Deep Sea\"], [\"01A368\", \"Green Haze\"], [\"022D15\", \"English Holly\"], [\"02402C\", \"Sherwood Green\"], [\"02478E\", \"Congress Blue\"], [\"024E46\", \"Evening Sea\"], [\"026395\", \"Bahama Blue\"], [\"02866F\", \"Observatory\"], [\"02A4D3\", \"Cerulean\"], [\"03163C\", \"Tangaroa\"], [\"032B52\", \"Green Vogue\"], [\"036A6E\", \"Mosque\"], [\"041004\", \"Midnight Moss\"], [\"041322\", \"Black Pearl\"], [\"042E4C\", \"Blue Whale\"], [\"044022\", \"Zuccini\"], [\"044259\", \"Teal Blue\"], [\"051040\", \"Deep Cove\"], [\"051657\", \"Gulf Blue\"], [\"055989\", \"Venice Blue\"], [\"056F57\", \"Watercourse\"], [\"062A78\", \"Catalina Blue\"], [\"063537\", \"Tiber\"], [\"069B81\", \"Gossamer\"], [\"06A189\", \"Niagara\"], [\"073A50\", \"Tarawera\"], [\"080110\", \"Jaguar\"], [\"081910\", \"Black Bean\"], [\"082567\", \"Deep Sapphire\"], [\"088370\", \"Elf Green\"], [\"08E8DE\", \"Bright Turquoise\"], [\"092256\", \"Downriver\"], [\"09230F\", \"Palm Green\"], [\"09255D\", \"Madison\"], [\"093624\", \"Bottle Green\"], [\"095859\", \"Deep Sea Green\"], [\"097F4B\", \"Salem\"], [\"0A001C\", \"Black Russian\"], [\"0A480D\", \"Dark Fern\"], [\"0A6906\", \"Japanese Laurel\"], [\"0A6F75\", \"Atoll\"], [\"0B0B0B\", \"Cod Gray\"], [\"0B0F08\", \"Marshland\"], [\"0B1107\", \"Gordons Green\"], [\"0B1304\", \"Black Forest\"], [\"0B6207\", \"San Felix\"], [\"0BDA51\", \"Malachite\"], [\"0C0B1D\", \"Ebony\"], [\"0C0D0F\", \"Woodsmoke\"], [\"0C1911\", \"Racing Green\"], [\"0C7A79\", \"Surfie Green\"], [\"0C8990\", \"Blue Chill\"], [\"0D0332\", \"Black Rock\"], [\"0D1117\", \"Bunker\"], [\"0D1C19\", \"Aztec\"], [\"0D2E1C\", \"Bush\"], [\"0E0E18\", \"Cinder\"], [\"0E2A30\", \"Firefly\"], [\"0F2D9E\", \"Torea Bay\"], [\"10121D\", \"Vulcan\"], [\"101405\", \"Green Waterloo\"], [\"105852\", \"Eden\"], [\"110C6C\", \"Arapawa\"], [\"120A8F\", \"Ultramarine\"], [\"123447\", \"Elephant\"], [\"126B40\", \"Jewel\"], [\"130000\", \"Diesel\"], [\"130A06\", \"Asphalt\"], [\"13264D\", \"Blue Zodiac\"], [\"134F19\", \"Parsley\"], [\"140600\", \"Nero\"], [\"1450AA\", \"Tory Blue\"], [\"151F4C\", \"Bunting\"], [\"1560BD\", \"Denim\"], [\"15736B\", \"Genoa\"], [\"161928\", \"Mirage\"], [\"161D10\", \"Hunter Green\"], [\"162A40\", \"Big Stone\"], [\"163222\", \"Celtic\"], [\"16322C\", \"Timber Green\"], [\"163531\", \"Gable Green\"], [\"171F04\", \"Pine Tree\"], [\"175579\", \"Chathams Blue\"], [\"182D09\", \"Deep Forest Green\"], [\"18587A\", \"Blumine\"], [\"19330E\", \"Palm Leaf\"], [\"193751\", \"Nile Blue\"], [\"1959A8\", \"Fun Blue\"], [\"1A1A68\", \"Lucky Point\"], [\"1AB385\", \"Mountain Meadow\"], [\"1B0245\", \"Tolopea\"], [\"1B1035\", \"Haiti\"], [\"1B127B\", \"Deep Koamaru\"], [\"1B1404\", \"Acadia\"], [\"1B2F11\", \"Seaweed\"], [\"1B3162\", \"Biscay\"], [\"1B659D\", \"Matisse\"], [\"1C1208\", \"Crowshead\"], [\"1C1E13\", \"Rangoon Green\"], [\"1C39BB\", \"Persian Blue\"], [\"1C402E\", \"Everglade\"], [\"1C7C7D\", \"Elm\"], [\"1D6142\", \"Green Pea\"], [\"1E0F04\", \"Creole\"], [\"1E1609\", \"Karaka\"], [\"1E1708\", \"El Paso\"], [\"1E385B\", \"Cello\"], [\"1E433C\", \"Te Papa Green\"], [\"1E90FF\", \"Dodger Blue\"], [\"1E9AB0\", \"Eastern Blue\"], [\"1F120F\", \"Night Rider\"], [\"1FC2C2\", \"Java\"], [\"20208D\", \"Jacksons Purple\"], [\"202E54\", \"Cloud Burst\"], [\"204852\", \"Blue Dianne\"], [\"211A0E\", \"Eternity\"], [\"220878\", \"Deep Blue\"], [\"228B22\", \"Forest Green\"], [\"233418\", \"Mallard\"], [\"240A40\", \"Violet\"], [\"240C02\", \"Kilamanjaro\"], [\"242A1D\", \"Log Cabin\"], [\"242E16\", \"Black Olive\"], [\"24500F\", \"Green House\"], [\"251607\", \"Graphite\"], [\"251706\", \"Cannon Black\"], [\"251F4F\", \"Port Gore\"], [\"25272C\", \"Shark\"], [\"25311C\", \"Green Kelp\"], [\"2596D1\", \"Curious Blue\"], [\"260368\", \"Paua\"], [\"26056A\", \"Paris M\"], [\"261105\", \"Wood Bark\"], [\"261414\", \"Gondola\"], [\"262335\", \"Steel Gray\"], [\"26283B\", \"Ebony Clay\"], [\"273A81\", \"Bay of Many\"], [\"27504B\", \"Plantation\"], [\"278A5B\", \"Eucalyptus\"], [\"281E15\", \"Oil\"], [\"283A77\", \"Astronaut\"], [\"286ACD\", \"Mariner\"], [\"290C5E\", \"Violent Violet\"], [\"292130\", \"Bastille\"], [\"292319\", \"Zeus\"], [\"292937\", \"Charade\"], [\"297B9A\", \"Jelly Bean\"], [\"29AB87\", \"Jungle Green\"], [\"2A0359\", \"Cherry Pie\"], [\"2A140E\", \"Coffee Bean\"], [\"2A2630\", \"Baltic Sea\"], [\"2A380B\", \"Turtle Green\"], [\"2A52BE\", \"Cerulean Blue\"], [\"2B0202\", \"Sepia Black\"], [\"2B194F\", \"Valhalla\"], [\"2B3228\", \"Heavy Metal\"], [\"2C0E8C\", \"Blue Gem\"], [\"2C1632\", \"Revolver\"], [\"2C2133\", \"Bleached Cedar\"], [\"2C8C84\", \"Lochinvar\"], [\"2D2510\", \"Mikado\"], [\"2D383A\", \"Outer Space\"], [\"2D569B\", \"St Tropaz\"], [\"2E0329\", \"Jacaranda\"], [\"2E1905\", \"Jacko Bean\"], [\"2E3222\", \"Rangitoto\"], [\"2E3F62\", \"Rhino\"], [\"2E8B57\", \"Sea Green\"], [\"2EBFD4\", \"Scooter\"], [\"2F270E\", \"Onion\"], [\"2F3CB3\", \"Governor Bay\"], [\"2F519E\", \"Sapphire\"], [\"2F5A57\", \"Spectra\"], [\"2F6168\", \"Casal\"], [\"300529\", \"Melanzane\"], [\"301F1E\", \"Cocoa Brown\"], [\"302A0F\", \"Woodrush\"], [\"304B6A\", \"San Juan\"], [\"30D5C8\", \"Turquoise\"], [\"311C17\", \"Eclipse\"], [\"314459\", \"Pickled Bluewood\"], [\"315BA1\", \"Azure\"], [\"31728D\", \"Calypso\"], [\"317D82\", \"Paradiso\"], [\"32127A\", \"Persian Indigo\"], [\"32293A\", \"Blackcurrant\"], [\"323232\", \"Mine Shaft\"], [\"325D52\", \"Stromboli\"], [\"327C14\", \"Bilbao\"], [\"327DA0\", \"Astral\"], [\"33036B\", \"Christalle\"], [\"33292F\", \"Thunder\"], [\"33CC99\", \"Shamrock\"], [\"341515\", \"Tamarind\"], [\"350036\", \"Mardi Gras\"], [\"350E42\", \"Valentino\"], [\"350E57\", \"Jagger\"], [\"353542\", \"Tuna\"], [\"354E8C\", \"Chambray\"], [\"363050\", \"Martinique\"], [\"363534\", \"Tuatara\"], [\"363C0D\", \"Waiouru\"], [\"36747D\", \"Ming\"], [\"368716\", \"La Palma\"], [\"370202\", \"Chocolate\"], [\"371D09\", \"Clinker\"], [\"37290E\", \"Brown Tumbleweed\"], [\"373021\", \"Birch\"], [\"377475\", \"Oracle\"], [\"380474\", \"Blue Diamond\"], [\"381A51\", \"Grape\"], [\"383533\", \"Dune\"], [\"384555\", \"Oxford Blue\"], [\"384910\", \"Clover\"], [\"394851\", \"Limed Spruce\"], [\"396413\", \"Dell\"], [\"3A0020\", \"Toledo\"], [\"3A2010\", \"Sambuca\"], [\"3A2A6A\", \"Jacarta\"], [\"3A686C\", \"William\"], [\"3A6A47\", \"Killarney\"], [\"3AB09E\", \"Keppel\"], [\"3B000B\", \"Temptress\"], [\"3B0910\", \"Aubergine\"], [\"3B1F1F\", \"Jon\"], [\"3B2820\", \"Treehouse\"], [\"3B7A57\", \"Amazon\"], [\"3B91B4\", \"Boston Blue\"], [\"3C0878\", \"Windsor\"], [\"3C1206\", \"Rebel\"], [\"3C1F76\", \"Meteorite\"], [\"3C2005\", \"Dark Ebony\"], [\"3C3910\", \"Camouflage\"], [\"3C4151\", \"Bright Gray\"], [\"3C4443\", \"Cape Cod\"], [\"3C493A\", \"Lunar Green\"], [\"3D0C02\", \"Bean  \"], [\"3D2B1F\", \"Bistre\"], [\"3D7D52\", \"Goblin\"], [\"3E0480\", \"Kingfisher Daisy\"], [\"3E1C14\", \"Cedar\"], [\"3E2B23\", \"English Walnut\"], [\"3E2C1C\", \"Black Marlin\"], [\"3E3A44\", \"Ship Gray\"], [\"3EABBF\", \"Pelorous\"], [\"3F2109\", \"Bronze\"], [\"3F2500\", \"Cola\"], [\"3F3002\", \"Madras\"], [\"3F307F\", \"Minsk\"], [\"3F4C3A\", \"Cabbage Pont\"], [\"3F583B\", \"Tom Thumb\"], [\"3F5D53\", \"Mineral Green\"], [\"3FC1AA\", \"Puerto Rico\"], [\"3FFF00\", \"Harlequin\"], [\"401801\", \"Brown Pod\"], [\"40291D\", \"Cork\"], [\"403B38\", \"Masala\"], [\"403D19\", \"Thatch Green\"], [\"405169\", \"Fiord\"], [\"40826D\", \"Viridian\"], [\"40A860\", \"Chateau Green\"], [\"410056\", \"Ripe Plum\"], [\"411F10\", \"Paco\"], [\"412010\", \"Deep Oak\"], [\"413C37\", \"Merlin\"], [\"414257\", \"Gun Powder\"], [\"414C7D\", \"East Bay\"], [\"4169E1\", \"Royal Blue\"], [\"41AA78\", \"Ocean Green\"], [\"420303\", \"Burnt Maroon\"], [\"423921\", \"Lisbon Brown\"], [\"427977\", \"Faded Jade\"], [\"431560\", \"Scarlet Gum\"], [\"433120\", \"Iroko\"], [\"433E37\", \"Armadillo\"], [\"434C59\", \"River Bed\"], [\"436A0D\", \"Green Leaf\"], [\"44012D\", \"Barossa\"], [\"441D00\", \"Morocco Brown\"], [\"444954\", \"Mako\"], [\"454936\", \"Kelp\"], [\"456CAC\", \"San Marino\"], [\"45B1E8\", \"Picton Blue\"], [\"460B41\", \"Loulou\"], [\"462425\", \"Crater Brown\"], [\"465945\", \"Gray Asparagus\"], [\"4682B4\", \"Steel Blue\"], [\"480404\", \"Rustic Red\"], [\"480607\", \"Bulgarian Rose\"], [\"480656\", \"Clairvoyant\"], [\"481C1C\", \"Cocoa Bean\"], [\"483131\", \"Woody Brown\"], [\"483C32\", \"Taupe\"], [\"49170C\", \"Van Cleef\"], [\"492615\", \"Brown Derby\"], [\"49371B\", \"Metallic Bronze\"], [\"495400\", \"Verdun Green\"], [\"496679\", \"Blue Bayoux\"], [\"497183\", \"Bismark\"], [\"4A2A04\", \"Bracken\"], [\"4A3004\", \"Deep Bronze\"], [\"4A3C30\", \"Mondo\"], [\"4A4244\", \"Tundora\"], [\"4A444B\", \"Gravel\"], [\"4A4E5A\", \"Trout\"], [\"4B0082\", \"Pigment Indigo\"], [\"4B5D52\", \"Nandor\"], [\"4C3024\", \"Saddle\"], [\"4C4F56\", \"Abbey\"], [\"4D0135\", \"Blackberry\"], [\"4D0A18\", \"Cab Sav\"], [\"4D1E01\", \"Indian Tan\"], [\"4D282D\", \"Cowboy\"], [\"4D282E\", \"Livid Brown\"], [\"4D3833\", \"Rock\"], [\"4D3D14\", \"Punga\"], [\"4D400F\", \"Bronzetone\"], [\"4D5328\", \"Woodland\"], [\"4E0606\", \"Mahogany\"], [\"4E2A5A\", \"Bossanova\"], [\"4E3B41\", \"Matterhorn\"], [\"4E420C\", \"Bronze Olive\"], [\"4E4562\", \"Mulled Wine\"], [\"4E6649\", \"Axolotl\"], [\"4E7F9E\", \"Wedgewood\"], [\"4EABD1\", \"Shakespeare\"], [\"4F1C70\", \"Honey Flower\"], [\"4F2398\", \"Daisy Bush\"], [\"4F69C6\", \"Indigo\"], [\"4F7942\", \"Fern Green\"], [\"4F9D5D\", \"Fruit Salad\"], [\"4FA83D\", \"Apple\"], [\"504351\", \"Mortar\"], [\"507096\", \"Kashmir Blue\"], [\"507672\", \"Cutty Sark\"], [\"50C878\", \"Emerald\"], [\"514649\", \"Emperor\"], [\"516E3D\", \"Chalet Green\"], [\"517C66\", \"Como\"], [\"51808F\", \"Smalt Blue\"], [\"52001F\", \"Castro\"], [\"520C17\", \"Maroon Oak\"], [\"523C94\", \"Gigas\"], [\"533455\", \"Voodoo\"], [\"534491\", \"Victoria\"], [\"53824B\", \"Hippie Green\"], [\"541012\", \"Heath\"], [\"544333\", \"Judge Gray\"], [\"54534D\", \"Fuscous Gray\"], [\"549019\", \"Vida Loca\"], [\"55280C\", \"Cioccolato\"], [\"555B10\", \"Saratoga\"], [\"556D56\", \"Finlandia\"], [\"5590D9\", \"Havelock Blue\"], [\"56B4BE\", \"Fountain Blue\"], [\"578363\", \"Spring Leaves\"], [\"583401\", \"Saddle Brown\"], [\"585562\", \"Scarpa Flow\"], [\"587156\", \"Cactus\"], [\"589AAF\", \"Hippie Blue\"], [\"591D35\", \"Wine Berry\"], [\"592804\", \"Brown Bramble\"], [\"593737\", \"Congo Brown\"], [\"594433\", \"Millbrook\"], [\"5A6E9C\", \"Waikawa Gray\"], [\"5A87A0\", \"Horizon\"], [\"5B3013\", \"Jambalaya\"], [\"5C0120\", \"Bordeaux\"], [\"5C0536\", \"Mulberry Wood\"], [\"5C2E01\", \"Carnaby Tan\"], [\"5C5D75\", \"Comet\"], [\"5D1E0F\", \"Redwood\"], [\"5D4C51\", \"Don Juan\"], [\"5D5C58\", \"Chicago\"], [\"5D5E37\", \"Verdigris\"], [\"5D7747\", \"Dingley\"], [\"5DA19F\", \"Breaker Bay\"], [\"5E483E\", \"Kabul\"], [\"5E5D3B\", \"Hemlock\"], [\"5F3D26\", \"Irish Coffee\"], [\"5F5F6E\", \"Mid Gray\"], [\"5F6672\", \"Shuttle Gray\"], [\"5FA777\", \"Aqua Forest\"], [\"5FB3AC\", \"Tradewind\"], [\"604913\", \"Horses Neck\"], [\"605B73\", \"Smoky\"], [\"606E68\", \"Corduroy\"], [\"6093D1\", \"Danube\"], [\"612718\", \"Espresso\"], [\"614051\", \"Eggplant\"], [\"615D30\", \"Costa Del Sol\"], [\"61845F\", \"Glade Green\"], [\"622F30\", \"Buccaneer\"], [\"623F2D\", \"Quincy\"], [\"624E9A\", \"Butterfly Bush\"], [\"625119\", \"West Coast\"], [\"626649\", \"Finch\"], [\"639A8F\", \"Patina\"], [\"63B76C\", \"Fern\"], [\"6456B7\", \"Blue Violet\"], [\"646077\", \"Dolphin\"], [\"646463\", \"Storm Dust\"], [\"646A54\", \"Siam\"], [\"646E75\", \"Nevada\"], [\"6495ED\", \"Cornflower Blue\"], [\"64CCDB\", \"Viking\"], [\"65000B\", \"Rosewood\"], [\"651A14\", \"Cherrywood\"], [\"652DC1\", \"Purple Heart\"], [\"657220\", \"Fern Frond\"], [\"65745D\", \"Willow Grove\"], [\"65869F\", \"Hoki\"], [\"660045\", \"Pompadour\"], [\"660099\", \"Purple\"], [\"66023C\", \"Tyrian Purple\"], [\"661010\", \"Dark Tan\"], [\"66B58F\", \"Silver Tree\"], [\"66FF00\", \"Bright Green\"], [\"66FF66\", \"Screamin' Green\"], [\"67032D\", \"Black Rose\"], [\"675FA6\", \"Scampi\"], [\"676662\", \"Ironside Gray\"], [\"678975\", \"Viridian Green\"], [\"67A712\", \"Christi\"], [\"683600\", \"Nutmeg Wood Finish\"], [\"685558\", \"Zambezi\"], [\"685E6E\", \"Salt Box\"], [\"692545\", \"Tawny Port\"], [\"692D54\", \"Finn\"], [\"695F62\", \"Scorpion\"], [\"697E9A\", \"Lynch\"], [\"6A442E\", \"Spice\"], [\"6A5D1B\", \"Himalaya\"], [\"6A6051\", \"Soya Bean\"], [\"6B2A14\", \"Hairy Heath\"], [\"6B3FA0\", \"Royal Purple\"], [\"6B4E31\", \"Shingle Fawn\"], [\"6B5755\", \"Dorado\"], [\"6B8BA2\", \"Bermuda Gray\"], [\"6B8E23\", \"Olive Drab\"], [\"6C3082\", \"Eminence\"], [\"6CDAE7\", \"Turquoise Blue\"], [\"6D0101\", \"Lonestar\"], [\"6D5E54\", \"Pine Cone\"], [\"6D6C6C\", \"Dove Gray\"], [\"6D9292\", \"Juniper\"], [\"6D92A1\", \"Gothic\"], [\"6E0902\", \"Red Oxide\"], [\"6E1D14\", \"Moccaccino\"], [\"6E4826\", \"Pickled Bean\"], [\"6E4B26\", \"Dallas\"], [\"6E6D57\", \"Kokoda\"], [\"6E7783\", \"Pale Sky\"], [\"6F440C\", \"Cafe Royale\"], [\"6F6A61\", \"Flint\"], [\"6F8E63\", \"Highland\"], [\"6F9D02\", \"Limeade\"], [\"6FD0C5\", \"Downy\"], [\"701C1C\", \"Persian Plum\"], [\"704214\", \"Sepia\"], [\"704A07\", \"Antique Bronze\"], [\"704F50\", \"Ferra\"], [\"706555\", \"Coffee\"], [\"708090\", \"Slate Gray\"], [\"711A00\", \"Cedar Wood Finish\"], [\"71291D\", \"Metallic Copper\"], [\"714693\", \"Affair\"], [\"714AB2\", \"Studio\"], [\"715D47\", \"Tobacco Brown\"], [\"716338\", \"Yellow Metal\"], [\"716B56\", \"Peat\"], [\"716E10\", \"Olivetone\"], [\"717486\", \"Storm Gray\"], [\"718080\", \"Sirocco\"], [\"71D9E2\", \"Aquamarine Blue\"], [\"72010F\", \"Venetian Red\"], [\"724A2F\", \"Old Copper\"], [\"726D4E\", \"Go Ben\"], [\"727B89\", \"Raven\"], [\"731E8F\", \"Seance\"], [\"734A12\", \"Raw Umber\"], [\"736C9F\", \"Kimberly\"], [\"736D58\", \"Crocodile\"], [\"737829\", \"Crete\"], [\"738678\", \"Xanadu\"], [\"74640D\", \"Spicy Mustard\"], [\"747D63\", \"Limed Ash\"], [\"747D83\", \"Rolling Stone\"], [\"748881\", \"Blue Smoke\"], [\"749378\", \"Laurel\"], [\"74C365\", \"Mantis\"], [\"755A57\", \"Russett\"], [\"7563A8\", \"Deluge\"], [\"76395D\", \"Cosmic\"], [\"7666C6\", \"Blue Marguerite\"], [\"76BD17\", \"Lima\"], [\"76D7EA\", \"Sky Blue\"], [\"770F05\", \"Dark Burgundy\"], [\"771F1F\", \"Crown of Thorns\"], [\"773F1A\", \"Walnut\"], [\"776F61\", \"Pablo\"], [\"778120\", \"Pacifika\"], [\"779E86\", \"Oxley\"], [\"77DD77\", \"Pastel Green\"], [\"780109\", \"Japanese Maple\"], [\"782D19\", \"Mocha\"], [\"782F16\", \"Peanut\"], [\"78866B\", \"Camouflage Green\"], [\"788A25\", \"Wasabi\"], [\"788BBA\", \"Ship Cove\"], [\"78A39C\", \"Sea Nymph\"], [\"795D4C\", \"Roman Coffee\"], [\"796878\", \"Old Lavender\"], [\"796989\", \"Rum\"], [\"796A78\", \"Fedora\"], [\"796D62\", \"Sandstone\"], [\"79DEEC\", \"Spray\"], [\"7A013A\", \"Siren\"], [\"7A58C1\", \"Fuchsia Blue\"], [\"7A7A7A\", \"Boulder\"], [\"7A89B8\", \"Wild Blue Yonder\"], [\"7AC488\", \"De York\"], [\"7B3801\", \"Red Beech\"], [\"7B3F00\", \"Cinnamon\"], [\"7B6608\", \"Yukon Gold\"], [\"7B7874\", \"Tapa\"], [\"7B7C94\", \"Waterloo \"], [\"7B8265\", \"Flax Smoke\"], [\"7B9F80\", \"Amulet\"], [\"7BA05B\", \"Asparagus\"], [\"7C1C05\", \"Kenyan Copper\"], [\"7C7631\", \"Pesto\"], [\"7C778A\", \"Topaz\"], [\"7C7B7A\", \"Concord\"], [\"7C7B82\", \"Jumbo\"], [\"7C881A\", \"Trendy Green\"], [\"7CA1A6\", \"Gumbo\"], [\"7CB0A1\", \"Acapulco\"], [\"7CB7BB\", \"Neptune\"], [\"7D2C14\", \"Pueblo\"], [\"7DA98D\", \"Bay Leaf\"], [\"7DC8F7\", \"Malibu\"], [\"7DD8C6\", \"Bermuda\"], [\"7E3A15\", \"Copper Canyon\"], [\"7F1734\", \"Claret\"], [\"7F3A02\", \"Peru Tan\"], [\"7F626D\", \"Falcon\"], [\"7F7589\", \"Mobster\"], [\"7F76D3\", \"Moody Blue\"], [\"7FFF00\", \"Chartreuse\"], [\"7FFFD4\", \"Aquamarine\"], [\"800000\", \"Maroon\"], [\"800B47\", \"Rose Bud Cherry\"], [\"801818\", \"Falu Red\"], [\"80341F\", \"Red Robin\"], [\"803790\", \"Vivid Violet\"], [\"80461B\", \"Russet\"], [\"807E79\", \"Friar Gray\"], [\"808000\", \"Olive\"], [\"808080\", \"Gray\"], [\"80B3AE\", \"Gulf Stream\"], [\"80B3C4\", \"Glacier\"], [\"80CCEA\", \"Seagull\"], [\"81422C\", \"Nutmeg\"], [\"816E71\", \"Spicy Pink\"], [\"817377\", \"Empress\"], [\"819885\", \"Spanish Green\"], [\"826F65\", \"Sand Dune\"], [\"828685\", \"Gunsmoke\"], [\"828F72\", \"Battleship Gray\"], [\"831923\", \"Merlot\"], [\"837050\", \"Shadow\"], [\"83AA5D\", \"Chelsea Cucumber\"], [\"83D0C6\", \"Monte Carlo\"], [\"843179\", \"Plum\"], [\"84A0A0\", \"Granny Smith\"], [\"8581D9\", \"Chetwode Blue\"], [\"858470\", \"Bandicoot\"], [\"859FAF\", \"Bali Hai\"], [\"85C4CC\", \"Half Baked\"], [\"860111\", \"Red Devil\"], [\"863C3C\", \"Lotus\"], [\"86483C\", \"Ironstone\"], [\"864D1E\", \"Bull Shot\"], [\"86560A\", \"Rusty Nail\"], [\"868974\", \"Bitter\"], [\"86949F\", \"Regent Gray\"], [\"871550\", \"Disco\"], [\"87756E\", \"Americano\"], [\"877C7B\", \"Hurricane\"], [\"878D91\", \"Oslo Gray\"], [\"87AB39\", \"Sushi\"], [\"885342\", \"Spicy Mix\"], [\"886221\", \"Kumera\"], [\"888387\", \"Suva Gray\"], [\"888D65\", \"Avocado\"], [\"893456\", \"Camelot\"], [\"893843\", \"Solid Pink\"], [\"894367\", \"Cannon Pink\"], [\"897D6D\", \"Makara\"], [\"8A3324\", \"Burnt Umber\"], [\"8A73D6\", \"True V\"], [\"8A8360\", \"Clay Creek\"], [\"8A8389\", \"Monsoon\"], [\"8A8F8A\", \"Stack\"], [\"8AB9F1\", \"Jordy Blue\"], [\"8B00FF\", \"Electric Violet\"], [\"8B0723\", \"Monarch\"], [\"8B6B0B\", \"Corn Harvest\"], [\"8B8470\", \"Olive Haze\"], [\"8B847E\", \"Schooner\"], [\"8B8680\", \"Natural Gray\"], [\"8B9C90\", \"Mantle\"], [\"8B9FEE\", \"Portage\"], [\"8BA690\", \"Envy\"], [\"8BA9A5\", \"Cascade\"], [\"8BE6D8\", \"Riptide\"], [\"8C055E\", \"Cardinal Pink\"], [\"8C472F\", \"Mule Fawn\"], [\"8C5738\", \"Potters Clay\"], [\"8C6495\", \"Trendy Pink\"], [\"8D0226\", \"Paprika\"], [\"8D3D38\", \"Sanguine Brown\"], [\"8D3F3F\", \"Tosca\"], [\"8D7662\", \"Cement\"], [\"8D8974\", \"Granite Green\"], [\"8D90A1\", \"Manatee\"], [\"8DA8CC\", \"Polo Blue\"], [\"8E0000\", \"Red Berry\"], [\"8E4D1E\", \"Rope\"], [\"8E6F70\", \"Opium\"], [\"8E775E\", \"Domino\"], [\"8E8190\", \"Mamba\"], [\"8EABC1\", \"Nepal\"], [\"8F021C\", \"Pohutukawa\"], [\"8F3E33\", \"El Salva\"], [\"8F4B0E\", \"Korma\"], [\"8F8176\", \"Squirrel\"], [\"8FD6B4\", \"Vista Blue\"], [\"900020\", \"Burgundy\"], [\"901E1E\", \"Old Brick\"], [\"907874\", \"Hemp\"], [\"907B71\", \"Almond Frost\"], [\"908D39\", \"Sycamore\"], [\"92000A\", \"Sangria\"], [\"924321\", \"Cumin\"], [\"926F5B\", \"Beaver\"], [\"928573\", \"Stonewall\"], [\"928590\", \"Venus\"], [\"9370DB\", \"Medium Purple\"], [\"93CCEA\", \"Cornflower\"], [\"93DFB8\", \"Algae Green\"], [\"944747\", \"Copper Rust\"], [\"948771\", \"Arrowtown\"], [\"950015\", \"Scarlett\"], [\"956387\", \"Strikemaster\"], [\"959396\", \"Mountain Mist\"], [\"960018\", \"Carmine\"], [\"964B00\", \"Brown\"], [\"967059\", \"Leather\"], [\"9678B6\", \"Purple Mountain's Majesty\"], [\"967BB6\", \"Lavender Purple\"], [\"96A8A1\", \"Pewter\"], [\"96BBAB\", \"Summer Green\"], [\"97605D\", \"Au Chico\"], [\"9771B5\", \"Wisteria\"], [\"97CD2D\", \"Atlantis\"], [\"983D61\", \"Vin Rouge\"], [\"9874D3\", \"Lilac Bush\"], [\"98777B\", \"Bazaar\"], [\"98811B\", \"Hacienda\"], [\"988D77\", \"Pale Oyster\"], [\"98FF98\", \"Mint Green\"], [\"990066\", \"Fresh Eggplant\"], [\"991199\", \"Violet Eggplant\"], [\"991613\", \"Tamarillo\"], [\"991B07\", \"Totem Pole\"], [\"996666\", \"Copper Rose\"], [\"9966CC\", \"Amethyst\"], [\"997A8D\", \"Mountbatten Pink\"], [\"9999CC\", \"Blue Bell\"], [\"9A3820\", \"Prairie Sand\"], [\"9A6E61\", \"Toast\"], [\"9A9577\", \"Gurkha\"], [\"9AB973\", \"Olivine\"], [\"9AC2B8\", \"Shadow Green\"], [\"9B4703\", \"Oregon\"], [\"9B9E8F\", \"Lemon Grass\"], [\"9C3336\", \"Stiletto\"], [\"9D5616\", \"Hawaiian Tan\"], [\"9DACB7\", \"Gull Gray\"], [\"9DC209\", \"Pistachio\"], [\"9DE093\", \"Granny Smith Apple\"], [\"9DE5FF\", \"Anakiwa\"], [\"9E5302\", \"Chelsea Gem\"], [\"9E5B40\", \"Sepia Skin\"], [\"9EA587\", \"Sage\"], [\"9EA91F\", \"Citron\"], [\"9EB1CD\", \"Rock Blue\"], [\"9EDEE0\", \"Morning Glory\"], [\"9F381D\", \"Cognac\"], [\"9F821C\", \"Reef Gold\"], [\"9F9F9C\", \"Star Dust\"], [\"9FA0B1\", \"Santas Gray\"], [\"9FD7D3\", \"Sinbad\"], [\"9FDD8C\", \"Feijoa\"], [\"A02712\", \"Tabasco\"], [\"A1750D\", \"Buttered Rum\"], [\"A1ADB5\", \"Hit Gray\"], [\"A1C50A\", \"Citrus\"], [\"A1DAD7\", \"Aqua Island\"], [\"A1E9DE\", \"Water Leaf\"], [\"A2006D\", \"Flirt\"], [\"A23B6C\", \"Rouge\"], [\"A26645\", \"Cape Palliser\"], [\"A2AAB3\", \"Gray Chateau\"], [\"A2AEAB\", \"Edward\"], [\"A3807B\", \"Pharlap\"], [\"A397B4\", \"Amethyst Smoke\"], [\"A3E3ED\", \"Blizzard Blue\"], [\"A4A49D\", \"Delta\"], [\"A4A6D3\", \"Wistful\"], [\"A4AF6E\", \"Green Smoke\"], [\"A50B5E\", \"Jazzberry Jam\"], [\"A59B91\", \"Zorba\"], [\"A5CB0C\", \"Bahia\"], [\"A62F20\", \"Roof Terracotta\"], [\"A65529\", \"Paarl\"], [\"A68B5B\", \"Barley Corn\"], [\"A69279\", \"Donkey Brown\"], [\"A6A29A\", \"Dawn\"], [\"A72525\", \"Mexican Red\"], [\"A7882C\", \"Luxor Gold\"], [\"A85307\", \"Rich Gold\"], [\"A86515\", \"Reno Sand\"], [\"A86B6B\", \"Coral Tree\"], [\"A8989B\", \"Dusty Gray\"], [\"A899E6\", \"Dull Lavender\"], [\"A8A589\", \"Tallow\"], [\"A8AE9C\", \"Bud\"], [\"A8AF8E\", \"Locust\"], [\"A8BD9F\", \"Norway\"], [\"A8E3BD\", \"Chinook\"], [\"A9A491\", \"Gray Olive\"], [\"A9ACB6\", \"Aluminium\"], [\"A9B2C3\", \"Cadet Blue\"], [\"A9B497\", \"Schist\"], [\"A9BDBF\", \"Tower Gray\"], [\"A9BEF2\", \"Perano\"], [\"A9C6C2\", \"Opal\"], [\"AA375A\", \"Night Shadz\"], [\"AA4203\", \"Fire\"], [\"AA8B5B\", \"Muesli\"], [\"AA8D6F\", \"Sandal\"], [\"AAA5A9\", \"Shady Lady\"], [\"AAA9CD\", \"Logan\"], [\"AAABB7\", \"Spun Pearl\"], [\"AAD6E6\", \"Regent St Blue\"], [\"AAF0D1\", \"Magic Mint\"], [\"AB0563\", \"Lipstick\"], [\"AB3472\", \"Royal Heath\"], [\"AB917A\", \"Sandrift\"], [\"ABA0D9\", \"Cold Purple\"], [\"ABA196\", \"Bronco\"], [\"AC8A56\", \"Limed Oak\"], [\"AC91CE\", \"East Side\"], [\"AC9E22\", \"Lemon Ginger\"], [\"ACA494\", \"Napa\"], [\"ACA586\", \"Hillary\"], [\"ACA59F\", \"Cloudy\"], [\"ACACAC\", \"Silver Chalice\"], [\"ACB78E\", \"Swamp Green\"], [\"ACCBB1\", \"Spring Rain\"], [\"ACDD4D\", \"Conifer\"], [\"ACE1AF\", \"Celadon\"], [\"AD781B\", \"Mandalay\"], [\"ADBED1\", \"Casper\"], [\"ADDFAD\", \"Moss Green\"], [\"ADE6C4\", \"Padua\"], [\"ADFF2F\", \"Green Yellow\"], [\"AE4560\", \"Hippie Pink\"], [\"AE6020\", \"Desert\"], [\"AE809E\", \"Bouquet\"], [\"AF4035\", \"Medium Carmine\"], [\"AF4D43\", \"Apple Blossom\"], [\"AF593E\", \"Brown Rust\"], [\"AF8751\", \"Driftwood\"], [\"AF8F2C\", \"Alpine\"], [\"AF9F1C\", \"Lucky\"], [\"AFA09E\", \"Martini\"], [\"AFB1B8\", \"Bombay\"], [\"AFBDD9\", \"Pigeon Post\"], [\"B04C6A\", \"Cadillac\"], [\"B05D54\", \"Matrix\"], [\"B05E81\", \"Tapestry\"], [\"B06608\", \"Mai Tai\"], [\"B09A95\", \"Del Rio\"], [\"B0E0E6\", \"Powder Blue\"], [\"B0E313\", \"Inch Worm\"], [\"B10000\", \"Bright Red\"], [\"B14A0B\", \"Vesuvius\"], [\"B1610B\", \"Pumpkin Skin\"], [\"B16D52\", \"Santa Fe\"], [\"B19461\", \"Teak\"], [\"B1E2C1\", \"Fringy Flower\"], [\"B1F4E7\", \"Ice Cold\"], [\"B20931\", \"Shiraz\"], [\"B2A1EA\", \"Biloba Flower\"], [\"B32D29\", \"Tall Poppy\"], [\"B35213\", \"Fiery Orange\"], [\"B38007\", \"Hot Toddy\"], [\"B3AF95\", \"Taupe Gray\"], [\"B3C110\", \"La Rioja\"], [\"B43332\", \"Well Read\"], [\"B44668\", \"Blush\"], [\"B4CFD3\", \"Jungle Mist\"], [\"B57281\", \"Turkish Rose\"], [\"B57EDC\", \"Lavender\"], [\"B5A27F\", \"Mongoose\"], [\"B5B35C\", \"Olive Green\"], [\"B5D2CE\", \"Jet Stream\"], [\"B5ECDF\", \"Cruise\"], [\"B6316C\", \"Hibiscus\"], [\"B69D98\", \"Thatch\"], [\"B6B095\", \"Heathered Gray\"], [\"B6BAA4\", \"Eagle\"], [\"B6D1EA\", \"Spindle\"], [\"B6D3BF\", \"Gum Leaf\"], [\"B7410E\", \"Rust\"], [\"B78E5C\", \"Muddy Waters\"], [\"B7A214\", \"Sahara\"], [\"B7A458\", \"Husk\"], [\"B7B1B1\", \"Nobel\"], [\"B7C3D0\", \"Heather\"], [\"B7F0BE\", \"Madang\"], [\"B81104\", \"Milano Red\"], [\"B87333\", \"Copper\"], [\"B8B56A\", \"Gimblet\"], [\"B8C1B1\", \"Green Spring\"], [\"B8C25D\", \"Celery\"], [\"B8E0F9\", \"Sail\"], [\"B94E48\", \"Chestnut\"], [\"B95140\", \"Crail\"], [\"B98D28\", \"Marigold\"], [\"B9C46A\", \"Wild Willow\"], [\"B9C8AC\", \"Rainee\"], [\"BA0101\", \"Guardsman Red\"], [\"BA450C\", \"Rock Spray\"], [\"BA6F1E\", \"Bourbon\"], [\"BA7F03\", \"Pirate Gold\"], [\"BAB1A2\", \"Nomad\"], [\"BAC7C9\", \"Submarine\"], [\"BAEEF9\", \"Charlotte\"], [\"BB3385\", \"Medium Red Violet\"], [\"BB8983\", \"Brandy Rose\"], [\"BBD009\", \"Rio Grande\"], [\"BBD7C1\", \"Surf\"], [\"BCC9C2\", \"Powder Ash\"], [\"BD5E2E\", \"Tuscany\"], [\"BD978E\", \"Quicksand\"], [\"BDB1A8\", \"Silk\"], [\"BDB2A1\", \"Malta\"], [\"BDB3C7\", \"Chatelle\"], [\"BDBBD7\", \"Lavender Gray\"], [\"BDBDC6\", \"French Gray\"], [\"BDC8B3\", \"Clay Ash\"], [\"BDC9CE\", \"Loblolly\"], [\"BDEDFD\", \"French Pass\"], [\"BEA6C3\", \"London Hue\"], [\"BEB5B7\", \"Pink Swan\"], [\"BEDE0D\", \"Fuego\"], [\"BF5500\", \"Rose of Sharon\"], [\"BFB8B0\", \"Tide\"], [\"BFBED8\", \"Blue Haze\"], [\"BFC1C2\", \"Silver Sand\"], [\"BFC921\", \"Key Lime Pie\"], [\"BFDBE2\", \"Ziggurat\"], [\"BFFF00\", \"Lime\"], [\"C02B18\", \"Thunderbird\"], [\"C04737\", \"Mojo\"], [\"C08081\", \"Old Rose\"], [\"C0C0C0\", \"Silver\"], [\"C0D3B9\", \"Pale Leaf\"], [\"C0D8B6\", \"Pixie Green\"], [\"C1440E\", \"Tia Maria\"], [\"C154C1\", \"Fuchsia Pink\"], [\"C1A004\", \"Buddha Gold\"], [\"C1B7A4\", \"Bison Hide\"], [\"C1BAB0\", \"Tea\"], [\"C1BECD\", \"Gray Suit\"], [\"C1D7B0\", \"Sprout\"], [\"C1F07C\", \"Sulu\"], [\"C26B03\", \"Indochine\"], [\"C2955D\", \"Twine\"], [\"C2BDB6\", \"Cotton Seed\"], [\"C2CAC4\", \"Pumice\"], [\"C2E8E5\", \"Jagged Ice\"], [\"C32148\", \"Maroon Flush\"], [\"C3B091\", \"Indian Khaki\"], [\"C3BFC1\", \"Pale Slate\"], [\"C3C3BD\", \"Gray Nickel\"], [\"C3CDE6\", \"Periwinkle Gray\"], [\"C3D1D1\", \"Tiara\"], [\"C3DDF9\", \"Tropical Blue\"], [\"C41E3A\", \"Cardinal\"], [\"C45655\", \"Fuzzy Wuzzy Brown\"], [\"C45719\", \"Orange Roughy\"], [\"C4C4BC\", \"Mist Gray\"], [\"C4D0B0\", \"Coriander\"], [\"C4F4EB\", \"Mint Tulip\"], [\"C54B8C\", \"Mulberry\"], [\"C59922\", \"Nugget\"], [\"C5994B\", \"Tussock\"], [\"C5DBCA\", \"Sea Mist\"], [\"C5E17A\", \"Yellow Green\"], [\"C62D42\", \"Brick Red\"], [\"C6726B\", \"Contessa\"], [\"C69191\", \"Oriental Pink\"], [\"C6A84B\", \"Roti\"], [\"C6C3B5\", \"Ash\"], [\"C6C8BD\", \"Kangaroo\"], [\"C6E610\", \"Las Palmas\"], [\"C7031E\", \"Monza\"], [\"C71585\", \"Red Violet\"], [\"C7BCA2\", \"Coral Reef\"], [\"C7C1FF\", \"Melrose\"], [\"C7C4BF\", \"Cloud\"], [\"C7C9D5\", \"Ghost\"], [\"C7CD90\", \"Pine Glade\"], [\"C7DDE5\", \"Botticelli\"], [\"C88A65\", \"Antique Brass\"], [\"C8A2C8\", \"Lilac\"], [\"C8A528\", \"Hokey Pokey\"], [\"C8AABF\", \"Lily\"], [\"C8B568\", \"Laser\"], [\"C8E3D7\", \"Edgewater\"], [\"C96323\", \"Piper\"], [\"C99415\", \"Pizza\"], [\"C9A0DC\", \"Light Wisteria\"], [\"C9B29B\", \"Rodeo Dust\"], [\"C9B35B\", \"Sundance\"], [\"C9B93B\", \"Earls Green\"], [\"C9C0BB\", \"Silver Rust\"], [\"C9D9D2\", \"Conch\"], [\"C9FFA2\", \"Reef\"], [\"C9FFE5\", \"Aero Blue\"], [\"CA3435\", \"Flush Mahogany\"], [\"CABB48\", \"Turmeric\"], [\"CADCD4\", \"Paris White\"], [\"CAE00D\", \"Bitter Lemon\"], [\"CAE6DA\", \"Skeptic\"], [\"CB8FA9\", \"Viola\"], [\"CBCAB6\", \"Foggy Gray\"], [\"CBD3B0\", \"Green Mist\"], [\"CBDBD6\", \"Nebula\"], [\"CC3333\", \"Persian Red\"], [\"CC5500\", \"Burnt Orange\"], [\"CC7722\", \"Ochre\"], [\"CC8899\", \"Puce\"], [\"CCCAA8\", \"Thistle Green\"], [\"CCCCFF\", \"Periwinkle\"], [\"CCFF00\", \"Electric Lime\"], [\"CD5700\", \"Tenn\"], [\"CD5C5C\", \"Chestnut Rose\"], [\"CD8429\", \"Brandy Punch\"], [\"CDF4FF\", \"Onahau\"], [\"CEB98F\", \"Sorrell Brown\"], [\"CEBABA\", \"Cold Turkey\"], [\"CEC291\", \"Yuma\"], [\"CEC7A7\", \"Chino\"], [\"CFA39D\", \"Eunry\"], [\"CFB53B\", \"Old Gold\"], [\"CFDCCF\", \"Tasman\"], [\"CFE5D2\", \"Surf Crest\"], [\"CFF9F3\", \"Humming Bird\"], [\"CFFAF4\", \"Scandal\"], [\"D05F04\", \"Red Stage\"], [\"D06DA1\", \"Hopbush\"], [\"D07D12\", \"Meteor\"], [\"D0BEF8\", \"Perfume\"], [\"D0C0E5\", \"Prelude\"], [\"D0F0C0\", \"Tea Green\"], [\"D18F1B\", \"Geebung\"], [\"D1BEA8\", \"Vanilla\"], [\"D1C6B4\", \"Soft Amber\"], [\"D1D2CA\", \"Celeste\"], [\"D1D2DD\", \"Mischka\"], [\"D1E231\", \"Pear\"], [\"D2691E\", \"Hot Cinnamon\"], [\"D27D46\", \"Raw Sienna\"], [\"D29EAA\", \"Careys Pink\"], [\"D2B48C\", \"Tan\"], [\"D2DA97\", \"Deco\"], [\"D2F6DE\", \"Blue Romance\"], [\"D2F8B0\", \"Gossip\"], [\"D3CBBA\", \"Sisal\"], [\"D3CDC5\", \"Swirl\"], [\"D47494\", \"Charm\"], [\"D4B6AF\", \"Clam Shell\"], [\"D4BF8D\", \"Straw\"], [\"D4C4A8\", \"Akaroa\"], [\"D4CD16\", \"Bird Flower\"], [\"D4D7D9\", \"Iron\"], [\"D4DFE2\", \"Geyser\"], [\"D4E2FC\", \"Hawkes Blue\"], [\"D54600\", \"Grenadier\"], [\"D591A4\", \"Can Can\"], [\"D59A6F\", \"Whiskey\"], [\"D5D195\", \"Winter Hazel\"], [\"D5F6E3\", \"Granny Apple\"], [\"D69188\", \"My Pink\"], [\"D6C562\", \"Tacha\"], [\"D6CEF6\", \"Moon Raker\"], [\"D6D6D1\", \"Quill Gray\"], [\"D6FFDB\", \"Snowy Mint\"], [\"D7837F\", \"New York Pink\"], [\"D7C498\", \"Pavlova\"], [\"D7D0FF\", \"Fog\"], [\"D84437\", \"Valencia\"], [\"D87C63\", \"Japonica\"], [\"D8BFD8\", \"Thistle\"], [\"D8C2D5\", \"Maverick\"], [\"D8FCFA\", \"Foam\"], [\"D94972\", \"Cabaret\"], [\"D99376\", \"Burning Sand\"], [\"D9B99B\", \"Cameo\"], [\"D9D6CF\", \"Timberwolf\"], [\"D9DCC1\", \"Tana\"], [\"D9E4F5\", \"Link Water\"], [\"D9F7FF\", \"Mabel\"], [\"DA3287\", \"Cerise\"], [\"DA5B38\", \"Flame Pea\"], [\"DA6304\", \"Bamboo\"], [\"DA6A41\", \"Red Damask\"], [\"DA70D6\", \"Orchid\"], [\"DA8A67\", \"Copperfield\"], [\"DAA520\", \"Golden Grass\"], [\"DAECD6\", \"Zanah\"], [\"DAF4F0\", \"Iceberg\"], [\"DAFAFF\", \"Oyster Bay\"], [\"DB5079\", \"Cranberry\"], [\"DB9690\", \"Petite Orchid\"], [\"DB995E\", \"Di Serria\"], [\"DBDBDB\", \"Alto\"], [\"DBFFF8\", \"Frosted Mint\"], [\"DC143C\", \"Crimson\"], [\"DC4333\", \"Punch\"], [\"DCB20C\", \"Galliano\"], [\"DCB4BC\", \"Blossom\"], [\"DCD747\", \"Wattle\"], [\"DCD9D2\", \"Westar\"], [\"DCDDCC\", \"Moon Mist\"], [\"DCEDB4\", \"Caper\"], [\"DCF0EA\", \"Swans Down\"], [\"DDD6D5\", \"Swiss Coffee\"], [\"DDF9F1\", \"White Ice\"], [\"DE3163\", \"Cerise Red\"], [\"DE6360\", \"Roman\"], [\"DEA681\", \"Tumbleweed\"], [\"DEBA13\", \"Gold Tips\"], [\"DEC196\", \"Brandy\"], [\"DECBC6\", \"Wafer\"], [\"DED4A4\", \"Sapling\"], [\"DED717\", \"Barberry\"], [\"DEE5C0\", \"Beryl Green\"], [\"DEF5FF\", \"Pattens Blue\"], [\"DF73FF\", \"Heliotrope\"], [\"DFBE6F\", \"Apache\"], [\"DFCD6F\", \"Chenin\"], [\"DFCFDB\", \"Lola\"], [\"DFECDA\", \"Willow Brook\"], [\"DFFF00\", \"Chartreuse Yellow\"], [\"E0B0FF\", \"Mauve\"], [\"E0B646\", \"Anzac\"], [\"E0B974\", \"Harvest Gold\"], [\"E0C095\", \"Calico\"], [\"E0FFFF\", \"Baby Blue\"], [\"E16865\", \"Sunglo\"], [\"E1BC64\", \"Equator\"], [\"E1C0C8\", \"Pink Flare\"], [\"E1E6D6\", \"Periglacial Blue\"], [\"E1EAD4\", \"Kidnapper\"], [\"E1F6E8\", \"Tara\"], [\"E25465\", \"Mandy\"], [\"E2725B\", \"Terracotta\"], [\"E28913\", \"Golden Bell\"], [\"E292C0\", \"Shocking\"], [\"E29418\", \"Dixie\"], [\"E29CD2\", \"Light Orchid\"], [\"E2D8ED\", \"Snuff\"], [\"E2EBED\", \"Mystic\"], [\"E2F3EC\", \"Apple Green\"], [\"E30B5C\", \"Razzmatazz\"], [\"E32636\", \"Alizarin Crimson\"], [\"E34234\", \"Cinnabar\"], [\"E3BEBE\", \"Cavern Pink\"], [\"E3F5E1\", \"Peppermint\"], [\"E3F988\", \"Mindaro\"], [\"E47698\", \"Deep Blush\"], [\"E49B0F\", \"Gamboge\"], [\"E4C2D5\", \"Melanie\"], [\"E4CFDE\", \"Twilight\"], [\"E4D1C0\", \"Bone\"], [\"E4D422\", \"Sunflower\"], [\"E4D5B7\", \"Grain Brown\"], [\"E4D69B\", \"Zombie\"], [\"E4F6E7\", \"Frostee\"], [\"E4FFD1\", \"Snow Flurry\"], [\"E52B50\", \"Amaranth\"], [\"E5841B\", \"Zest\"], [\"E5CCC9\", \"Dust Storm\"], [\"E5D7BD\", \"Stark White\"], [\"E5D8AF\", \"Hampton\"], [\"E5E0E1\", \"Bon Jour\"], [\"E5E5E5\", \"Mercury\"], [\"E5F9F6\", \"Polar\"], [\"E64E03\", \"Trinidad\"], [\"E6BE8A\", \"Gold Sand\"], [\"E6BEA5\", \"Cashmere\"], [\"E6D7B9\", \"Double Spanish White\"], [\"E6E4D4\", \"Satin Linen\"], [\"E6F2EA\", \"Harp\"], [\"E6F8F3\", \"Off Green\"], [\"E6FFE9\", \"Hint of Green\"], [\"E6FFFF\", \"Tranquil\"], [\"E77200\", \"Mango Tango\"], [\"E7730A\", \"Christine\"], [\"E79F8C\", \"Tonys Pink\"], [\"E79FC4\", \"Kobi\"], [\"E7BCB4\", \"Rose Fog\"], [\"E7BF05\", \"Corn\"], [\"E7CD8C\", \"Putty\"], [\"E7ECE6\", \"Gray Nurse\"], [\"E7F8FF\", \"Lily White\"], [\"E7FEFF\", \"Bubbles\"], [\"E89928\", \"Fire Bush\"], [\"E8B9B3\", \"Shilo\"], [\"E8E0D5\", \"Pearl Bush\"], [\"E8EBE0\", \"Green White\"], [\"E8F1D4\", \"Chrome White\"], [\"E8F2EB\", \"Gin\"], [\"E8F5F2\", \"Aqua Squeeze\"], [\"E96E00\", \"Clementine\"], [\"E97451\", \"Burnt Sienna\"], [\"E97C07\", \"Tahiti Gold\"], [\"E9CECD\", \"Oyster Pink\"], [\"E9D75A\", \"Confetti\"], [\"E9E3E3\", \"Ebb\"], [\"E9F8ED\", \"Ottoman\"], [\"E9FFFD\", \"Clear Day\"], [\"EA88A8\", \"Carissma\"], [\"EAAE69\", \"Porsche\"], [\"EAB33B\", \"Tulip Tree\"], [\"EAC674\", \"Rob Roy\"], [\"EADAB8\", \"Raffia\"], [\"EAE8D4\", \"White Rock\"], [\"EAF6EE\", \"Panache\"], [\"EAF6FF\", \"Solitude\"], [\"EAF9F5\", \"Aqua Spring\"], [\"EAFFFE\", \"Dew\"], [\"EB9373\", \"Apricot\"], [\"EBC2AF\", \"Zinnwaldite\"], [\"ECA927\", \"Fuel Yellow\"], [\"ECC54E\", \"Ronchi\"], [\"ECC7EE\", \"French Lilac\"], [\"ECCDB9\", \"Just Right\"], [\"ECE090\", \"Wild Rice\"], [\"ECEBBD\", \"Fall Green\"], [\"ECEBCE\", \"Aths Special\"], [\"ECF245\", \"Starship\"], [\"ED0A3F\", \"Red Ribbon\"], [\"ED7A1C\", \"Tango\"], [\"ED9121\", \"Carrot Orange\"], [\"ED989E\", \"Sea Pink\"], [\"EDB381\", \"Tacao\"], [\"EDC9AF\", \"Desert Sand\"], [\"EDCDAB\", \"Pancho\"], [\"EDDCB1\", \"Chamois\"], [\"EDEA99\", \"Primrose\"], [\"EDF5DD\", \"Frost\"], [\"EDF5F5\", \"Aqua Haze\"], [\"EDF6FF\", \"Zumthor\"], [\"EDF9F1\", \"Narvik\"], [\"EDFC84\", \"Honeysuckle\"], [\"EE82EE\", \"Lavender Magenta\"], [\"EEC1BE\", \"Beauty Bush\"], [\"EED794\", \"Chalky\"], [\"EED9C4\", \"Almond\"], [\"EEDC82\", \"Flax\"], [\"EEDEDA\", \"Bizarre\"], [\"EEE3AD\", \"Double Colonial White\"], [\"EEEEE8\", \"Cararra\"], [\"EEEF78\", \"Manz\"], [\"EEF0C8\", \"Tahuna Sands\"], [\"EEF0F3\", \"Athens Gray\"], [\"EEF3C3\", \"Tusk\"], [\"EEF4DE\", \"Loafer\"], [\"EEF6F7\", \"Catskill White\"], [\"EEFDFF\", \"Twilight Blue\"], [\"EEFF9A\", \"Jonquil\"], [\"EEFFE2\", \"Rice Flower\"], [\"EF863F\", \"Jaffa\"], [\"EFEFEF\", \"Gallery\"], [\"EFF2F3\", \"Porcelain\"], [\"F091A9\", \"Mauvelous\"], [\"F0D52D\", \"Golden Dream\"], [\"F0DB7D\", \"Golden Sand\"], [\"F0DC82\", \"Buff\"], [\"F0E2EC\", \"Prim\"], [\"F0E68C\", \"Khaki\"], [\"F0EEFD\", \"Selago\"], [\"F0EEFF\", \"Titan White\"], [\"F0F8FF\", \"Alice Blue\"], [\"F0FCEA\", \"Feta\"], [\"F18200\", \"Gold Drop\"], [\"F19BAB\", \"Wewak\"], [\"F1E788\", \"Sahara Sand\"], [\"F1E9D2\", \"Parchment\"], [\"F1E9FF\", \"Blue Chalk\"], [\"F1EEC1\", \"Mint Julep\"], [\"F1F1F1\", \"Seashell\"], [\"F1F7F2\", \"Saltpan\"], [\"F1FFAD\", \"Tidal\"], [\"F1FFC8\", \"Chiffon\"], [\"F2552A\", \"Flamingo\"], [\"F28500\", \"Tangerine\"], [\"F2C3B2\", \"Mandys Pink\"], [\"F2F2F2\", \"Concrete\"], [\"F2FAFA\", \"Black Squeeze\"], [\"F34723\", \"Pomegranate\"], [\"F3AD16\", \"Buttercup\"], [\"F3D69D\", \"New Orleans\"], [\"F3D9DF\", \"Vanilla Ice\"], [\"F3E7BB\", \"Sidecar\"], [\"F3E9E5\", \"Dawn Pink\"], [\"F3EDCF\", \"Wheatfield\"], [\"F3FB62\", \"Canary\"], [\"F3FBD4\", \"Orinoco\"], [\"F3FFD8\", \"Carla\"], [\"F400A1\", \"Hollywood Cerise\"], [\"F4A460\", \"Sandy brown\"], [\"F4C430\", \"Saffron\"], [\"F4D81C\", \"Ripe Lemon\"], [\"F4EBD3\", \"Janna\"], [\"F4F2EE\", \"Pampas\"], [\"F4F4F4\", \"Wild Sand\"], [\"F4F8FF\", \"Zircon\"], [\"F57584\", \"Froly\"], [\"F5C85C\", \"Cream Can\"], [\"F5C999\", \"Manhattan\"], [\"F5D5A0\", \"Maize\"], [\"F5DEB3\", \"Wheat\"], [\"F5E7A2\", \"Sandwisp\"], [\"F5E7E2\", \"Pot Pourri\"], [\"F5E9D3\", \"Albescent White\"], [\"F5EDEF\", \"Soft Peach\"], [\"F5F3E5\", \"Ecru White\"], [\"F5F5DC\", \"Beige\"], [\"F5FB3D\", \"Golden Fizz\"], [\"F5FFBE\", \"Australian Mint\"], [\"F64A8A\", \"French Rose\"], [\"F653A6\", \"Brilliant Rose\"], [\"F6A4C9\", \"Illusion\"], [\"F6F0E6\", \"Merino\"], [\"F6F7F7\", \"Black Haze\"], [\"F6FFDC\", \"Spring Sun\"], [\"F7468A\", \"Violet Red\"], [\"F77703\", \"Chilean Fire\"], [\"F77FBE\", \"Persian Pink\"], [\"F7B668\", \"Rajah\"], [\"F7C8DA\", \"Azalea\"], [\"F7DBE6\", \"We Peep\"], [\"F7F2E1\", \"Quarter Spanish White\"], [\"F7F5FA\", \"Whisper\"], [\"F7FAF7\", \"Snow Drift\"], [\"F8B853\", \"Casablanca\"], [\"F8C3DF\", \"Chantilly\"], [\"F8D9E9\", \"Cherub\"], [\"F8DB9D\", \"Marzipan\"], [\"F8DD5C\", \"Energy Yellow\"], [\"F8E4BF\", \"Givry\"], [\"F8F0E8\", \"White Linen\"], [\"F8F4FF\", \"Magnolia\"], [\"F8F6F1\", \"Spring Wood\"], [\"F8F7DC\", \"Coconut Cream\"], [\"F8F7FC\", \"White Lilac\"], [\"F8F8F7\", \"Desert Storm\"], [\"F8F99C\", \"Texas\"], [\"F8FACD\", \"Corn Field\"], [\"F8FDD3\", \"Mimosa\"], [\"F95A61\", \"Carnation\"], [\"F9BF58\", \"Saffron Mango\"], [\"F9E0ED\", \"Carousel Pink\"], [\"F9E4BC\", \"Dairy Cream\"], [\"F9E663\", \"Portica\"], [\"F9E6F4\", \"Underage Pink\"], [\"F9EAF3\", \"Amour\"], [\"F9F8E4\", \"Rum Swizzle\"], [\"F9FF8B\", \"Dolly\"], [\"F9FFF6\", \"Sugar Cane\"], [\"FA7814\", \"Ecstasy\"], [\"FA9D5A\", \"Tan Hide\"], [\"FAD3A2\", \"Corvette\"], [\"FADFAD\", \"Peach Yellow\"], [\"FAE600\", \"Turbo\"], [\"FAEAB9\", \"Astra\"], [\"FAECCC\", \"Champagne\"], [\"FAF0E6\", \"Linen\"], [\"FAF3F0\", \"Fantasy\"], [\"FAF7D6\", \"Citrine White\"], [\"FAFAFA\", \"Alabaster\"], [\"FAFDE4\", \"Hint of Yellow\"], [\"FAFFA4\", \"Milan\"], [\"FB607F\", \"Brink Pink\"], [\"FB8989\", \"Geraldine\"], [\"FBA0E3\", \"Lavender Rose\"], [\"FBA129\", \"Sea Buckthorn\"], [\"FBAC13\", \"Sun\"], [\"FBAED2\", \"Lavender Pink\"], [\"FBB2A3\", \"Rose Bud\"], [\"FBBEDA\", \"Cupid\"], [\"FBCCE7\", \"Classic Rose\"], [\"FBCEB1\", \"Apricot Peach\"], [\"FBE7B2\", \"Banana Mania\"], [\"FBE870\", \"Marigold Yellow\"], [\"FBE96C\", \"Festival\"], [\"FBEA8C\", \"Sweet Corn\"], [\"FBEC5D\", \"Candy Corn\"], [\"FBF9F9\", \"Hint of Red\"], [\"FBFFBA\", \"Shalimar\"], [\"FC0FC0\", \"Shocking Pink\"], [\"FC80A5\", \"Tickle Me Pink\"], [\"FC9C1D\", \"Tree Poppy\"], [\"FCC01E\", \"Lightning Yellow\"], [\"FCD667\", \"Goldenrod\"], [\"FCD917\", \"Candlelight\"], [\"FCDA98\", \"Cherokee\"], [\"FCF4D0\", \"Double Pearl Lusta\"], [\"FCF4DC\", \"Pearl Lusta\"], [\"FCF8F7\", \"Vista White\"], [\"FCFBF3\", \"Bianca\"], [\"FCFEDA\", \"Moon Glow\"], [\"FCFFE7\", \"China Ivory\"], [\"FCFFF9\", \"Ceramic\"], [\"FD0E35\", \"Torch Red\"], [\"FD5B78\", \"Wild Watermelon\"], [\"FD7B33\", \"Crusta\"], [\"FD7C07\", \"Sorbus\"], [\"FD9FA2\", \"Sweet Pink\"], [\"FDD5B1\", \"Light Apricot\"], [\"FDD7E4\", \"Pig Pink\"], [\"FDE1DC\", \"Cinderella\"], [\"FDE295\", \"Golden Glow\"], [\"FDE910\", \"Lemon\"], [\"FDF5E6\", \"Old Lace\"], [\"FDF6D3\", \"Half Colonial White\"], [\"FDF7AD\", \"Drover\"], [\"FDFEB8\", \"Pale Prim\"], [\"FDFFD5\", \"Cumulus\"], [\"FE28A2\", \"Persian Rose\"], [\"FE4C40\", \"Sunset Orange\"], [\"FE6F5E\", \"Bittersweet\"], [\"FE9D04\", \"California\"], [\"FEA904\", \"Yellow Sea\"], [\"FEBAAD\", \"Melon\"], [\"FED33C\", \"Bright Sun\"], [\"FED85D\", \"Dandelion\"], [\"FEDB8D\", \"Salomie\"], [\"FEE5AC\", \"Cape Honey\"], [\"FEEBF3\", \"Remy\"], [\"FEEFCE\", \"Oasis\"], [\"FEF0EC\", \"Bridesmaid\"], [\"FEF2C7\", \"Beeswax\"], [\"FEF3D8\", \"Bleach White\"], [\"FEF4CC\", \"Pipi\"], [\"FEF4DB\", \"Half Spanish White\"], [\"FEF4F8\", \"Wisp Pink\"], [\"FEF5F1\", \"Provincial Pink\"], [\"FEF7DE\", \"Half Dutch White\"], [\"FEF8E2\", \"Solitaire\"], [\"FEF8FF\", \"White Pointer\"], [\"FEF9E3\", \"Off Yellow\"], [\"FEFCED\", \"Orange White\"], [\"FF0000\", \"Red\"], [\"FF007F\", \"Rose\"], [\"FF00CC\", \"Purple Pizzazz\"], [\"FF00FF\", \"Magenta / Fuchsia\"], [\"FF2400\", \"Scarlet\"], [\"FF3399\", \"Wild Strawberry\"], [\"FF33CC\", \"Razzle Dazzle Rose\"], [\"FF355E\", \"Radical Red\"], [\"FF3F34\", \"Red Orange\"], [\"FF4040\", \"Coral Red\"], [\"FF4D00\", \"Vermilion\"], [\"FF4F00\", \"International Orange\"], [\"FF6037\", \"Outrageous Orange\"], [\"FF6600\", \"Blaze Orange\"], [\"FF66FF\", \"Pink Flamingo\"], [\"FF681F\", \"Orange\"], [\"FF69B4\", \"Hot Pink\"], [\"FF6B53\", \"Persimmon\"], [\"FF6FFF\", \"Blush Pink\"], [\"FF7034\", \"Burning Orange\"], [\"FF7518\", \"Pumpkin\"], [\"FF7D07\", \"Flamenco\"], [\"FF7F00\", \"Flush Orange\"], [\"FF7F50\", \"Coral\"], [\"FF8C69\", \"Salmon\"], [\"FF9000\", \"Pizazz\"], [\"FF910F\", \"West Side\"], [\"FF91A4\", \"Pink Salmon\"], [\"FF9933\", \"Neon Carrot\"], [\"FF9966\", \"Atomic Tangerine\"], [\"FF9980\", \"Vivid Tangerine\"], [\"FF9E2C\", \"Sunshade\"], [\"FFA000\", \"Orange Peel\"], [\"FFA194\", \"Mona Lisa\"], [\"FFA500\", \"Web Orange\"], [\"FFA6C9\", \"Carnation Pink\"], [\"FFAB81\", \"Hit Pink\"], [\"FFAE42\", \"Yellow Orange\"], [\"FFB0AC\", \"Cornflower Lilac\"], [\"FFB1B3\", \"Sundown\"], [\"FFB31F\", \"My Sin\"], [\"FFB555\", \"Texas Rose\"], [\"FFB7D5\", \"Cotton Candy\"], [\"FFB97B\", \"Macaroni and Cheese\"], [\"FFBA00\", \"Selective Yellow\"], [\"FFBD5F\", \"Koromiko\"], [\"FFBF00\", \"Amber\"], [\"FFC0A8\", \"Wax Flower\"], [\"FFC0CB\", \"Pink\"], [\"FFC3C0\", \"Your Pink\"], [\"FFC901\", \"Supernova\"], [\"FFCBA4\", \"Flesh\"], [\"FFCC33\", \"Sunglow\"], [\"FFCC5C\", \"Golden Tainoi\"], [\"FFCC99\", \"Peach Orange\"], [\"FFCD8C\", \"Chardonnay\"], [\"FFD1DC\", \"Pastel Pink\"], [\"FFD2B7\", \"Romantic\"], [\"FFD38C\", \"Grandis\"], [\"FFD700\", \"Gold\"], [\"FFD800\", \"School bus Yellow\"], [\"FFD8D9\", \"Cosmos\"], [\"FFDB58\", \"Mustard\"], [\"FFDCD6\", \"Peach Schnapps\"], [\"FFDDAF\", \"Caramel\"], [\"FFDDCD\", \"Tuft Bush\"], [\"FFDDCF\", \"Watusi\"], [\"FFDDF4\", \"Pink Lace\"], [\"FFDEAD\", \"Navajo White\"], [\"FFDEB3\", \"Frangipani\"], [\"FFE1DF\", \"Pippin\"], [\"FFE1F2\", \"Pale Rose\"], [\"FFE2C5\", \"Negroni\"], [\"FFE5A0\", \"Cream Brulee\"], [\"FFE5B4\", \"Peach\"], [\"FFE6C7\", \"Tequila\"], [\"FFE772\", \"Kournikova\"], [\"FFEAC8\", \"Sandy Beach\"], [\"FFEAD4\", \"Karry\"], [\"FFEC13\", \"Broom\"], [\"FFEDBC\", \"Colonial White\"], [\"FFEED8\", \"Derby\"], [\"FFEFA1\", \"Vis Vis\"], [\"FFEFC1\", \"Egg White\"], [\"FFEFD5\", \"Papaya Whip\"], [\"FFEFEC\", \"Fair Pink\"], [\"FFF0DB\", \"Peach Cream\"], [\"FFF0F5\", \"Lavender blush\"], [\"FFF14F\", \"Gorse\"], [\"FFF1B5\", \"Buttermilk\"], [\"FFF1D8\", \"Pink Lady\"], [\"FFF1EE\", \"Forget Me Not\"], [\"FFF1F9\", \"Tutu\"], [\"FFF39D\", \"Picasso\"], [\"FFF3F1\", \"Chardon\"], [\"FFF46E\", \"Paris Daisy\"], [\"FFF4CE\", \"Barley White\"], [\"FFF4DD\", \"Egg Sour\"], [\"FFF4E0\", \"Sazerac\"], [\"FFF4E8\", \"Serenade\"], [\"FFF4F3\", \"Chablis\"], [\"FFF5EE\", \"Seashell Peach\"], [\"FFF5F3\", \"Sauvignon\"], [\"FFF6D4\", \"Milk Punch\"], [\"FFF6DF\", \"Varden\"], [\"FFF6F5\", \"Rose White\"], [\"FFF8D1\", \"Baja White\"], [\"FFF9E2\", \"Gin Fizz\"], [\"FFF9E6\", \"Early Dawn\"], [\"FFFACD\", \"Lemon Chiffon\"], [\"FFFAF4\", \"Bridal Heath\"], [\"FFFBDC\", \"Scotch Mist\"], [\"FFFBF9\", \"Soapstone\"], [\"FFFC99\", \"Witch Haze\"], [\"FFFCEA\", \"Buttery White\"], [\"FFFCEE\", \"Island Spice\"], [\"FFFDD0\", \"Cream\"], [\"FFFDE6\", \"Chilean Heath\"], [\"FFFDE8\", \"Travertine\"], [\"FFFDF3\", \"Orchid White\"], [\"FFFDF4\", \"Quarter Pearl Lusta\"], [\"FFFEE1\", \"Half and Half\"], [\"FFFEEC\", \"Apricot White\"], [\"FFFEF0\", \"Rice Cake\"], [\"FFFEF6\", \"Black White\"], [\"FFFEFD\", \"Romance\"], [\"FFFF00\", \"Yellow\"], [\"FFFF66\", \"Laser Lemon\"], [\"FFFF99\", \"Pale Canary\"], [\"FFFFB4\", \"Portafino\"], [\"FFFFF0\", \"Ivory\"], [\"FFFFFF\", \"White\"], [\"acc2d9\", \"cloudy blue\"], [\"56ae57\", \"dark pastel green\"], [\"b2996e\", \"dust\"], [\"a8ff04\", \"electric lime\"], [\"69d84f\", \"fresh green\"], [\"894585\", \"light eggplant\"], [\"70b23f\", \"nasty green\"], [\"d4ffff\", \"really light blue\"], [\"65ab7c\", \"tea\"], [\"952e8f\", \"warm purple\"], [\"fcfc81\", \"yellowish tan\"], [\"a5a391\", \"cement\"], [\"388004\", \"dark grass green\"], [\"4c9085\", \"dusty teal\"], [\"5e9b8a\", \"grey teal\"], [\"efb435\", \"macaroni and cheese\"], [\"d99b82\", \"pinkish tan\"], [\"0a5f38\", \"spruce\"], [\"0c06f7\", \"strong blue\"], [\"61de2a\", \"toxic green\"], [\"3778bf\", \"windows blue\"], [\"2242c7\", \"blue blue\"], [\"533cc6\", \"blue with a hint of purple\"], [\"9bb53c\", \"booger\"], [\"05ffa6\", \"bright sea green\"], [\"1f6357\", \"dark green blue\"], [\"017374\", \"deep turquoise\"], [\"0cb577\", \"green teal\"], [\"ff0789\", \"strong pink\"], [\"afa88b\", \"bland\"], [\"08787f\", \"deep aqua\"], [\"dd85d7\", \"lavender pink\"], [\"a6c875\", \"light moss green\"], [\"a7ffb5\", \"light seafoam green\"], [\"c2b709\", \"olive yellow\"], [\"e78ea5\", \"pig pink\"], [\"966ebd\", \"deep lilac\"], [\"ccad60\", \"desert\"], [\"ac86a8\", \"dusty lavender\"], [\"947e94\", \"purpley grey\"], [\"983fb2\", \"purply\"], [\"ff63e9\", \"candy pink\"], [\"b2fba5\", \"light pastel green\"], [\"63b365\", \"boring green\"], [\"8ee53f\", \"kiwi green\"], [\"b7e1a1\", \"light grey green\"], [\"ff6f52\", \"orange pink\"], [\"bdf8a3\", \"tea green\"], [\"d3b683\", \"very light brown\"], [\"fffcc4\", \"egg shell\"], [\"430541\", \"eggplant purple\"], [\"ffb2d0\", \"powder pink\"], [\"997570\", \"reddish grey\"], [\"ad900d\", \"baby shit brown\"], [\"c48efd\", \"liliac\"], [\"507b9c\", \"stormy blue\"], [\"7d7103\", \"ugly brown\"], [\"fffd78\", \"custard\"], [\"da467d\", \"darkish pink\"], [\"410200\", \"deep brown\"], [\"c9d179\", \"greenish beige\"], [\"fffa86\", \"manilla\"], [\"5684ae\", \"off blue\"], [\"6b7c85\", \"battleship grey\"], [\"6f6c0a\", \"browny green\"], [\"7e4071\", \"bruise\"], [\"009337\", \"kelley green\"], [\"d0e429\", \"sickly yellow\"], [\"fff917\", \"sunny yellow\"], [\"1d5dec\", \"azul\"], [\"054907\", \"darkgreen\"], [\"b5ce08\", \"green/yellow\"], [\"8fb67b\", \"lichen\"], [\"c8ffb0\", \"light light green\"], [\"fdde6c\", \"pale gold\"], [\"ffdf22\", \"sun yellow\"], [\"a9be70\", \"tan green\"], [\"6832e3\", \"burple\"], [\"fdb147\", \"butterscotch\"], [\"c7ac7d\", \"toupe\"], [\"fff39a\", \"dark cream\"], [\"850e04\", \"indian red\"], [\"efc0fe\", \"light lavendar\"], [\"40fd14\", \"poison green\"], [\"b6c406\", \"baby puke green\"], [\"9dff00\", \"bright yellow green\"], [\"3c4142\", \"charcoal grey\"], [\"f2ab15\", \"squash\"], [\"ac4f06\", \"cinnamon\"], [\"c4fe82\", \"light pea green\"], [\"2cfa1f\", \"radioactive green\"], [\"9a6200\", \"raw sienna\"], [\"ca9bf7\", \"baby purple\"], [\"875f42\", \"cocoa\"], [\"3a2efe\", \"light royal blue\"], [\"fd8d49\", \"orangeish\"], [\"8b3103\", \"rust brown\"], [\"cba560\", \"sand brown\"], [\"698339\", \"swamp\"], [\"0cdc73\", \"tealish green\"], [\"b75203\", \"burnt siena\"], [\"7f8f4e\", \"camo\"], [\"26538d\", \"dusk blue\"], [\"63a950\", \"fern\"], [\"c87f89\", \"old rose\"], [\"b1fc99\", \"pale light green\"], [\"ff9a8a\", \"peachy pink\"], [\"f6688e\", \"rosy pink\"], [\"76fda8\", \"light bluish green\"], [\"53fe5c\", \"light bright green\"], [\"4efd54\", \"light neon green\"], [\"a0febf\", \"light seafoam\"], [\"7bf2da\", \"tiffany blue\"], [\"bcf5a6\", \"washed out green\"], [\"ca6b02\", \"browny orange\"], [\"107ab0\", \"nice blue\"], [\"2138ab\", \"sapphire\"], [\"719f91\", \"greyish teal\"], [\"fdb915\", \"orangey yellow\"], [\"fefcaf\", \"parchment\"], [\"fcf679\", \"straw\"], [\"1d0200\", \"very dark brown\"], [\"cb6843\", \"terracota\"], [\"31668a\", \"ugly blue\"], [\"247afd\", \"clear blue\"], [\"ffffb6\", \"creme\"], [\"90fda9\", \"foam green\"], [\"86a17d\", \"grey/green\"], [\"fddc5c\", \"light gold\"], [\"78d1b6\", \"seafoam blue\"], [\"13bbaf\", \"topaz\"], [\"fb5ffc\", \"violet pink\"], [\"20f986\", \"wintergreen\"], [\"ffe36e\", \"yellow tan\"], [\"9d0759\", \"dark fuchsia\"], [\"3a18b1\", \"indigo blue\"], [\"c2ff89\", \"light yellowish green\"], [\"d767ad\", \"pale magenta\"], [\"720058\", \"rich purple\"], [\"ffda03\", \"sunflower yellow\"], [\"01c08d\", \"green/blue\"], [\"ac7434\", \"leather\"], [\"014600\", \"racing green\"], [\"9900fa\", \"vivid purple\"], [\"02066f\", \"dark royal blue\"], [\"8e7618\", \"hazel\"], [\"d1768f\", \"muted pink\"], [\"96b403\", \"booger green\"], [\"fdff63\", \"canary\"], [\"95a3a6\", \"cool grey\"], [\"7f684e\", \"dark taupe\"], [\"751973\", \"darkish purple\"], [\"089404\", \"true green\"], [\"ff6163\", \"coral pink\"], [\"598556\", \"dark sage\"], [\"214761\", \"dark slate blue\"], [\"3c73a8\", \"flat blue\"], [\"ba9e88\", \"mushroom\"], [\"021bf9\", \"rich blue\"], [\"734a65\", \"dirty purple\"], [\"23c48b\", \"greenblue\"], [\"8fae22\", \"icky green\"], [\"e6f2a2\", \"light khaki\"], [\"4b57db\", \"warm blue\"], [\"d90166\", \"dark hot pink\"], [\"015482\", \"deep sea blue\"], [\"9d0216\", \"carmine\"], [\"728f02\", \"dark yellow green\"], [\"ffe5ad\", \"pale peach\"], [\"4e0550\", \"plum purple\"], [\"f9bc08\", \"golden rod\"], [\"ff073a\", \"neon red\"], [\"c77986\", \"old pink\"], [\"d6fffe\", \"very pale blue\"], [\"fe4b03\", \"blood orange\"], [\"fd5956\", \"grapefruit\"], [\"fce166\", \"sand yellow\"], [\"b2713d\", \"clay brown\"], [\"1f3b4d\", \"dark blue grey\"], [\"699d4c\", \"flat green\"], [\"56fca2\", \"light green blue\"], [\"fb5581\", \"warm pink\"], [\"3e82fc\", \"dodger blue\"], [\"a0bf16\", \"gross green\"], [\"d6fffa\", \"ice\"], [\"4f738e\", \"metallic blue\"], [\"ffb19a\", \"pale salmon\"], [\"5c8b15\", \"sap green\"], [\"54ac68\", \"algae\"], [\"89a0b0\", \"bluey grey\"], [\"7ea07a\", \"greeny grey\"], [\"1bfc06\", \"highlighter green\"], [\"cafffb\", \"light light blue\"], [\"b6ffbb\", \"light mint\"], [\"a75e09\", \"raw umber\"], [\"152eff\", \"vivid blue\"], [\"8d5eb7\", \"deep lavender\"], [\"5f9e8f\", \"dull teal\"], [\"63f7b4\", \"light greenish blue\"], [\"606602\", \"mud green\"], [\"fc86aa\", \"pinky\"], [\"8c0034\", \"red wine\"], [\"758000\", \"shit green\"], [\"ab7e4c\", \"tan brown\"], [\"030764\", \"darkblue\"], [\"fe86a4\", \"rosa\"], [\"d5174e\", \"lipstick\"], [\"fed0fc\", \"pale mauve\"], [\"680018\", \"claret\"], [\"fedf08\", \"dandelion\"], [\"fe420f\", \"orangered\"], [\"6f7c00\", \"poop green\"], [\"ca0147\", \"ruby\"], [\"1b2431\", \"dark\"], [\"00fbb0\", \"greenish turquoise\"], [\"db5856\", \"pastel red\"], [\"ddd618\", \"piss yellow\"], [\"41fdfe\", \"bright cyan\"], [\"cf524e\", \"dark coral\"], [\"21c36f\", \"algae green\"], [\"a90308\", \"darkish red\"], [\"6e1005\", \"reddy brown\"], [\"fe828c\", \"blush pink\"], [\"4b6113\", \"camouflage green\"], [\"4da409\", \"lawn green\"], [\"beae8a\", \"putty\"], [\"0339f8\", \"vibrant blue\"], [\"a88f59\", \"dark sand\"], [\"5d21d0\", \"purple/blue\"], [\"feb209\", \"saffron\"], [\"4e518b\", \"twilight\"], [\"964e02\", \"warm brown\"], [\"85a3b2\", \"bluegrey\"], [\"ff69af\", \"bubble gum pink\"], [\"c3fbf4\", \"duck egg blue\"], [\"2afeb7\", \"greenish cyan\"], [\"005f6a\", \"petrol\"], [\"0c1793\", \"royal\"], [\"ffff81\", \"butter\"], [\"f0833a\", \"dusty orange\"], [\"f1f33f\", \"off yellow\"], [\"b1d27b\", \"pale olive green\"], [\"fc824a\", \"orangish\"], [\"71aa34\", \"leaf\"], [\"b7c9e2\", \"light blue grey\"], [\"4b0101\", \"dried blood\"], [\"a552e6\", \"lightish purple\"], [\"af2f0d\", \"rusty red\"], [\"8b88f8\", \"lavender blue\"], [\"9af764\", \"light grass green\"], [\"a6fbb2\", \"light mint green\"], [\"ffc512\", \"sunflower\"], [\"750851\", \"velvet\"], [\"c14a09\", \"brick orange\"], [\"fe2f4a\", \"lightish red\"], [\"0203e2\", \"pure blue\"], [\"0a437a\", \"twilight blue\"], [\"a50055\", \"violet red\"], [\"ae8b0c\", \"yellowy brown\"], [\"fd798f\", \"carnation\"], [\"bfac05\", \"muddy yellow\"], [\"3eaf76\", \"dark seafoam green\"], [\"c74767\", \"deep rose\"], [\"b9484e\", \"dusty red\"], [\"647d8e\", \"grey/blue\"], [\"bffe28\", \"lemon lime\"], [\"d725de\", \"purple/pink\"], [\"b29705\", \"brown yellow\"], [\"673a3f\", \"purple brown\"], [\"a87dc2\", \"wisteria\"], [\"fafe4b\", \"banana yellow\"], [\"c0022f\", \"lipstick red\"], [\"0e87cc\", \"water blue\"], [\"8d8468\", \"brown grey\"], [\"ad03de\", \"vibrant purple\"], [\"8cff9e\", \"baby green\"], [\"94ac02\", \"barf green\"], [\"c4fff7\", \"eggshell blue\"], [\"fdee73\", \"sandy yellow\"], [\"33b864\", \"cool green\"], [\"fff9d0\", \"pale\"], [\"758da3\", \"blue/grey\"], [\"f504c9\", \"hot magenta\"], [\"77a1b5\", \"greyblue\"], [\"8756e4\", \"purpley\"], [\"889717\", \"baby shit green\"], [\"c27e79\", \"brownish pink\"], [\"017371\", \"dark aquamarine\"], [\"9f8303\", \"diarrhea\"], [\"f7d560\", \"light mustard\"], [\"bdf6fe\", \"pale sky blue\"], [\"75b84f\", \"turtle green\"], [\"9cbb04\", \"bright olive\"], [\"29465b\", \"dark grey blue\"], [\"696006\", \"greeny brown\"], [\"adf802\", \"lemon green\"], [\"c1c6fc\", \"light periwinkle\"], [\"35ad6b\", \"seaweed green\"], [\"fffd37\", \"sunshine yellow\"], [\"a442a0\", \"ugly purple\"], [\"f36196\", \"medium pink\"], [\"947706\", \"puke brown\"], [\"fff4f2\", \"very light pink\"], [\"1e9167\", \"viridian\"], [\"b5c306\", \"bile\"], [\"feff7f\", \"faded yellow\"], [\"cffdbc\", \"very pale green\"], [\"0add08\", \"vibrant green\"], [\"87fd05\", \"bright lime\"], [\"1ef876\", \"spearmint\"], [\"7bfdc7\", \"light aquamarine\"], [\"bcecac\", \"light sage\"], [\"bbf90f\", \"yellowgreen\"], [\"ab9004\", \"baby poo\"], [\"1fb57a\", \"dark seafoam\"], [\"00555a\", \"deep teal\"], [\"a484ac\", \"heather\"], [\"c45508\", \"rust orange\"], [\"3f829d\", \"dirty blue\"], [\"548d44\", \"fern green\"], [\"c95efb\", \"bright lilac\"], [\"3ae57f\", \"weird green\"], [\"016795\", \"peacock blue\"], [\"87a922\", \"avocado green\"], [\"f0944d\", \"faded orange\"], [\"5d1451\", \"grape purple\"], [\"25ff29\", \"hot green\"], [\"d0fe1d\", \"lime yellow\"], [\"ffa62b\", \"mango\"], [\"01b44c\", \"shamrock\"], [\"ff6cb5\", \"bubblegum\"], [\"6b4247\", \"purplish brown\"], [\"c7c10c\", \"vomit yellow\"], [\"b7fffa\", \"pale cyan\"], [\"aeff6e\", \"key lime\"], [\"ec2d01\", \"tomato red\"], [\"76ff7b\", \"lightgreen\"], [\"730039\", \"merlot\"], [\"040348\", \"night blue\"], [\"df4ec8\", \"purpleish pink\"], [\"6ecb3c\", \"apple\"], [\"8f9805\", \"baby poop green\"], [\"5edc1f\", \"green apple\"], [\"d94ff5\", \"heliotrope\"], [\"c8fd3d\", \"yellow/green\"], [\"070d0d\", \"almost black\"], [\"4984b8\", \"cool blue\"], [\"51b73b\", \"leafy green\"], [\"ac7e04\", \"mustard brown\"], [\"4e5481\", \"dusk\"], [\"876e4b\", \"dull brown\"], [\"58bc08\", \"frog green\"], [\"2fef10\", \"vivid green\"], [\"2dfe54\", \"bright light green\"], [\"0aff02\", \"fluro green\"], [\"9cef43\", \"kiwi\"], [\"18d17b\", \"seaweed\"], [\"35530a\", \"navy green\"], [\"1805db\", \"ultramarine blue\"], [\"6258c4\", \"iris\"], [\"ff964f\", \"pastel orange\"], [\"ffab0f\", \"yellowish orange\"], [\"8f8ce7\", \"perrywinkle\"], [\"24bca8\", \"tealish\"], [\"3f012c\", \"dark plum\"], [\"cbf85f\", \"pear\"], [\"ff724c\", \"pinkish orange\"], [\"280137\", \"midnight purple\"], [\"b36ff6\", \"light urple\"], [\"48c072\", \"dark mint\"], [\"bccb7a\", \"greenish tan\"], [\"a8415b\", \"light burgundy\"], [\"06b1c4\", \"turquoise blue\"], [\"cd7584\", \"ugly pink\"], [\"f1da7a\", \"sandy\"], [\"ff0490\", \"electric pink\"], [\"805b87\", \"muted purple\"], [\"50a747\", \"mid green\"], [\"a8a495\", \"greyish\"], [\"cfff04\", \"neon yellow\"], [\"ffff7e\", \"banana\"], [\"ff7fa7\", \"carnation pink\"], [\"ef4026\", \"tomato\"], [\"3c9992\", \"sea\"], [\"886806\", \"muddy brown\"], [\"04f489\", \"turquoise green\"], [\"fef69e\", \"buff\"], [\"cfaf7b\", \"fawn\"], [\"3b719f\", \"muted blue\"], [\"fdc1c5\", \"pale rose\"], [\"20c073\", \"dark mint green\"], [\"9b5fc0\", \"amethyst\"], [\"0f9b8e\", \"blue/green\"], [\"742802\", \"chestnut\"], [\"9db92c\", \"sick green\"], [\"a4bf20\", \"pea\"], [\"cd5909\", \"rusty orange\"], [\"ada587\", \"stone\"], [\"be013c\", \"rose red\"], [\"b8ffeb\", \"pale aqua\"], [\"dc4d01\", \"deep orange\"], [\"a2653e\", \"earth\"], [\"638b27\", \"mossy green\"], [\"419c03\", \"grassy green\"], [\"b1ff65\", \"pale lime green\"], [\"9dbcd4\", \"light grey blue\"], [\"fdfdfe\", \"pale grey\"], [\"77ab56\", \"asparagus\"], [\"464196\", \"blueberry\"], [\"990147\", \"purple red\"], [\"befd73\", \"pale lime\"], [\"32bf84\", \"greenish teal\"], [\"af6f09\", \"caramel\"], [\"a0025c\", \"deep magenta\"], [\"ffd8b1\", \"light peach\"], [\"7f4e1e\", \"milk chocolate\"], [\"bf9b0c\", \"ocher\"], [\"6ba353\", \"off green\"], [\"f075e6\", \"purply pink\"], [\"7bc8f6\", \"lightblue\"], [\"475f94\", \"dusky blue\"], [\"f5bf03\", \"golden\"], [\"fffeb6\", \"light beige\"], [\"fffd74\", \"butter yellow\"], [\"895b7b\", \"dusky purple\"], [\"436bad\", \"french blue\"], [\"d0c101\", \"ugly yellow\"], [\"c6f808\", \"greeny yellow\"], [\"f43605\", \"orangish red\"], [\"02c14d\", \"shamrock green\"], [\"b25f03\", \"orangish brown\"], [\"2a7e19\", \"tree green\"], [\"490648\", \"deep violet\"], [\"536267\", \"gunmetal\"], [\"5a06ef\", \"blue/purple\"], [\"cf0234\", \"cherry\"], [\"c4a661\", \"sandy brown\"], [\"978a84\", \"warm grey\"], [\"1f0954\", \"dark indigo\"], [\"03012d\", \"midnight\"], [\"2bb179\", \"bluey green\"], [\"c3909b\", \"grey pink\"], [\"a66fb5\", \"soft purple\"], [\"770001\", \"blood\"], [\"922b05\", \"brown red\"], [\"7d7f7c\", \"medium grey\"], [\"990f4b\", \"berry\"], [\"8f7303\", \"poo\"], [\"c83cb9\", \"purpley pink\"], [\"fea993\", \"light salmon\"], [\"acbb0d\", \"snot\"], [\"c071fe\", \"easter purple\"], [\"ccfd7f\", \"light yellow green\"], [\"00022e\", \"dark navy blue\"], [\"828344\", \"drab\"], [\"ffc5cb\", \"light rose\"], [\"ab1239\", \"rouge\"], [\"b0054b\", \"purplish red\"], [\"99cc04\", \"slime green\"], [\"937c00\", \"baby poop\"], [\"019529\", \"irish green\"], [\"ef1de7\", \"pink/purple\"], [\"000435\", \"dark navy\"], [\"42b395\", \"greeny blue\"], [\"9d5783\", \"light plum\"], [\"c8aca9\", \"pinkish grey\"], [\"c87606\", \"dirty orange\"], [\"aa2704\", \"rust red\"], [\"e4cbff\", \"pale lilac\"], [\"fa4224\", \"orangey red\"], [\"0804f9\", \"primary blue\"], [\"5cb200\", \"kermit green\"], [\"76424e\", \"brownish purple\"], [\"6c7a0e\", \"murky green\"], [\"fbdd7e\", \"wheat\"], [\"2a0134\", \"very dark purple\"], [\"044a05\", \"bottle green\"], [\"fd4659\", \"watermelon\"], [\"0d75f8\", \"deep sky blue\"], [\"fe0002\", \"fire engine red\"], [\"cb9d06\", \"yellow ochre\"], [\"fb7d07\", \"pumpkin orange\"], [\"b9cc81\", \"pale olive\"], [\"edc8ff\", \"light lilac\"], [\"61e160\", \"lightish green\"], [\"8ab8fe\", \"carolina blue\"], [\"920a4e\", \"mulberry\"], [\"fe02a2\", \"shocking pink\"], [\"9a3001\", \"auburn\"], [\"65fe08\", \"bright lime green\"], [\"befdb7\", \"celadon\"], [\"b17261\", \"pinkish brown\"], [\"885f01\", \"poo brown\"], [\"02ccfe\", \"bright sky blue\"], [\"c1fd95\", \"celery\"], [\"836539\", \"dirt brown\"], [\"fb2943\", \"strawberry\"], [\"84b701\", \"dark lime\"], [\"b66325\", \"copper\"], [\"7f5112\", \"medium brown\"], [\"5fa052\", \"muted green\"], [\"6dedfd\", \"robin's egg\"], [\"0bf9ea\", \"bright aqua\"], [\"c760ff\", \"bright lavender\"], [\"ffffcb\", \"ivory\"], [\"f6cefc\", \"very light purple\"], [\"155084\", \"light navy\"], [\"f5054f\", \"pink red\"], [\"645403\", \"olive brown\"], [\"7a5901\", \"poop brown\"], [\"a8b504\", \"mustard green\"], [\"3d9973\", \"ocean green\"], [\"000133\", \"very dark blue\"], [\"76a973\", \"dusty green\"], [\"2e5a88\", \"light navy blue\"], [\"0bf77d\", \"minty green\"], [\"bd6c48\", \"adobe\"], [\"ac1db8\", \"barney\"], [\"2baf6a\", \"jade green\"], [\"26f7fd\", \"bright light blue\"], [\"aefd6c\", \"light lime\"], [\"9b8f55\", \"dark khaki\"], [\"ffad01\", \"orange yellow\"], [\"c69c04\", \"ocre\"], [\"f4d054\", \"maize\"], [\"de9dac\", \"faded pink\"], [\"05480d\", \"british racing green\"], [\"c9ae74\", \"sandstone\"], [\"60460f\", \"mud brown\"], [\"98f6b0\", \"light sea green\"], [\"8af1fe\", \"robin egg blue\"], [\"2ee8bb\", \"aqua marine\"], [\"11875d\", \"dark sea green\"], [\"fdb0c0\", \"soft pink\"], [\"b16002\", \"orangey brown\"], [\"f7022a\", \"cherry red\"], [\"d5ab09\", \"burnt yellow\"], [\"86775f\", \"brownish grey\"], [\"c69f59\", \"camel\"], [\"7a687f\", \"purplish grey\"], [\"042e60\", \"marine\"], [\"c88d94\", \"greyish pink\"], [\"a5fbd5\", \"pale turquoise\"], [\"fffe71\", \"pastel yellow\"], [\"6241c7\", \"bluey purple\"], [\"fffe40\", \"canary yellow\"], [\"d3494e\", \"faded red\"], [\"985e2b\", \"sepia\"], [\"a6814c\", \"coffee\"], [\"ff08e8\", \"bright magenta\"], [\"9d7651\", \"mocha\"], [\"feffca\", \"ecru\"], [\"98568d\", \"purpleish\"], [\"9e003a\", \"cranberry\"], [\"287c37\", \"darkish green\"], [\"b96902\", \"brown orange\"], [\"ba6873\", \"dusky rose\"], [\"ff7855\", \"melon\"], [\"94b21c\", \"sickly green\"], [\"c5c9c7\", \"silver\"], [\"661aee\", \"purply blue\"], [\"6140ef\", \"purpleish blue\"], [\"9be5aa\", \"hospital green\"], [\"7b5804\", \"shit brown\"], [\"276ab3\", \"mid blue\"], [\"feb308\", \"amber\"], [\"8cfd7e\", \"easter green\"], [\"6488ea\", \"soft blue\"], [\"056eee\", \"cerulean blue\"], [\"b27a01\", \"golden brown\"], [\"0ffef9\", \"bright turquoise\"], [\"fa2a55\", \"red pink\"], [\"820747\", \"red purple\"], [\"7a6a4f\", \"greyish brown\"], [\"f4320c\", \"vermillion\"], [\"a13905\", \"russet\"], [\"6f828a\", \"steel grey\"], [\"a55af4\", \"lighter purple\"], [\"ad0afd\", \"bright violet\"], [\"004577\", \"prussian blue\"], [\"658d6d\", \"slate green\"], [\"ca7b80\", \"dirty pink\"], [\"005249\", \"dark blue green\"], [\"2b5d34\", \"pine\"], [\"bff128\", \"yellowy green\"], [\"b59410\", \"dark gold\"], [\"2976bb\", \"bluish\"], [\"014182\", \"darkish blue\"], [\"bb3f3f\", \"dull red\"], [\"fc2647\", \"pinky red\"], [\"a87900\", \"bronze\"], [\"82cbb2\", \"pale teal\"], [\"667c3e\", \"military green\"], [\"fe46a5\", \"barbie pink\"], [\"fe83cc\", \"bubblegum pink\"], [\"94a617\", \"pea soup green\"], [\"a88905\", \"dark mustard\"], [\"7f5f00\", \"shit\"], [\"9e43a2\", \"medium purple\"], [\"062e03\", \"very dark green\"], [\"8a6e45\", \"dirt\"], [\"cc7a8b\", \"dusky pink\"], [\"9e0168\", \"red violet\"], [\"fdff38\", \"lemon yellow\"], [\"c0fa8b\", \"pistachio\"], [\"eedc5b\", \"dull yellow\"], [\"7ebd01\", \"dark lime green\"], [\"3b5b92\", \"denim blue\"], [\"01889f\", \"teal blue\"], [\"3d7afd\", \"lightish blue\"], [\"5f34e7\", \"purpley blue\"], [\"6d5acf\", \"light indigo\"], [\"748500\", \"swamp green\"], [\"706c11\", \"brown green\"], [\"3c0008\", \"dark maroon\"], [\"cb00f5\", \"hot purple\"], [\"002d04\", \"dark forest green\"], [\"658cbb\", \"faded blue\"], [\"749551\", \"drab green\"], [\"b9ff66\", \"light lime green\"], [\"9dc100\", \"snot green\"], [\"faee66\", \"yellowish\"], [\"7efbb3\", \"light blue green\"], [\"7b002c\", \"bordeaux\"], [\"c292a1\", \"light mauve\"], [\"017b92\", \"ocean\"], [\"fcc006\", \"marigold\"], [\"657432\", \"muddy green\"], [\"d8863b\", \"dull orange\"], [\"738595\", \"steel\"], [\"aa23ff\", \"electric purple\"], [\"08ff08\", \"fluorescent green\"], [\"9b7a01\", \"yellowish brown\"], [\"f29e8e\", \"blush\"], [\"6fc276\", \"soft green\"], [\"ff5b00\", \"bright orange\"], [\"fdff52\", \"lemon\"], [\"866f85\", \"purple grey\"], [\"8ffe09\", \"acid green\"], [\"eecffe\", \"pale lavender\"], [\"510ac9\", \"violet blue\"], [\"4f9153\", \"light forest green\"], [\"9f2305\", \"burnt red\"], [\"728639\", \"khaki green\"], [\"de0c62\", \"cerise\"], [\"916e99\", \"faded purple\"], [\"ffb16d\", \"apricot\"], [\"3c4d03\", \"dark olive green\"], [\"7f7053\", \"grey brown\"], [\"77926f\", \"green grey\"], [\"010fcc\", \"true blue\"], [\"ceaefa\", \"pale violet\"], [\"8f99fb\", \"periwinkle blue\"], [\"c6fcff\", \"light sky blue\"], [\"5539cc\", \"blurple\"], [\"544e03\", \"green brown\"], [\"017a79\", \"bluegreen\"], [\"01f9c6\", \"bright teal\"], [\"c9b003\", \"brownish yellow\"], [\"929901\", \"pea soup\"], [\"0b5509\", \"forest\"], [\"a00498\", \"barney purple\"], [\"2000b1\", \"ultramarine\"], [\"94568c\", \"purplish\"], [\"c2be0e\", \"puke yellow\"], [\"748b97\", \"bluish grey\"], [\"665fd1\", \"dark periwinkle\"], [\"9c6da5\", \"dark lilac\"], [\"c44240\", \"reddish\"], [\"a24857\", \"light maroon\"], [\"825f87\", \"dusty purple\"], [\"c9643b\", \"terra cotta\"], [\"90b134\", \"avocado\"], [\"01386a\", \"marine blue\"], [\"25a36f\", \"teal green\"], [\"59656d\", \"slate grey\"], [\"75fd63\", \"lighter green\"], [\"21fc0d\", \"electric green\"], [\"5a86ad\", \"dusty blue\"], [\"fec615\", \"golden yellow\"], [\"fffd01\", \"bright yellow\"], [\"dfc5fe\", \"light lavender\"], [\"b26400\", \"umber\"], [\"7f5e00\", \"poop\"], [\"de7e5d\", \"dark peach\"], [\"048243\", \"jungle green\"], [\"ffffd4\", \"eggshell\"], [\"3b638c\", \"denim\"], [\"b79400\", \"yellow brown\"], [\"84597e\", \"dull purple\"], [\"411900\", \"chocolate brown\"], [\"7b0323\", \"wine red\"], [\"04d9ff\", \"neon blue\"], [\"667e2c\", \"dirty green\"], [\"fbeeac\", \"light tan\"], [\"d7fffe\", \"ice blue\"], [\"4e7496\", \"cadet blue\"], [\"874c62\", \"dark mauve\"], [\"d5ffff\", \"very light blue\"], [\"826d8c\", \"grey purple\"], [\"ffbacd\", \"pastel pink\"], [\"d1ffbd\", \"very light green\"], [\"448ee4\", \"dark sky blue\"], [\"05472a\", \"evergreen\"], [\"d5869d\", \"dull pink\"], [\"3d0734\", \"aubergine\"], [\"4a0100\", \"mahogany\"], [\"f8481c\", \"reddish orange\"], [\"02590f\", \"deep green\"], [\"89a203\", \"vomit green\"], [\"e03fd8\", \"purple pink\"], [\"d58a94\", \"dusty pink\"], [\"7bb274\", \"faded green\"], [\"526525\", \"camo green\"], [\"c94cbe\", \"pinky purple\"], [\"db4bda\", \"pink purple\"], [\"9e3623\", \"brownish red\"], [\"b5485d\", \"dark rose\"], [\"735c12\", \"mud\"], [\"9c6d57\", \"brownish\"], [\"028f1e\", \"emerald green\"], [\"b1916e\", \"pale brown\"], [\"49759c\", \"dull blue\"], [\"a0450e\", \"burnt umber\"], [\"39ad48\", \"medium green\"], [\"b66a50\", \"clay\"], [\"8cffdb\", \"light aqua\"], [\"a4be5c\", \"light olive green\"], [\"cb7723\", \"brownish orange\"], [\"05696b\", \"dark aqua\"], [\"ce5dae\", \"purplish pink\"], [\"c85a53\", \"dark salmon\"], [\"96ae8d\", \"greenish grey\"], [\"1fa774\", \"jade\"], [\"7a9703\", \"ugly green\"], [\"ac9362\", \"dark beige\"], [\"01a049\", \"emerald\"], [\"d9544d\", \"pale red\"], [\"fa5ff7\", \"light magenta\"], [\"82cafc\", \"sky\"], [\"acfffc\", \"light cyan\"], [\"fcb001\", \"yellow orange\"], [\"910951\", \"reddish purple\"], [\"fe2c54\", \"reddish pink\"], [\"c875c4\", \"orchid\"], [\"cdc50a\", \"dirty yellow\"], [\"fd411e\", \"orange red\"], [\"9a0200\", \"deep red\"], [\"be6400\", \"orange brown\"], [\"030aa7\", \"cobalt blue\"], [\"fe019a\", \"neon pink\"], [\"f7879a\", \"rose pink\"], [\"887191\", \"greyish purple\"], [\"b00149\", \"raspberry\"], [\"12e193\", \"aqua green\"], [\"fe7b7c\", \"salmon pink\"], [\"ff9408\", \"tangerine\"], [\"6a6e09\", \"brownish green\"], [\"8b2e16\", \"red brown\"], [\"696112\", \"greenish brown\"], [\"e17701\", \"pumpkin\"], [\"0a481e\", \"pine green\"], [\"343837\", \"charcoal\"], [\"ffb7ce\", \"baby pink\"], [\"6a79f7\", \"cornflower\"], [\"5d06e9\", \"blue violet\"], [\"3d1c02\", \"chocolate\"], [\"82a67d\", \"greyish green\"], [\"be0119\", \"scarlet\"], [\"c9ff27\", \"green yellow\"], [\"373e02\", \"dark olive\"], [\"a9561e\", \"sienna\"], [\"caa0ff\", \"pastel purple\"], [\"ca6641\", \"terracotta\"], [\"02d8e9\", \"aqua blue\"], [\"88b378\", \"sage green\"], [\"980002\", \"blood red\"], [\"cb0162\", \"deep pink\"], [\"5cac2d\", \"grass\"], [\"769958\", \"moss\"], [\"a2bffe\", \"pastel blue\"], [\"10a674\", \"bluish green\"], [\"06b48b\", \"green blue\"], [\"af884a\", \"dark tan\"], [\"0b8b87\", \"greenish blue\"], [\"ffa756\", \"pale orange\"], [\"a2a415\", \"vomit\"], [\"154406\", \"forrest green\"], [\"856798\", \"dark lavender\"], [\"34013f\", \"dark violet\"], [\"632de9\", \"purple blue\"], [\"0a888a\", \"dark cyan\"], [\"6f7632\", \"olive drab\"], [\"d46a7e\", \"pinkish\"], [\"1e488f\", \"cobalt\"], [\"bc13fe\", \"neon purple\"], [\"7ef4cc\", \"light turquoise\"], [\"76cd26\", \"apple green\"], [\"74a662\", \"dull green\"], [\"80013f\", \"wine\"], [\"b1d1fc\", \"powder blue\"], [\"ffffe4\", \"off white\"], [\"0652ff\", \"electric blue\"], [\"045c5a\", \"dark turquoise\"], [\"5729ce\", \"blue purple\"], [\"069af3\", \"azure\"], [\"ff000d\", \"bright red\"], [\"f10c45\", \"pinkish red\"], [\"5170d7\", \"cornflower blue\"], [\"acbf69\", \"light olive\"], [\"6c3461\", \"grape\"], [\"5e819d\", \"greyish blue\"], [\"601ef9\", \"purplish blue\"], [\"b0dd16\", \"yellowish green\"], [\"cdfd02\", \"greenish yellow\"], [\"2c6fbb\", \"medium blue\"], [\"c0737a\", \"dusty rose\"], [\"d6b4fc\", \"light violet\"], [\"020035\", \"midnight blue\"], [\"703be7\", \"bluish purple\"], [\"fd3c06\", \"red orange\"], [\"960056\", \"dark magenta\"], [\"40a368\", \"greenish\"], [\"03719c\", \"ocean blue\"], [\"fc5a50\", \"coral\"], [\"ffffc2\", \"cream\"], [\"7f2b0a\", \"reddish brown\"], [\"b04e0f\", \"burnt sienna\"], [\"a03623\", \"brick\"], [\"87ae73\", \"sage\"], [\"789b73\", \"grey green\"], [\"ffffff\", \"white\"], [\"98eff9\", \"robin's egg blue\"], [\"658b38\", \"moss green\"], [\"5a7d9a\", \"steel blue\"], [\"380835\", \"eggplant\"], [\"fffe7a\", \"light yellow\"], [\"5ca904\", \"leaf green\"], [\"d8dcd6\", \"light grey\"], [\"a5a502\", \"puke\"], [\"d648d7\", \"pinkish purple\"], [\"047495\", \"sea blue\"], [\"b790d4\", \"pale purple\"], [\"5b7c99\", \"slate blue\"], [\"607c8e\", \"blue grey\"], [\"0b4008\", \"hunter green\"], [\"ed0dd9\", \"fuchsia\"], [\"8c000f\", \"crimson\"], [\"ffff84\", \"pale yellow\"], [\"bf9005\", \"ochre\"], [\"d2bd0a\", \"mustard yellow\"], [\"ff474c\", \"light red\"], [\"0485d1\", \"cerulean\"], [\"ffcfdc\", \"pale pink\"], [\"040273\", \"deep blue\"], [\"a83c09\", \"rust\"], [\"90e4c1\", \"light teal\"], [\"516572\", \"slate\"], [\"fac205\", \"goldenrod\"], [\"d5b60a\", \"dark yellow\"], [\"363737\", \"dark grey\"], [\"4b5d16\", \"army green\"], [\"6b8ba4\", \"grey blue\"], [\"80f9ad\", \"seafoam\"], [\"a57e52\", \"puce\"], [\"a9f971\", \"spring green\"], [\"c65102\", \"dark orange\"], [\"e2ca76\", \"sand\"], [\"b0ff9d\", \"pastel green\"], [\"9ffeb0\", \"mint\"], [\"fdaa48\", \"light orange\"], [\"fe01b1\", \"bright pink\"], [\"c1f80a\", \"chartreuse\"], [\"36013f\", \"deep purple\"], [\"341c02\", \"dark brown\"], [\"b9a281\", \"taupe\"], [\"8eab12\", \"pea green\"], [\"9aae07\", \"puke green\"], [\"02ab2e\", \"kelly green\"], [\"7af9ab\", \"seafoam green\"], [\"137e6d\", \"blue green\"], [\"aaa662\", \"khaki\"], [\"610023\", \"burgundy\"], [\"014d4e\", \"dark teal\"], [\"8f1402\", \"brick red\"], [\"4b006e\", \"royal purple\"], [\"580f41\", \"plum\"], [\"8fff9f\", \"mint green\"], [\"dbb40c\", \"gold\"], [\"a2cffe\", \"baby blue\"], [\"c0fb2d\", \"yellow green\"], [\"be03fd\", \"bright purple\"], [\"840000\", \"dark red\"], [\"d0fefe\", \"pale blue\"], [\"3f9b0b\", \"grass green\"], [\"01153e\", \"navy\"], [\"04d8b2\", \"aquamarine\"], [\"c04e01\", \"burnt orange\"], [\"0cff0c\", \"neon green\"], [\"0165fc\", \"bright blue\"], [\"cf6275\", \"rose\"], [\"ffd1df\", \"light pink\"], [\"ceb301\", \"mustard\"], [\"380282\", \"indigo\"], [\"aaff32\", \"lime\"], [\"53fca1\", \"sea green\"], [\"8e82fe\", \"periwinkle\"], [\"cb416b\", \"dark pink\"], [\"677a04\", \"olive green\"], [\"ffb07c\", \"peach\"], [\"c7fdb5\", \"pale green\"], [\"ad8150\", \"light brown\"], [\"ff028d\", \"hot pink\"], [\"000000\", \"black\"], [\"cea2fd\", \"lilac\"], [\"001146\", \"navy blue\"], [\"0504aa\", \"royal blue\"], [\"e6daa6\", \"beige\"], [\"ff796c\", \"salmon\"], [\"6e750e\", \"olive\"], [\"650021\", \"maroon\"], [\"01ff07\", \"bright green\"], [\"35063e\", \"dark purple\"], [\"ae7181\", \"mauve\"], [\"06470c\", \"forest green\"], [\"13eac9\", \"aqua\"], [\"00ffff\", \"cyan\"], [\"d1b26f\", \"tan\"], [\"00035b\", \"dark blue\"], [\"c79fef\", \"lavender\"], [\"06c2ac\", \"turquoise\"], [\"033500\", \"dark green\"], [\"9a0eea\", \"violet\"], [\"bf77f6\", \"light purple\"], [\"89fe05\", \"lime green\"], [\"929591\", \"grey\"], [\"75bbfd\", \"sky blue\"], [\"ffff14\", \"yellow\"], [\"c20078\", \"magenta\"], [\"96f97b\", \"light green\"], [\"f97306\", \"orange\"], [\"029386\", \"teal\"], [\"95d0fc\", \"light blue\"], [\"e50000\", \"red\"], [\"653700\", \"brown\"], [\"ff81c0\", \"pink\"], [\"0343df\", \"blue\"], [\"15b01a\", \"green\"], [\"7e1e9c\", \"purple\"], [\"FF5E99\", \"paul irish pink\"], [\"87b84a\", \"peridot\"], [\"00000000\", \"transparent\"]];\n  lookup = {};\n  normalizeKey = function(key) {\n    return key.toString().toLowerCase().split(' ').join('');\n  };\n  names.each(function(element) {\n    return lookup[normalizeKey(element[1])] = element[0].parseHex();\n  });\n  return Color.lookup = function(color) {\n    return lookup[normalizeKey(color)];\n  };\n})();\n\n/**\nThe Controllable module adds simple movement\nwhen up, down, left, or right are held.\n\n      # create a player and include Controllable\n      player = GameObject\n        width: 5\n        height: 17\n        x: 15\n        y: 30\n        speed:  2\n\n      player.include Controllable\n\n      # hold the left arrow key, then\n      # update the player\n      player.update()\n\n      # the player is moved left according to his speed\n      player.I.x\n      # => 13\n\n      # We keep track of the direction the object is\n      # facing in case you need that (eg. for attack direction)\n      player.I.facing\n      # => player.I.facing\n      # => Point(-1, 0)\n\n@name Controllable\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Controllable = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    facing: Point(1, 0),\n    speed: 1,\n    velocity: Point(0, 0)\n  });\n  self.bind(\"update\", function() {\n    return self.movement();\n  });\n  return {\n    movement: function() {\n      I.velocity.x = 0;\n      I.velocity.y = 0;\n      if (keydown.left) {\n        I.velocity.x = -1;\n      }\n      if (keydown.right) {\n        I.velocity.x = 1;\n      }\n      if (keydown.up) {\n        I.velocity.y = -1;\n      }\n      if (keydown.down) {\n        I.velocity.y = 1;\n      }\n      I.velocity = I.velocity.norm();\n      if (!I.velocity.equal(Point.ZERO)) {\n        I.facing = I.velocity;\n      }\n      return I.velocity = I.velocity.scale(I.speed);\n    }\n  };\n};\n\n/**\nThe Cooldown module provides a declarative way to manage cooldowns on\nGameObject's properties.\n\n    # Health regeneration\n    player = GameObject\n      health: 50\n\n    # health will approach\n    # 100 by 1 every second\n    player.cooldown \"health\",\n      target: 100\n\n    elapsedTime = 1\n    player.update(elapsedTime)\n\n    player.I.health\n    # => 51\n\n    # Shoot Timeout\n    player = GameObject()\n\n    # by default the cooldown\n    # approaches 0 by 1 each second\n    player.cooldown \"shootTimer\"\n\n    player.I.shootTimer = 10 # => Pew! Pew!\n\n    player.update(elapsedTime)\n\n    player.I.shootTimer # => 9\n\n    # Turbo Cooldown\n    player = GameObject()\n\n    # turboTimer starts at 1000\n    # and approaches 12 by 5 each second\n    player.cooldown \"turboTimer\",\n      approachBy: 5\n      value: 1000\n      target: 12\n\n    player.I.turboTimer = 1000\n\n    player.update(elapsedTime)\n\n    player.I.turboTimer # => 995\n\n@name Cooldown\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Cooldown = function(I, self) {\n  Object.reverseMerge(I, {\n    cooldowns: {}\n  });\n  self.bind(\"update\", function(dt) {\n    var approachBy, cooldownOptions, name, target, _ref, _results;\n    _ref = I.cooldowns;\n    _results = [];\n    for (name in _ref) {\n      cooldownOptions = _ref[name];\n      approachBy = cooldownOptions.approachBy, target = cooldownOptions.target;\n      _results.push(I[name] = I[name].approach(target, approachBy * dt));\n    }\n    return _results;\n  });\n  return {\n    cooldown: function(name, options) {\n      var approachBy, target, value;\n      if (options == null) {\n        options = {};\n      }\n      target = options.target, approachBy = options.approachBy, value = options.value;\n      target || (target = 0);\n      if (approachBy == null) {\n        approachBy = 1;\n      }\n      I.cooldowns[name] = {\n        target: target,\n        approachBy: approachBy\n      };\n      if (value != null) {\n        return I[name] = options.value;\n      } else {\n        if (!I[name]) {\n          return I[name] = 0;\n        }\n      }\n    }\n  };\n};\n\n/**\nThe Debuggable Module provides a simple API to easily display\nan object's properties onscreen. This mixin comes with predefined\nattribute filters so that you can exclude irrelevant data.\n\n    player = GameObject\n      x: 40\n      y: 14\n      spriteName: null\n      numericErrorProperty: NaN\n\n    player.include Debuggable\n\n    # sets up debug output for all player's properties\n    # at the starting position (0, 0)\n    player.debug\n      filter: 'all'\n\n@name Debuggable\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Debuggable = function(I, self) {\n  var COL_HEIGHT, FONT_SIZE, ROW_HEIGHT, debugBounds, debugVelocity, debugX, debugY, drawDebugLine, filterProperties, getPropertyRow, initialI, nan, processValue, sortedKeys;\n  if (I == null) {\n    I = {};\n  }\n  COL_HEIGHT = 175;\n  ROW_HEIGHT = 9;\n  FONT_SIZE = 9;\n  debugX = 0;\n  debugY = 0;\n  Object.reverseMerge(I, {\n    debug: {\n      enabled: false,\n      color: 'black',\n      filter: 'all',\n      bounds: true,\n      velocity: true,\n      position: {\n        x: 0,\n        y: 0\n      }\n    }\n  });\n  initialI = Object.extend({}, I);\n  debugBounds = function(canvas) {\n    return canvas.drawRect({\n      color: 'rgba(255, 0, 255, 0.4)',\n      bounds: self.bounds()\n    });\n  };\n  debugVelocity = function(canvas) {\n    if (I.velocity != null) {\n      return canvas.withTransform(Matrix.translation(I.x, I.y), function(canvas) {\n        var color, thickness;\n        thickness = 4;\n        color = 'rgba(255, 0, 0, 0.5)';\n        canvas.drawRect({\n          x: 0,\n          y: -thickness / 2,\n          width: I.velocity.x,\n          height: thickness,\n          color: color\n        });\n        return canvas.drawRect({\n          x: -thickness / 2,\n          y: 0,\n          width: thickness,\n          height: I.velocity.y,\n          color: color\n        });\n      });\n    }\n  };\n  filterProperties = function(properties) {\n    var key, results, value;\n    results = {};\n    switch (I.debug.filter) {\n      case 'all':\n        results = properties;\n        break;\n      case 'undefined':\n        for (key in properties) {\n          value = properties[key];\n          if ((value == null) || nan(value)) {\n            results[key] = value;\n          }\n        }\n        break;\n      case 'changed':\n        for (key in properties) {\n          value = properties[key];\n          if (initialI[key] !== value) {\n            results[key] = value;\n          }\n        }\n    }\n    return results;\n  };\n  sortedKeys = function() {\n    var key, keys, value, _ref;\n    keys = [];\n    _ref = filterProperties(I);\n    for (key in _ref) {\n      value = _ref[key];\n      keys.push(key);\n    }\n    return keys.sort();\n  };\n  nan = function(value) {\n    return typeof value === 'number' && isNaN(value);\n  };\n  drawDebugLine = function(text, canvas, x, y) {\n    canvas.drawText({\n      color: I.debug.color,\n      x: x + I.debug.position.x,\n      y: y + I.debug.position.y,\n      text: text\n    });\n    return debugY += ROW_HEIGHT;\n  };\n  getPropertyRow = function(key, value, canvas) {\n    var k, toStringArray, v;\n    if (typeof value === 'function') {\n\n    } else if (Object.isObject(value)) {\n      drawDebugLine(key, canvas, debugX, debugY);\n      debugX += 8;\n      for (k in value) {\n        v = value[k];\n        getPropertyRow(k, v, canvas);\n      }\n      return debugX -= 8;\n    } else if (Object.isArray(value)) {\n      toStringArray = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = value.length; _i < _len; _i++) {\n          v = value[_i];\n          if (Object.isObject(v)) {\n            _results.push(v.I[\"class\"] || v.toString());\n          } else {\n            _results.push(v);\n          }\n        }\n        return _results;\n      })();\n      return drawDebugLine(\"\" + key + \"(\" + value.length + \"): \" + toStringArray, canvas, debugX, debugY);\n    } else {\n      value = processValue(value);\n      return drawDebugLine(\"\" + key + \": \" + value, canvas, debugX, debugY);\n    }\n  };\n  processValue = function(value) {\n    var output, parsedNumber;\n    output = value;\n    try {\n      parsedNumber = parseFloat(value);\n    } catch (_error) {}\n    if (parsedNumber) {\n      if (typeof value !== 'string' && parsedNumber !== parseInt(value)) {\n        output = value.toFixed(3);\n      }\n    }\n    return output;\n  };\n  self.bind(\"update\", function() {\n    if (justPressed['0']) {\n      return self.toggleDebug();\n    }\n  });\n  self.bind(\"overlay\", function(canvas) {\n    var key, _i, _len, _ref;\n    if (I.debug.enabled) {\n      canvas.font(\"\" + FONT_SIZE + \"px Monaco\");\n      debugX = 0;\n      debugY = ROW_HEIGHT;\n      _ref = sortedKeys();\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        key = _ref[_i];\n        getPropertyRow(key, I[key], canvas);\n      }\n      debugX += COL_HEIGHT;\n      debugY = ROW_HEIGHT;\n      if (I.debug.bounds) {\n        debugBounds(canvas);\n      }\n      if (I.debug.velocity) {\n        return debugVelocity(canvas);\n      }\n    }\n  });\n  return {\n    /**\n    Enable debugging display for the calling GameObject.\n    \n        player = GameObject\n          x: 40\n          y: 14\n          spriteName: null\n          numericErrorProperty: NaN\n    \n        player.include Debuggable\n    \n        # sets up debug output for all player's properties\n        # at the starting position (0, 0)\n        player.debug\n          filter: 'all'\n    \n        player.I.y = 45\n    \n        # sets up debug output for only properties that have\n        # changed since initialization. In this case only y\n        # would be displayed.\n        player.debug\n          filter: 'changed'\n    \n        # sets up debug output for properties that are <code>undefined</code>,\n        # <code>null</code>, or <code>NaN</code>. In this case spriteName and\n        # numericErrorProperty would be displayed.\n        player.debug\n          filter: 'undefined'\n    \n        # sets up debug output using all possible configuration options\n        player.debug\n          bounds: true # set this to false to disable visual debugging of the object's bounding box\n          color: 'red' # color of debug text\n          filter: 'all'\n          x: 30 # x position to start printing debug information\n          y: 50 # y position to start printing debug information\n          velocity: true # set this to false to disable visual debugging of the object's velocity\n    \n    @name debug\n    @methodOf Debuggable#\n    @param {Object} Options to configure debug output\n    @param {Boolean} bounds Whether or not to visually debug the object's bounds\n    @param {Color|String} color The color of the debug text\n    @param {String} filter Choices include 'all', 'changed', and 'undefined'\n    @param {Number} x The x position to start drawing the debug information\n    @param {Number} y The y position to start drawing the debug information\n    @param {Boolean} velocity Whether or not to visually debug the object's velocity\n    */\n\n    debug: function(options) {\n      var x, y;\n      if (options == null) {\n        options = {};\n      }\n      x = options.x, y = options.y;\n      if (x != null) {\n        I.debug.position.x = x;\n      }\n      if (y != null) {\n        I.debug.position.y = y;\n      }\n      Object.extend(I.debug, options);\n      return I.debug.enabled = true;\n    },\n    /**\n    Toggle display of debug information.\n    \n        player = GameObject()\n    \n        player.include Debuggable\n    \n        # enables debug display\n        player.debug()\n    \n        # disables debug display\n        player.toggleDisable()\n    \n        # if false is passed to toggleDisplay, then debugging is disabled.\n        player.toggleDisplay(false)\n    \n        # if true is passed to toggleDisplay, then debugging is enabled.\n        player.toggleDisplay(true)\n    \n    @name toggleDebug\n    @methodOf Debuggable#\n    @param {Boolean} newVal If true is passed then debugging is enabled, if false is passed then debugging is disabled, if nothing is passed, then debug state is toggled.\n    */\n\n    toggleDebug: function(newVal) {\n      if (newVal != null) {\n        return I.debug.enabled = newVal;\n      } else {\n        return I.debug.enabled = !I.debug.enabled;\n      }\n    }\n  };\n};\n\n/**\nThe Drawable module is used to provide a simple draw method to the including\nobject.\n\nBinds a default draw listener to draw a rectangle or a sprite, if one exists.\n\nBinds a step listener to update the transform of the object.\n\nAutoloads the sprite specified in I.sprite, if any.\n\n    player = Core\n      x: 15\n      y: 30\n      width: 5\n      height: 5\n      sprite: \"my_cool_sprite\"\n\n    engine.bind 'draw', (canvas) ->\n      player.draw(canvas)\n    # => Uncaught TypeError: Object has no method 'draw'\n\n    player.include(Drawable)\n\n    engine.bind 'draw', (canvas) ->\n      player.draw(canvas)\n    # => if you have a sprite named \"my_cool_sprite\" in your images folder\n    # then it will be drawn. Otherwise, a rectangle positioned at x: 15 and\n    # y: 30 with width and height 5 will be drawn.\n\n@name Drawable\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\n/**\nTriggered every time the object should be drawn. A canvas is passed as\nthe first argument.\n\n    player = Core\n      x: 0\n      y: 10\n      width: 5\n      height: 5\n\n    player.bind \"draw\", (canvas) ->\n      # Text will be drawn positioned relatively to the object.\n      canvas.drawText\n        text: \"Hey, drawing stuff is pretty easy.\"\n        color: \"white\"\n        x: 5\n        y: 5\n\n@name draw\n@methodOf Drawable#\n@event\n@param {PowerCanvas} canvas A reference to the canvas to draw on.\n*/\n\n\n/**\nTriggered before the object should be drawn. A canvas is passed as\nthe first argument. This does not apply the current transform.\n\n@name beforeTransform\n@methodOf Drawable#\n@event\n@param {PowerCanvas} canvas A reference to the canvas to draw on.\n*/\n\n\n/**\nTriggered after the object should be drawn. A canvas is passed as\nthe first argument. This applies the current transform.\n\n@name afterTransform\n@methodOf Drawable#\n@event\n@param {PowerCanvas} canvas A reference to the canvas to draw on.\n*/\n\n\nthis.Drawable = function(I, self) {\n  var cachedSprite;\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    alpha: 1,\n    color: \"#196\",\n    scale: 1,\n    scaleX: 1,\n    scaleY: 1,\n    zIndex: 0\n  });\n  cachedSprite = null;\n  self.unbind(\".Drawable\");\n  self.bind('draw.Drawable', function(canvas) {\n    var previousAlpha, sprite;\n    if ((I.alpha != null) && I.alpha !== 1) {\n      previousAlpha = canvas.context().globalAlpha;\n      canvas.context().globalAlpha = I.alpha;\n    }\n    if (sprite = self.sprite()) {\n      if (sprite.draw != null) {\n        sprite.draw(canvas, -sprite.width / 2, -sprite.height / 2);\n      } else {\n        if (typeof warn === \"function\") {\n          warn(\"Sprite has no draw method!\");\n        }\n      }\n    } else {\n      if (I.radius != null) {\n        canvas.drawCircle({\n          x: 0,\n          y: 0,\n          radius: I.radius,\n          color: I.color\n        });\n      } else {\n        canvas.drawRect({\n          x: -I.width / 2,\n          y: -I.height / 2,\n          width: I.width,\n          height: I.height,\n          color: I.color\n        });\n      }\n    }\n    if ((I.alpha != null) && I.alpha !== 1) {\n      return canvas.context().globalAlpha = previousAlpha;\n    }\n  });\n  return {\n    /**\n    Draw does not actually do any drawing itself, instead it triggers all of the draw events.\n    Listeners on the events do the actual drawing.\n    \n    @name draw\n    @methodOf Drawable#\n    @returns self\n    */\n\n    draw: function(canvas) {\n      self.trigger('beforeTransform', canvas);\n      canvas.withTransform(self.transform(), function(canvas) {\n        self.trigger('beforeDraw', canvas);\n        self.trigger('draw', canvas);\n        return self.trigger('afterDraw', canvas);\n      });\n      self.trigger('afterTransform', canvas);\n      return self;\n    },\n    sprite: function(newSprite) {\n      if (newSprite != null) {\n        return cachedSprite = newSprite;\n      } else {\n        if (I.sprite) {\n          return Sprite.loadByName(I.sprite);\n        }\n      }\n    },\n    /**\n    Returns the current transform, with translation, rotation, and flipping applied.\n    \n    @name transform\n    @methodOf Drawable#\n    @returns {Matrix} The current transform\n    */\n\n    transform: function() {\n      var center, transform;\n      center = self.center();\n      transform = Matrix.translation(center.x.floor(), center.y.floor());\n      transform = transform.concat(Matrix.scale(I.scale * I.scaleX, I.scale * I.scaleY));\n      if (I.rotation) {\n        transform = transform.concat(Matrix.rotation(I.rotation));\n      }\n      if (I.spriteOffset) {\n        transform = transform.concat(Matrix.translation(I.spriteOffset.x, I.spriteOffset.y));\n      }\n      return transform;\n    }\n  };\n};\n\nthis.DustParticle = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.extend(I, {\n    color: 'rgb(100, 100, 100)',\n    duration: 0.2,\n    fadeOut: true,\n    maxSpeed: 90\n  });\n  I.velocity = [Point(-60, -30), Point(40, -15), Point(-20, -7), Point(60, -30), Point(40, -15), Point(20, -7)].rand();\n  I.acceleration = Point(0, 60);\n  return {};\n};\n\nthis.DustEmitter = function(I) {\n  var self;\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    duration: 3,\n    particleCount: 20,\n    batchSize: 5,\n    x: 0,\n    y: 0,\n    zIndex: 50,\n    generator: {\n      includedModules: [\"DustParticle\"],\n      radius: function(n) {\n        return [2, 3, 1].wrap(n);\n      }\n    }\n  });\n  self = Emitter(I);\n  return self;\n};\n\n(function() {\n  var Easing, polynomialEasings;\n  Easing = {\n    sinusoidal: function(begin, end) {\n      var change;\n      change = end - begin;\n      return function(t) {\n        return begin + change * (1 - Math.cos(t * Math.TAU / 4));\n      };\n    },\n    sinusoidalOut: function(begin, end) {\n      var change;\n      change = end - begin;\n      return function(t) {\n        return begin + change * (0 + Math.sin(t * Math.TAU / 4));\n      };\n    }\n  };\n  polynomialEasings = [\"linear\", \"quadratic\", \"cubic\", \"quartic\", \"quintic\"];\n  polynomialEasings.each(function(easing, i) {\n    var exponent, sign;\n    exponent = i + 1;\n    sign = exponent % 2 ? 1 : -1;\n    Easing[easing] = function(begin, end) {\n      var change;\n      change = end - begin;\n      return function(t) {\n        return begin + change * Math.pow(t, exponent);\n      };\n    };\n    return Easing[\"\" + easing + \"Out\"] = function(begin, end) {\n      var change;\n      change = end - begin;\n      return function(t) {\n        return begin + change * (1 + sign * Math.pow(t - 1, exponent));\n      };\n    };\n  });\n  [\"sinusoidal\"].concat(polynomialEasings).each(function(easing) {\n    return Easing[\"\" + easing + \"InOut\"] = function(begin, end) {\n      var easeIn, easeOut, midpoint;\n      midpoint = (begin + end) / 2;\n      easeIn = Easing[easing](begin, midpoint);\n      easeOut = Easing[\"\" + easing + \"Out\"](midpoint, end);\n      return function(t) {\n        if (t < 0.5) {\n          return easeIn(2 * t);\n        } else {\n          return easeOut(2 * t - 1);\n        }\n      };\n    };\n  });\n  return (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"Easing\"] = Easing;\n})();\n\nthis.Emitterable = function(I, self) {\n  var n;\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    batchSize: 1,\n    emissionRate: 1,\n    width: 0,\n    height: 0,\n    sprite: Sprite.EMPTY,\n    generator: {},\n    particles: [],\n    particleCount: Infinity,\n    x: I.x,\n    y: I.y,\n    particleData: {\n      acceleration: Point(0, 0.1),\n      age: 0,\n      color: \"blue\",\n      duration: 1.5,\n      height: 2,\n      maxSpeed: 120,\n      offset: Point(0, 0),\n      sprite: false,\n      spriteName: false,\n      velocity: Point(-0.25, 1),\n      width: 2,\n      x: 0,\n      y: 0\n    }\n  });\n  n = 0;\n  self.bind('draw', function(canvas) {\n    return I.particles.invoke(\"draw\", canvas);\n  });\n  self.bind('overlay', function(canvas) {\n    return I.particles.invoke(\"trigger\", \"overlay\", canvas);\n  });\n  self.bind('beforeUpdate', function(dt) {\n    return I.particles.invoke(\"trigger\", \"beforeUpdate\", dt);\n  });\n  self.bind('afterUpdate', function(dt) {\n    return I.particles.invoke(\"trigger\", \"afterUpdate\", dt);\n  });\n  self.bind('update', function(dt) {\n    I.batchSize.times(function() {\n      var key, particleProperties, value, _ref;\n      if (n < I.particleCount && rand() < I.emissionRate) {\n        particleProperties = Object.extend({}, I.particleData);\n        _ref = I.generator;\n        for (key in _ref) {\n          value = _ref[key];\n          if (I.generator[key].call) {\n            particleProperties[key] = I.generator[key](n, I);\n          } else {\n            particleProperties[key] = I.generator[key];\n          }\n        }\n        particleProperties.x += particleProperties.offset.x;\n        particleProperties.y += particleProperties.offset.y;\n        I.particles.push(GameObject(particleProperties));\n        return n += 1;\n      }\n    });\n    I.particles = I.particles.select(function(particle) {\n      return particle.update(dt);\n    });\n    if (n === I.particleCount && !I.particles.length) {\n      return I.active = false;\n    }\n  });\n  return {};\n};\n\nthis.Emitter = function(I) {\n  var self;\n  if (I == null) {\n    I = {};\n  }\n  self = GameObject(I);\n  self.include(\"Emitterable\");\n  return self;\n};\n\n(function() {\n  /**\n  The Engine controls the game world and manages game state. Once you\n  set it up and let it run it pretty much takes care of itself.\n  \n  You can use the engine to add or remove objects from the game world.\n  \n  There are several modules that can include to add additional capabilities\n  to the engine.\n  \n  The engine fires events that you  may bind listeners to. Event listeners\n  may be bound with <code>engine.bind(eventName, callback)</code>\n  \n  @name Engine\n  @constructor\n  @param {Object} I Instance variables of the engine\n  */\n\n  /**\n  Observe or modify the\n  entity data before it is added to the engine.\n  @name beforeAdd\n  @methodOf Engine#\n  @event\n  @param {Object} entityData\n  */\n\n  /**\n  Observe or configure a <code>gameObject</code> that has been added\n  to the engine.\n  @name afterAdd\n  @methodOf Engine#\n  @event\n  @param {GameObject} object The object that has just been added to the\n  engine.\n  */\n\n  /**\n  Called when the engine updates all the game objects.\n  \n  @name update\n  @methodOf Engine#\n  @event\n  @param {Number} elapsedTime The time in seconds that has elapsed since the last update.\n  */\n\n  /**\n  Called after the engine completes an update. Here it is\n  safe to modify the game objects array.\n  \n  @name afterUpdate\n  @methodOf Engine#\n  @event\n  */\n\n  /**\n  Called before the engine draws the game objects on the canvas. The current camera transform is applied.\n  \n  @name beforeDraw\n  @methodOf Engine#\n  @event\n  @params {PixieCanvas} canvas A reference to the canvas to draw on.\n  */\n\n  /**\n  Called after the engine draws on the canvas. The current camera transform is applied.\n  \n      engine.bind \"draw\", (canvas) ->\n        # print some directions for the player\n        canvas.drawText\n          text: \"Go this way =>\"\n          x: 200\n          y: 200\n  \n  @name draw\n  @methodOf Engine#\n  @event\n  @params {PixieCanvas} canvas A reference to the canvas to draw on.\n  */\n\n  /**\n  Called after the engine draws.\n  \n  The current camera transform is not applied. This is great for\n  adding overlays.\n  \n      engine.bind \"overlay\", (canvas) ->\n        # print the player's health. This will be\n        # positioned absolutely according to the viewport.\n        canvas.drawText\n          text: \"HEALTH:\"\n          position: Point(20, 20)\n  \n        canvas.drawText\n          text: player.health()\n          position: Point(50, 20)\n  \n  @name overlay\n  @methodOf Engine#\n  @event\n  @params {PixieCanvas} canvas A reference to the canvas to draw on.\n  */\n\n  var Engine;\n  Engine = function(I) {\n    var animLoop, draw, frameAdvance, lastStepTime, running, self, startTime, step, update;\n    if (I == null) {\n      I = {};\n    }\n    Object.reverseMerge(I, {\n      FPS: 60,\n      paused: false\n    });\n    frameAdvance = false;\n    running = false;\n    startTime = +new Date();\n    lastStepTime = -Infinity;\n    animLoop = function(timestamp) {\n      var delta, msPerFrame, remainder;\n      timestamp || (timestamp = +new Date());\n      msPerFrame = 1000 / I.FPS;\n      delta = timestamp - lastStepTime;\n      remainder = delta - msPerFrame;\n      if (remainder > 0) {\n        lastStepTime = timestamp - Math.min(remainder, msPerFrame);\n        step();\n      }\n      if (running) {\n        return window.requestAnimationFrame(animLoop);\n      }\n    };\n    update = function(elapsedTime) {\n      self.trigger(\"beforeUpdate\", elapsedTime);\n      self.trigger(\"update\", elapsedTime);\n      return self.trigger(\"afterUpdate\", elapsedTime);\n    };\n    draw = function() {\n      var canvas;\n      if (!(canvas = I.canvas)) {\n        return;\n      }\n      self.trigger(\"beforeDraw\", canvas);\n      self.trigger(\"draw\", canvas);\n      return self.trigger(\"overlay\", canvas);\n    };\n    step = function() {\n      var elapsedTime;\n      if (!I.paused || frameAdvance) {\n        elapsedTime = 1 / I.FPS;\n        update(elapsedTime);\n      }\n      return draw();\n    };\n    self = Core(I).extend({\n      /**\n      Start the game simulation.\n      \n          engine.start()\n      \n      @methodOf Engine#\n      @name start\n      */\n\n      start: function() {\n        if (!running) {\n          running = true;\n          return window.requestAnimationFrame(animLoop);\n        }\n      },\n      /**\n      Stop the simulation.\n      \n          engine.stop()\n      \n      @methodOf Engine#\n      @name stop\n      */\n\n      stop: function() {\n        return running = false;\n      },\n      /**\n      Pause the game and step through 1 update of the engine.\n      \n          engine.frameAdvance()\n      \n      @methodOf Engine#\n      @name frameAdvance\n      */\n\n      frameAdvance: function() {\n        I.paused = true;\n        frameAdvance = true;\n        step();\n        return frameAdvance = false;\n      },\n      /**\n      Resume the game.\n      \n          engine.play()\n      \n      @methodOf Engine#\n      @name play\n      */\n\n      play: function() {\n        return I.paused = false;\n      },\n      /**\n      Toggle the paused state of the simulation.\n      \n          engine.pause()\n      \n      @methodOf Engine#\n      @name pause\n      @param {Boolean} [setTo] Force to pause by passing true or unpause by passing false.\n      */\n\n      pause: function(setTo) {\n        if (setTo != null) {\n          return I.paused = setTo;\n        } else {\n          return I.paused = !I.paused;\n        }\n      },\n      /**\n      Query the engine to see if it is paused.\n      \n          engine.pause()\n      \n          engine.paused()\n          # true\n      \n          engine.play()\n      \n          engine.paused()\n          # false\n      \n      @methodOf Engine#\n      @name paused\n      */\n\n      paused: function() {\n        return I.paused;\n      },\n      /**\n      Change the framerate of the game. The default framerate is 30 fps.\n      \n          engine.setFramerate(60)\n      \n      @methodOf Engine#\n      @name setFramerate\n      */\n\n      setFramerate: function(newFPS) {\n        I.FPS = newFPS;\n        self.stop();\n        return self.start();\n      },\n      update: update,\n      draw: draw\n    });\n    self.include(Ageable);\n    Engine.defaultModules.each(function(moduleName) {\n      var fullModuleName;\n      fullModuleName = \"Engine.\" + moduleName;\n      if (!Engine[moduleName]) {\n        throw \"#\" + fullModuleName + \" is not a valid engine module\";\n      }\n      return self.include(fullModuleName);\n    });\n    self.trigger(\"init\");\n    return self;\n  };\n  Engine.defaultModules = [\"Data\", \"Keyboard\", \"Mouse\", \"Background\", \"Delay\", \"GameState\", \"Selector\", \"Collision\", \"Tilemap\", \"Levels\"];\n  return (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"Engine\"] = Engine;\n})();\n\n/**\nThe <code>Collision</code> module provides some simple collision detection methods to engine.\n\n@name Collision\n@fieldOf Engine\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.Collision = function(I, self) {\n  return {\n    /**\n    Detects collisions between a bounds and the game objects.\n    \n    @name collides\n    @methodOf Engine#\n    @param bounds The bounds to check collisions with.\n    @param [sourceObject] An object to exclude from the results.\n    @returns {Boolean} true if the bounds object collides with any of the game objects, false otherwise.\n    */\n\n    collides: function(bounds, sourceObject, selector) {\n      if (selector == null) {\n        selector = \".solid\";\n      }\n      return self.find(selector).inject(false, function(collided, object) {\n        return collided || (object !== sourceObject) && object.collides(bounds) && object;\n      });\n    },\n    /**\n    Detects collisions between a bounds and the game objects.\n    Returns an array of objects colliding with the bounds provided.\n    \n    @name collidesWith\n    @methodOf Engine#\n    @param bounds The bounds to check collisions with.\n    @param [sourceObject] An object to exclude from the results.\n    @returns {Array} An array of objects that collide with the given bounds.\n    */\n\n    collidesWith: function(bounds, sourceObject, selector) {\n      if (selector == null) {\n        selector = \".solid\";\n      }\n      return self.find(selector).select(function(object) {\n        return object !== sourceObject && object.collides(bounds);\n      });\n    },\n    /**\n    Detects collisions between a ray and the game objects.\n    \n    @name rayCollides\n    @methodOf Engine#\n    @param source The origin point\n    @param direction A point representing the direction of the ray\n    @param [sourceObject] An object to exclude from the results.\n    @param [selector] A selector to choos which objects in the engine to collide with\n    */\n\n    rayCollides: function(_arg) {\n      var direction, hits, nearestDistance, nearestHit, selector, source, sourceObject;\n      source = _arg.source, direction = _arg.direction, sourceObject = _arg.sourceObject, selector = _arg.selector;\n      if (selector == null) {\n        selector = \"\";\n      }\n      hits = self.find(selector).map(function(object) {\n        var hit;\n        hit = (object !== sourceObject) && Collision.rayRectangle(source, direction, object.centeredBounds());\n        if (hit) {\n          hit.object = object;\n        }\n        return hit;\n      });\n      nearestDistance = Infinity;\n      nearestHit = null;\n      hits.each(function(hit) {\n        var d;\n        if (hit && (d = hit.distance(source)) < nearestDistance) {\n          nearestDistance = d;\n          return nearestHit = hit;\n        }\n      });\n      return nearestHit;\n    },\n    objectsUnderPoint: function(point, selector) {\n      var bounds;\n      if (selector == null) {\n        selector = \"\";\n      }\n      bounds = {\n        x: point.x,\n        y: point.y,\n        width: 0,\n        height: 0\n      };\n      return self.find(selector).select(function(object) {\n        return object.collides(bounds);\n      });\n    }\n  };\n};\n\n/**\nThe <code>Data</code> module provides methods to store global and persistent data in the engine.\n\n    engine.data.score = 0\n    engine.data.score += 10\n    \n    engine.data.score # => 10\n\n@name Data\n@fieldOf Engine\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.Data = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    data: {}\n  });\n  Object.defineProperty(self, 'data', {\n    get: function() {\n      return I.data;\n    }\n  });\n  return {};\n};\n\n/**\nThe <code>Delay</code> module provides methods to trigger events after a number of steps have passed.\n\n@name Delay\n@fieldOf Engine\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.Delay = function(I, self) {\n  var delayedEvents;\n  delayedEvents = [];\n  self.bind('afterUpdate', function(elapsedTime) {\n    var firingEvents, _ref;\n    _ref = delayedEvents.partition(function(event) {\n      return (event.delay -= elapsedTime) >= 0;\n    }), delayedEvents = _ref[0], firingEvents = _ref[1];\n    firingEvents.each(function(event) {\n      return event.callback();\n    });\n  });\n  return {\n    /**\n    Execute a callback after a number of seconds have passed.\n    \n        engine.delay 5, ->\n          engine.add\n            class: \"Ghost\"\n    \n    @name delay\n    @methodOf Engine#\n    @param {Number} seconds The number of steps to wait before executing the callback\n    @param {Function} callback The callback to be executed.\n    \n    @returns {Engine} self\n    */\n\n    delay: function(seconds, callback) {\n      delayedEvents.push({\n        delay: seconds,\n        callback: callback\n      });\n      return self;\n    }\n  };\n};\n\n/**\nThe <code>FPSCounter</code> module tracks and displays the framerate.\n\n    window.engine = Engine\n      ...\n      includedModules: [\"FPSCounter\"]\n      FPSColor: \"#080\"\n\n@name FPSCounter\n@fieldOf Engine\n@module\n\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.FPSCounter = function(I, self) {\n  var framerate;\n  Object.reverseMerge(I, {\n    showFPS: true,\n    FPSColor: \"#FFF\"\n  });\n  framerate = Framerate();\n  return self.bind(\"overlay\", function(canvas) {\n    if (I.showFPS) {\n      canvas.font(\"bold 9pt consolas, 'Courier New', 'andale mono', 'lucida console', monospace\");\n      canvas.drawText({\n        color: I.FPSColor,\n        position: Point(6, 18),\n        text: \"fps: \" + framerate.fps\n      });\n    }\n    return framerate.rendered();\n  });\n};\n\nEngine.GameState = function(I, self) {\n  var requestedState;\n  Object.reverseMerge(I, {\n    currentState: GameState()\n  });\n  requestedState = null;\n  self.bind(\"update\", function(elapsedTime) {\n    I.currentState.trigger(\"beforeUpdate\", elapsedTime);\n    I.currentState.trigger(\"update\", elapsedTime);\n    return I.currentState.trigger(\"afterUpdate\", elapsedTime);\n  });\n  self.bind(\"afterUpdate\", function() {\n    var previousState;\n    if (requestedState != null) {\n      I.currentState.trigger(\"exit\", requestedState);\n      self.trigger('stateExited', I.currentState);\n      previousState = I.currentState;\n      I.currentState = requestedState;\n      I.currentState.trigger(\"enter\", previousState);\n      self.trigger('stateEntered', I.currentState);\n      return requestedState = null;\n    }\n  });\n  self.bind(\"draw\", function(canvas) {\n    I.currentState.trigger(\"beforeDraw\", canvas);\n    I.currentState.trigger(\"draw\", canvas);\n    return I.currentState.trigger(\"overlay\", canvas);\n  });\n  return {\n    add: function(classNameOrEntityData, entityData) {\n      var object;\n      if (entityData == null) {\n        entityData = {};\n      }\n      if (typeof classNameOrEntityData.isString === \"function\" ? classNameOrEntityData.isString() : void 0) {\n        entityData[\"class\"] = classNameOrEntityData;\n      } else {\n        entityData = classNameOrEntityData;\n      }\n      self.trigger(\"beforeAdd\", entityData);\n      object = I.currentState.add(entityData);\n      self.trigger(\"afterAdd\", object);\n      return object;\n    },\n    camera: function(n) {\n      if (n == null) {\n        n = 0;\n      }\n      return self.cameras()[n];\n    },\n    cameras: function(newCameras) {\n      if (newCameras != null) {\n        I.currentState.cameras(newCameras);\n        return self;\n      } else {\n        return I.currentState.cameras();\n      }\n    },\n    fadeIn: function(options) {\n      if (options == null) {\n        options = {};\n      }\n      return self.cameras().invoke('fadeIn', options);\n    },\n    fadeOut: function(options) {\n      if (options == null) {\n        options = {};\n      }\n      return self.cameras().invoke('fadeOut', options);\n    },\n    flash: function(options) {\n      if (options == null) {\n        options = {};\n      }\n      return self.camera(options.camera).flash(options);\n    },\n    objects: function() {\n      return I.currentState.objects();\n    },\n    setState: function(newState) {\n      return requestedState = newState;\n    },\n    shake: function(options) {\n      if (options == null) {\n        options = {};\n      }\n      return self.camera(options.camera).shake(options);\n    },\n    saveState: function() {\n      return I.currentState.saveState();\n    },\n    loadState: function(newState) {\n      return I.currentState.loadState(newState);\n    },\n    reload: function() {\n      return I.currentState.reload();\n    }\n  };\n};\n\n/**\nThe <code>Joysticks</code> module gives the engine access to joysticks.\n\n    # First you need to add the joysticks module to the engine\n    window.engine = Engine\n      ...\n      includedModules: [\"Joysticks\"]\n    # Then you need to get a controller reference\n    # id = 0 for player 1, etc.\n    controller = engine.controller(id)\n    \n    # Point indicating direction primary axis is held\n    direction = controller.position()\n    \n    # Check if buttons are held\n    controller.actionDown(\"A\")\n    controller.actionDown(\"B\")\n    controller.actionDown(\"X\")\n    controller.actionDown(\"Y\")\n\n@name Joysticks\n@fieldOf Engine\n@module\n\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.Joysticks = function(I, self) {\n  Joysticks.init();\n  self.bind(\"update\", function() {\n    Joysticks.init();\n    return Joysticks.update();\n  });\n  return {\n    /**\n    Get a controller for a given joystick id.\n    \n    @name controller\n    @methodOf Engine.Joysticks#\n    \n    @param {Number} i The joystick id to get the controller of.\n    */\n\n    controller: function(i) {\n      return Joysticks.getController(i);\n    }\n  };\n};\n\n/**\nThis module sets up the keyboard inputs for each engine update.\n\n@name Keyboard\n@fieldOf Engine\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.Keyboard = function(I, self) {\n  self.bind(\"beforeUpdate\", function() {\n    return typeof updateKeys === \"function\" ? updateKeys() : void 0;\n  });\n  return {};\n};\n\n/**\nThis module provides methods for transitioning between levels.\n\n@name Levels\n@fieldOf Engine\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.Levels = function(I, self) {\n  var loadLevel;\n  Object.reverseMerge(I, {\n    levels: [],\n    currentLevel: -1,\n    currentLevelName: null\n  });\n  I.transitioning = false;\n  loadLevel = function(level) {\n    var levelState;\n    if (!I.transitioning) {\n      I.transitioning = true;\n      levelState = LevelState({\n        level: level\n      });\n      I.currentLevelName = level;\n      return engine.setState(levelState);\n    }\n  };\n  return {\n    /**\n    Load map for the next level.\n    \n        engine.nextLevel()\n    \n    @name nextLevel\n    @methodOf Engine#\n    */\n\n    nextLevel: function() {\n      var level;\n      if (!I.transitioning) {\n        I.currentLevel += 1;\n        if (level = I.levels[I.currentLevel]) {\n          return loadLevel(level);\n        } else {\n          return engine.setState(GameOver());\n        }\n      }\n    },\n    /**\n    Load map named <code>level</code>\n    \n        engine.goToLevel 'bossFight'\n    \n    @name goToLevel\n    @methodOf Engine#\n    */\n\n    goToLevel: function(level) {\n      return loadLevel(level);\n    },\n    /**\n    Reload the current level. Useful for retrying after a player dies.\n    \n        engine.reloadLevel()\n    \n    @name reloadLevel\n    @methodOf Engine#\n    */\n\n    restartLevel: function() {\n      return loadLevel(I.currentLevelName);\n    },\n    reloadLevel: function() {\n      return self.restartLevel();\n    }\n  };\n};\n\n/**\nThis module clears or fills the canvas before drawing the scene.\n\n@name Clear\n@fieldOf Engine\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.Background = function(I, self) {\n  Object.reverseMerge(I, {\n    background: null,\n    backgroundColor: \"#00010D\",\n    clear: false\n  });\n  self.attrAccessor(\"clear\", \"backgroundColor\");\n  self.bind(\"init\", function() {\n    var _ref;\n    if ((_ref = I.background) != null ? typeof _ref.isString === \"function\" ? _ref.isString() : void 0 : void 0) {\n      return I.background = Sprite.loadByName(I.background);\n    }\n  });\n  self.bind(\"beforeDraw\", function() {\n    if (I.clear) {\n      return I.canvas.clear();\n    } else if (I.background) {\n      return I.background.fill(I.canvas, 0, 0, App.width, App.height);\n    } else if (I.backgroundColor) {\n      return I.canvas.fill(I.backgroundColor);\n    }\n  });\n  return {};\n};\n\n/**\nThis module sets up the mouse inputs for each engine update.\n\n@name Mouse\n@fieldOf Engine\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.Mouse = function(I, self) {\n  self.bind(\"beforeUpdate\", function() {\n    return typeof updateMouse === \"function\" ? updateMouse() : void 0;\n  });\n  return {};\n};\n\n/**\nThe <code>Selector</code> module provides methods to query the engine to find game objects.\n\n@name Selector\n@fieldOf Engine\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.Selector = function(I, self) {\n  var instanceMethods;\n  instanceMethods = {\n    set: function(attr, value) {\n      return this.each(function(item) {\n        return item.I[attr] = value;\n      });\n    }\n  };\n  return {\n    /**\n    Get the game object matching the given selector that is closest to the given position.\n    \n        player = engine.add\n          x: 0\n          y: 0\n    \n        enemy1 = engine.add\n          enemy: true\n          x: 10\n          y: 0\n    \n        enemy2 = engine.add\n          enemy: true\n          x: 0\n          y: 15\n    \n        player2 = engine.add\n          x: 0\n          y: 10\n    \n        equals engine.closest(\".enemy\", player.position()), enemy1\n        equals engine.closest(\".enemy\", player2.position()), enemy2\n    \n    @name closest\n    @methodOf Engine.selector\n    @param {String} selector\n    @param {Point} position\n    */\n\n    closest: function(selector, position) {\n      return self.find(selector).sort(function(a, b) {\n        return Point.distanceSquared(position, a.position()) - Point.distanceSquared(position, b.position());\n      }).first();\n    },\n    /**\n    Get a selection of GameObjects that match the specified selector criteria. The selector language\n    can select objects by id, class, or attributes. Note that this method always returns an Array,\n    so if you are trying to find only one object you will need something like <code>engine.find(\"Enemy\").first()</code>.\n    \n        player = engine.add\n          class: \"Player\"\n    \n        enemy = engine.add\n          class: \"Enemy\"\n          speed: 5\n          x: 0\n    \n        distantEnemy = engine.add\n          class \"Enemy\"\n          x: 500\n    \n        boss = engine.add\n          class: \"Enemy\"\n          id: \"Boss\"\n          x: 0\n    \n        # to select an object by id use \"#anId\"\n        engine.find \"#Boss\"\n        # => [boss]\n    \n        # to select an object by class use \"MyClass\"\n        engine.find \"Enemy\"\n        # => [enemy, distantEnemy, boss]\n    \n        # to select an object by properties use \".someProperty\" or \".someProperty=someValue\"\n        engine.find \".speed=5\"\n        # => [enemy]\n    \n        # You may mix and match selectors.\n        engine.find \"Enemy.x=0\"\n        # => [enemy, boss] # doesn't return distantEnemy\n    \n    @name find\n    @methodOf Engine#\n    @param {String} selector\n    @returns {Array} An array of the objects found\n    */\n\n    each: function(selector, fn) {\n      return self.find(selector).each(function(obj, index) {\n        return fn(obj, index);\n      });\n    },\n    /**\n    Find all game objects that match the given selector.\n    \n    @name find\n    @methodOf Engine.selector\n    \n    @param {String} selector\n    */\n\n    find: function(selector) {\n      var matcher, results;\n      results = [];\n      matcher = Engine.Selector.generate(selector);\n      self.objects().each(function(object) {\n        if (matcher.match(object)) {\n          return results.push(object);\n        }\n      });\n      return Object.extend(results, instanceMethods);\n    },\n    /**\n    Find the first game object that matches the given selector.\n    \n    @name find\n    @methodOf Engine.selector\n    \n    @param {String} selector\n    */\n\n    first: function(selector) {\n      return self.find(selector).first();\n    }\n  };\n};\n\nObject.extend(Engine.Selector, {\n  parse: function(selector) {\n    return selector.split(\",\").invoke(\"trim\");\n  },\n  process: function(item) {\n    var result;\n    result = /^(\\w+)?#?([\\w\\-]+)?\\.?([\\w\\-]+)?=?([\\w\\-]+)?/.exec(item);\n    if (result) {\n      if (result[4]) {\n        result[4] = result[4].parse();\n      }\n      return result.splice(1);\n    } else {\n      return [];\n    }\n  },\n  generate: function(selector) {\n    var ATTR, ATTR_VALUE, ID, TYPE, components;\n    components = Engine.Selector.parse(selector).map(function(piece) {\n      return Engine.Selector.process(piece);\n    });\n    TYPE = 0;\n    ID = 1;\n    ATTR = 2;\n    ATTR_VALUE = 3;\n    return {\n      match: function(object) {\n        var attr, attrMatch, component, idMatch, typeMatch, value, _i, _len;\n        for (_i = 0, _len = components.length; _i < _len; _i++) {\n          component = components[_i];\n          idMatch = (component[ID] === object.I.id) || !component[ID];\n          typeMatch = (component[TYPE] === object.I[\"class\"]) || !component[TYPE];\n          if (attr = component[ATTR]) {\n            if ((value = component[ATTR_VALUE]) != null) {\n              attrMatch = object.I[attr] === value;\n            } else {\n              attrMatch = object.I[attr];\n            }\n          } else {\n            attrMatch = true;\n          }\n          if (idMatch && typeMatch && attrMatch) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }\n});\n\n/**\nThe <code>Stats</code> module provides methods to query the engine to find game objects.\n\n@name Stats\n@fieldOf Engine\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.Stats = function(I, self) {\n  return {\n    measure: function(objects, field, frequency) {\n      if (frequency == null) {\n        frequency = 30;\n      }\n    },\n    gatherData: function() {\n      return self.find();\n    }\n  };\n};\n\n/**\nThe <code>Tilemap</code> module provides a way to load tilemaps in the engine.\n\n@name Tilemap\n@fieldOf Engine\n@module\n\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\nEngine.Tilemap = function(I, self) {\n  var clearObjects, updating;\n  Object.extend(I, {\n    map: null\n  });\n  updating = false;\n  clearObjects = false;\n  self.bind(\"update\", function() {\n    return updating = true;\n  });\n  self.bind(\"afterUpdate\", function() {\n    updating = false;\n    if (clearObjects) {\n      self.objects().clear();\n      return clearObjects = false;\n    }\n  });\n  return {\n    /**\n    Loads a new may and unloads any existing map or entities.\n    \n    @name loadMap\n    @methodOf Engine#\n    */\n\n    loadMap: function(name, complete) {\n      clearObjects = updating;\n      return I.map = Tilemap.load({\n        name: name,\n        complete: complete,\n        entity: self.add\n      });\n    }\n  };\n};\n\n/**\nThe Expirable module deactivates a <code>GameObject</code> after a specified duration.\nIf a duration is specified the object will update that many times. If -1 is\nspecified the object will have an unlimited duration.\n\nThis module is included by default in <code>GameObjects</code>\n\n    enemy = GameObject\n      x: 50\n      y: 30\n      duration: 5\n\n    enemy.include Expirable\n\n    enemy.I.active\n    # => true\n\n    5.times ->\n      enemy.update(1)\n\n    enemy.I.active\n    # => false\n\n@name Expirable\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Expirable = function(I, self) {\n  var startingAlpha;\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    duration: -1,\n    alpha: 1,\n    fadeOut: false\n  });\n  startingAlpha = I.alpha;\n  self.bind(\"update\", function(dt) {\n    if (I.fadeOut) {\n      I.alpha = startingAlpha * (1 - (I.age / I.duration));\n    }\n    if (I.duration !== -1 && I.age >= I.duration) {\n      I.active = false;\n    }\n    return I.alpha = I.alpha.clamp(0, 1);\n  });\n  return {};\n};\n\n/**\nThe `Flickerable` module provides a method to flicker a sprite between its current opacity (alpha) and a given opacity.\n\n    player = GameObject\n      alpha: 0.9\n\n    player.include 'Flickerable'\n\n    # called with no arguments, flicker will toggle the player's alpha\n    # value between 0.9 (value provided above) and 0.5 (flickerable default)\n    # every 0.1 second, for a total of 2 seconds\n    player.flicker()\n\n@name Flickerable\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Flickerable = function(I, self) {\n  var frequencyLength, originalAlpha;\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    flickerAlpha: 0.5,\n    flickerDuration: 0,\n    flickerFrequency: 0.1\n  });\n  originalAlpha = I.alpha;\n  frequencyLength = 0;\n  self.bind('update', function(elapsedTime) {\n    I.flickerDuration = I.flickerDuration.approach(0, elapsedTime);\n    frequencyLength += elapsedTime;\n    if (I.flickerDuration > 0) {\n      if (frequencyLength >= I.flickerFrequency) {\n        frequencyLength = 0;\n        if (I.alpha === I.flickerAlpha) {\n          return I.alpha = originalAlpha;\n        } else {\n          return I.alpha = I.flickerAlpha;\n        }\n      }\n    } else {\n      return I.alpha = originalAlpha;\n    }\n  });\n  return {\n    /**\n    A convenient way to set the flicker instance variables on a sprite. You can modify the\n    instance variables by hand but the suggested way to do it is through this method.\n    \n        player = GameObject()\n    \n        player.include(Flickerable)\n    \n        player.flicker\n          duration: 5\n          frequency: 0.2\n          alpha: 0.3\n    \n        # => This causes the sprite to flicker between full opacity\n        # => and 30% opacity every 0.2 seconds for 5 seconds\n    \n    @name flicker\n    @methodOf Flickerable#\n    @param {Number} [duration=2] How long the effect lasts in seconds\n    @param {Number} [frequency=0.1] Number of seconds in between opacity changes\n    @param {Number} [alpha=0.5] Alpha value to toggle between\n    @returns {GameObject} The calling object\n    */\n\n    flicker: function(options) {\n      if (options == null) {\n        options = {};\n      }\n      Object.reverseMerge(options, {\n        duration: 2,\n        frequency: 0.1,\n        alpha: 0.5\n      });\n      I.flickerDuration = options.duration;\n      I.flickerFrequency = options.frequency;\n      I.flickerAlpha = options.alpha;\n      return self;\n    }\n  };\n};\n\n/**\nThe Follow module provides a simple method to set an object's\ndirection so that it is pointed at another object.\n\nThe calculated direction is based on the center point of\neach object.\n\nThis method relies on both objects having <code>position</code> methods.\n\nInclude this module by calling <code>self.include Follow</code>\n\n    player = GameObject\n      x: 50\n      y: 50\n      width: 10\n      height: 10\n\n    enemy = GameObject\n      x: 100\n      y: 50\n      width: 10\n      height: 10\n      velocity: Point(0, 0)\n      speed: 2\n\n    enemy.include Follow\n\n    # Make an enemy follow the player\n    enemy.follow(player)\n\n    # now the enemy's direction will point toward the player\n    enemy.I.direction\n    # => Point(-1, 0)\n\n    # you can use this direction to set a velocity for your object.\n    enemy.I.velocity = enemy.I.direction.scale(I.speed)\n\n\n@name Follow\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Follow = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    velocity: Point(0, 0),\n    speed: 1\n  });\n  return {\n    /**\n    Set your velocity to follow another object.\n    \n        enemy.follow(player)\n    \n        # => The enemy now has it's velocity attribute set in\n        # the direction of the player, with magnitude equal to\n        # the enemy's speed\n    \n    @name follow\n    @methodOf Follow#\n    @param {GameObject} obj The object you want to follow\n    */\n\n    follow: function(obj) {\n      if (obj) {\n        return I.velocity = obj.position().subtract(self.position()).norm(I.speed);\n      }\n    }\n  };\n};\n\n/**\nThis object keeps track of framerate and displays it by creating and appending an\nhtml element to the DOM.\n\nOnce created you call snapshot at the end of every rendering cycle.\n\n@name Framerate\n@constructor\n*/\n\n\nthis.Framerate = function(options) {\n  var framerateUpdateInterval, framerates, numFramerates, renderTime, self, updateFramerate;\n  if (options == null) {\n    options = {};\n  }\n  numFramerates = 15;\n  framerateUpdateInterval = 250;\n  renderTime = -1;\n  framerates = [];\n  updateFramerate = function() {\n    return self.fps = framerates.average().round();\n  };\n  setInterval(updateFramerate, framerateUpdateInterval);\n  /**\n  Call this method everytime you render.\n  \n  @name rendered\n  @methodOf Framerate#\n  */\n\n  return self = {\n    rendered: function() {\n      var framerate, newTime, t;\n      if (renderTime < 0) {\n        return renderTime = new Date().getTime();\n      } else {\n        newTime = new Date().getTime();\n        t = newTime - renderTime;\n        framerate = 1000 / t;\n        framerates.push(framerate);\n        while (framerates.length > numFramerates) {\n          framerates.shift();\n        }\n        return renderTime = newTime;\n      }\n    }\n  };\n};\n\n/**\nThe default base class for all objects you can add to the engine.\n\nGameObjects fire events that you may bind listeners to. Event listeners\nmay be bound with <code>object.bind(eventName, callback)</code>\n\n@name GameObject\n@extends Core\n@constructor\n@instanceVariables age, active, created, destroyed, solid, includedModules, excludedModules\n*/\n\n\n/**\nTriggered when the object is created.\n\n    enemyCount = 0\n\n    enemy = engine.add\n      class: \"Enemy\"\n\n    enemy.bind 'create', ->\n      enemyCount++\n\n@name create\n@methodOf GameObject#\n@event\n*/\n\n\n/**\nTriggered when object is destroyed. Use\nthe destroy event to add particle effects, play sounds, etc.\n\n    bomb = GameObject()\n\n    bomb.bind 'destroy', ->\n      bomb.explode()\n      Sound.play \"Kaboom\"\n\n@name destroy\n@methodOf GameObject#\n@event\n*/\n\n\n/**\nTriggered during every update step.\n\n    player = GameObject()\n\n    player.bind 'step', ->\n      # check to see if keys are being pressed and\n      # change the player's velocity\n      if keydown.left\n        player.velocity(Point(-1, 0))\n      else if keydown.right\n        player.velocity(Point(1, 0))\n      else\n        player.velocity(Point(0, 0))\n\n@name step\n@methodOf GameObject#\n@event\n*/\n\n\n/**\nTriggered every update after the <code>step</code> event is triggered.\n\n    player = GameObject()\n\n    # we can really use the update and\n    # step events almost interchangebly\n    player.bind 'update', ->\n      # check to see if keys are being pressed and\n      # change the player's velocity\n      if keydown.left\n        player.velocity(Point(-1, 0))\n      else if keydown.right\n        player.velocity(Point(1, 0))\n      else\n        player.velocity(Point(0, 0))\n\n@name update\n@methodOf GameObject#\n@event\n*/\n\n\n/**\nTriggered when the object is removed from\nthe engine. Use the remove event to handle any clean up.\n\n    boss = GameObject()\n\n    boss.bind 'remove', ->\n      unlockDoorToLevel2()\n\n@name remove\n@methodOf GameObject#\n@event\n*/\n\n\nthis.GameObject = function(I) {\n  var self;\n  I || (I = {});\n  /**\n  @name {Object} I Instance variables\n  @memberOf GameObject#\n  */\n\n  Object.reverseMerge(I, {\n    active: true,\n    created: false,\n    destroyed: false\n  });\n  self = Core(I).extend({\n    /**\n    Update the game object. This is generally called by the engine.\n    \n    @name update\n    @methodOf GameObject#\n    */\n\n    update: function(elapsedTime) {\n      if (I.active) {\n        self.trigger('update', elapsedTime);\n      }\n      return I.active;\n    },\n    /**\n    Triggers the create event if the object has not already been created.\n    \n    @name create\n    @methodOf GameObject#\n    */\n\n    create: function() {\n      if (!I.created) {\n        self.trigger('create');\n      }\n      return I.created = true;\n    },\n    /**\n    Destroys the object and triggers the destroyed event.\n    \n    @name destroy\n    @methodOf GameObject#\n    */\n\n    destroy: function() {\n      if (!I.destroyed) {\n        self.trigger('destroy');\n      }\n      I.destroyed = true;\n      return I.active = false;\n    }\n  });\n  GameObject.defaultModules.each(function(moduleName) {\n    return self.include(moduleName);\n  });\n  return self;\n};\n\nGameObject.defaultModules = [\"Ageable\", \"Bounded\", \"Clampable\", \"Cooldown\", \"Drawable\", \"Expirable\", \"Follow\", \"GameObject.Meter\", \"Movable\", \"Rotatable\", \"TimedEvents\", \"Tween\", \"GameObject.Effect\"];\n\n/**\nConstruct an object instance from the given entity data.\n@name construct\n@memberOf GameObject\n@param {Object} entityData\n*/\n\n\nGameObject.construct = function(entityData) {\n  if (entityData[\"class\"]) {\n    return entityData[\"class\"].constantize()(entityData);\n  } else {\n    return GameObject(entityData);\n  }\n};\n\n/**\nA collection of effects to make your game juicy.\n\n@name Effect\n@fieldOf GameObject\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nGameObject.Effect = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  return {\n    /**\n    A convenient way to fade out this object over time.\n    \n        player = GameObject()\n    \n        # Fade the player object out over the next 2 seconds. \n        player.fadeOut 2\n    \n        # Fade out and then destroy\n        player.fadeOut, 0.25, ->\n          self.destroy()\n    \n    @name fadeOut\n    @methodOf GameObject#\n    @param {Number} [duration=1] Time to fade out in seconds\n    @param {Function} [complete=null] The function to execute when fade out completes.\n    */\n\n    fadeOut: function(duration, complete) {\n      if (duration == null) {\n        duration = 1;\n      }\n      return self.tween(duration, {\n        alpha: 0,\n        complete: complete\n      });\n    }\n  };\n};\n\n/**\nThe Metered module provides a simple drop-in\nmeter ui to track arbitrary numeric attributes.\n\n    player = GameObject\n      health: 100\n      heathMax: 100\n    \n    enemy = GameObject\n      health: 500\n    \n    someOtherObject = GameObject\n    \n    player.meter 'health'\n    # => Sets up a health meter that will be drawn during the player overlay event\n    \n    enemy.meter 'health'\n    # => Sets up a health meter that will be drawn during the enemy overlay event. \n    # Since healthMax wasn't provided, it is set to the value of I.health (500)\n    \n    someOtherObject.meter 'turbo'\n    # => Sets up a turbo meter that will be drawn during the someOtherObject overlay event. \n    # Since neither turbo or turboMax were provided, they are both set to 100.\n\nMetered module\n@name Metered\n@module\n@constructor\n@param {Object} I Instance variables\n@param {GameObject} self Reference to including object\n*/\n\n\nGameObject.Meter = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    meters: {}\n  });\n  self.bind('overlay', function(canvas) {\n    var backgroundColor, borderColor, borderRadius, borderWidth, color, height, meterData, name, ratio, show, width, x, y, _ref, _ref1, _ref2;\n    _ref = I.meters;\n    for (name in _ref) {\n      meterData = _ref[name];\n      backgroundColor = meterData.backgroundColor, (_ref1 = meterData.border, borderColor = _ref1.color, borderRadius = _ref1.radius, borderWidth = _ref1.width), color = meterData.color, height = meterData.height, show = meterData.show, width = meterData.width, x = meterData.x, y = meterData.y;\n      if (meterData.position != null) {\n        _ref2 = meterData.position, x = _ref2.x, y = _ref2.y;\n      }\n      if (!show) {\n        return;\n      }\n      ratio = (I[name] / I[\"\" + name + \"Max\"]).clamp(0, 1);\n      canvas.drawRoundRect({\n        color: backgroundColor,\n        radius: borderRadius,\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n      canvas.drawRoundRect({\n        color: color,\n        x: x,\n        y: y,\n        radius: borderRadius,\n        width: width * ratio,\n        height: height\n      });\n      canvas.drawRoundRect({\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        radius: borderRadius,\n        stroke: {\n          color: borderColor,\n          width: borderWidth\n        }\n      });\n    }\n  });\n  return {\n    /**\n    Configures a meter to be drawn each overlay event.\n    \n        player = GameObject\n      \n        player.meter 'health',\n          border\n            color: 'brown'\n            radius: 3\n          color: 'pink'\n          height: 20\n          x: 5\n          y: 5\n          show: true\n          width: 150\n      \n        # => Sets up a health meter, using all the configuration options\n    \n    @name meter\n    @methodOf Metered#\n    @param {String} name The name of the property to meter\n    @param {Object} options The meter configuration options\n    @param {String} border: color Color of the meter's border\n    @param {Number} border: width Width of the meter's border\n    @param {String} color Color of the meter's inner rectangle\n    @param {Number} height Height of the meter\n    @param {Object} position An x, y object representing the position of the meter\n    @param {Number} x x position of the meter\n    @param {Number} y y position of the meter\n    @param {Number} border: radius Border radius of the meter\n    @param {Boolean} show Boolean to toggle whether of not to display the meter\n    @param {Number} width How wide the meter is\n    */\n\n    meter: function(name, options) {\n      if (options == null) {\n        options = {};\n      }\n      Object.reverseMerge(options, {\n        backgroundColor: 'black',\n        border: {\n          color: 'white',\n          radius: 2,\n          width: 1.5\n        },\n        color: 'green',\n        height: 10,\n        x: 0,\n        y: 0,\n        show: true,\n        width: 100\n      });\n      if (I[name] == null) {\n        I[name] = 100;\n      }\n      if (!I[\"\" + name + \"Max\"]) {\n        if (I[name]) {\n          I[\"\" + name + \"Max\"] = I[name];\n        } else {\n          I[\"\" + name + \"Max\"] = 100;\n        }\n      }\n      return I.meters[name] = options;\n    },\n    /**\n    Shows the named meter\n    \n        player = GameObject\n      \n        # creates a health meter but disables visibility\n        player.meter 'health'\n          show: false\n      \n        # enables visibility for the meter named 'health'\n        player.showMeter 'health'\n    \n    @name showMeter\n    @methodOf Metered#\n    @param {String} name The name of the meter to show\n    */\n\n    showMeter: function(name) {\n      return I.meters[name].show = true;\n    },\n    /**\n    Hides the named meter\n    \n        player = GameObject\n      \n        # creates a health meter\n        player.meter 'health'\n      \n        # disables visibility for the meter named 'health'\n        player.hideMeter 'health'\n    \n    @name hideMeter\n    @methodOf Metered#\n    @param {String} name The name of the meter to hide\n    */\n\n    hideMeter: function(name) {\n      return I.meters[name].show = false;\n    },\n    /**\n    Toggles visibility of the named meter\n    \n        player = GameObject\n      \n        # creates a health meter\n        player.meter 'health'\n      \n        # toggles visibility for the meter named 'health'\n        player.toggleMeter 'health'\n    \n    @name toggleMeter\n    @methodOf Metered#\n    @param {String} name The name of the meter to toggle\n    */\n\n    toggleMeter: function(name) {\n      return I.meters[name].show = !I.meters[name].show;\n    }\n  };\n};\n\n/**\nThe Game Over class sets up a simple game state with restart instructions.\n\n@see TextScreen\n@name GameOver\n@constructor\n*/\n\n\n/**\nTransitions to the title state on user input.\n\n@name update\n@methodOf GameOver#\n@event\n*/\n\n\n/**\nDraws Game Over screen and reset instructions.\n\n@name overlay\n@methodOf GameOver#\n@param {PixieCanvas} canvas\n@event\n*/\n\n\nthis.GameOver = function(I) {\n  var self;\n  if (I == null) {\n    I = {};\n  }\n  self = TextScreen(I);\n  self.bind('update', function() {\n    if (justPressed.any) {\n      return engine.delay(15, function() {\n        return engine.setState(TitleScreen());\n      });\n    }\n  });\n  self.bind(\"overlay\", function(canvas) {\n    self.centerText(canvas, \"Game Over\");\n    return self.centerText(canvas, \"Press any key to restart\", {\n      size: 12,\n      y: App.height / 2 + 30\n    });\n  });\n  return self;\n};\n\nthis.GameState = function(I) {\n  var queuedObjects, self;\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    objects: []\n  });\n  queuedObjects = [];\n  self = Core(I).extend({\n    /**\n    The add method creates and adds an object to the game world. Two\n    other events are triggered around this one: beforeAdd and afterAdd.\n    \n        # you can add arbitrary entityData and\n        # the engine will make it into a GameObject\n        engine.add\n          x: 50\n          y: 30\n          color: \"red\"\n    \n        player = engine.add\n          class: \"Player\"\n    \n    @name add\n    @methodOf Engine#\n    @param {Object} entityData The data used to create the game object.\n    @returns {GameObject}\n    */\n\n    add: function(entityData) {\n      var object;\n      self.trigger(\"beforeAdd\", entityData);\n      object = GameObject.construct(entityData);\n      object.create();\n      self.trigger(\"afterAdd\", object);\n      if (I.updating) {\n        queuedObjects.push(object);\n      } else {\n        I.objects.push(object);\n      }\n      return object;\n    },\n    objects: function() {\n      return I.objects.copy();\n    }\n  });\n  self.bind(\"update\", function(elapsedTime) {\n    var toKeep, toRemove, _ref;\n    I.updating = true;\n    I.objects.invoke(\"trigger\", \"beforeUpdate\", elapsedTime);\n    _ref = I.objects.partition(function(object) {\n      return object.update(elapsedTime);\n    }), toKeep = _ref[0], toRemove = _ref[1];\n    I.objects.invoke(\"trigger\", \"afterUpdate\", elapsedTime);\n    toRemove.invoke(\"trigger\", \"remove\");\n    I.objects = toKeep.concat(queuedObjects);\n    queuedObjects = [];\n    return I.updating = false;\n  });\n  self.include(\"GameState.Cameras\");\n  self.include(\"GameState.SaveState\");\n  return self;\n};\n\nGameState.Cameras = function(I, self) {\n  var cameras;\n  cameras = [Camera()];\n  self.bind('update', function(elapsedTime) {\n    return self.cameras().invoke('trigger', 'update', elapsedTime);\n  });\n  self.bind('afterUpdate', function(elapsedTime) {\n    return self.cameras().invoke('trigger', 'afterUpdate', elapsedTime);\n  });\n  self.bind('draw', function(canvas) {\n    return self.cameras().invoke('trigger', 'draw', canvas, self.objects());\n  });\n  self.bind('overlay', function(canvas) {\n    return self.cameras().invoke('trigger', 'overlay', canvas, self.objects());\n  });\n  return {\n    addCamera: function(data) {\n      return cameras.push(Camera(data));\n    },\n    /**\n    Returns the array of camera objects.\n    \n    @name cameras\n    @methodOf Engine#\n    @returns {Array}\n    */\n\n    cameras: function(newCameras) {\n      if (newCameras) {\n        cameras = newCameras;\n        return self;\n      } else {\n        return cameras;\n      }\n    }\n  };\n};\n\n/**\nThe <code>SaveState</code> module provides methods to save and restore the current game state.\n\n@name SaveState\n@fieldOf GameState\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the game state\n*/\n\n\nGameState.SaveState = function(I, self) {\n  var savedState;\n  savedState = null;\n  return {\n    /**\n    Save the current game state and returns a JSON object representing that state.\n    \n        engine.bind 'update', ->\n          if justPressed.s\n            engine.saveState()\n    \n    @name saveState\n    @methodOf GameState#\n    @returns {Array} An array of the instance data of all objects in the game state\n    */\n\n    saveState: function() {\n      return savedState = I.objects.map(function(object) {\n        return Object.extend({}, object.I);\n      });\n    },\n    /**\n    Loads the game state passed in, or the last saved state, if any.\n    \n        engine.bind 'update', ->\n          if justPressed.l\n            # loads the last saved state\n            engine.loadState()\n      \n          if justPressed.o\n            # removes all game objects, then reinstantiates \n            # them with the entityData passed in\n            engine.loadState([{x: 40, y: 50, class: \"Player\"}, {x: 0, y: 0, class: \"Enemy\"}, {x: 500, y: 400, class: \"Boss\"}])\n    \n    @name loadState\n    @methodOf GameState#\n    @param [newState] An arraf of object instance data to load.\n    */\n\n    loadState: function(newState) {\n      if (newState || (newState = savedState)) {\n        I.objects.invoke(\"trigger\", \"remove\");\n        I.objects = [];\n        return newState.each(function(objectData) {\n          return self.add(Object.extend({}, objectData));\n        });\n      }\n    },\n    /**\n    Reloads the current game state, useful for hotswapping code.\n    \n        engine.I.objects.each (object) ->\n          # bring all objects to (0, 0) for some reason\n          object.I.x = 0\n          object.I.y = 0\n      \n        # reload all objects to make sure\n        # they are at (0, 0)  \n        engine.reload()\n    \n    @name reload\n    @methodOf GameState#\n    */\n\n    reload: function() {\n      var oldObjects;\n      oldObjects = I.objects;\n      I.objects = [];\n      return oldObjects.each(function(object) {\n        object.trigger(\"remove\");\n        return self.add(object.I);\n      });\n    }\n  };\n};\n\n/**\nThe <code>SingleCamera</code> module provides provides a single camera view of the game.\nIts transform can be adjusted to view different areas and provide various camera effects.\n\n@name SingleCamera\n@fieldOf GameState\n@module\n@param {Object} I Instance variables\n@param {Object} self Reference to the game state\n*/\n\n\nGameState.SingleCamera = function(I, self) {\n  Object.reverseMerge(I, {\n    cameraTransform: Matrix.IDENTITY,\n    zSort: true\n  });\n  self.attrAccessor(\"cameraTransform\");\n  self.bind(\"draw\", function(canvas) {\n    return canvas.withTransform(I.cameraTransform, function(canvas) {\n      var drawObjects;\n      drawObjects = self.objects();\n      if (I.zSort) {\n        drawObjects.sort(function(a, b) {\n          return a.I.zIndex - b.I.zIndex;\n        });\n      }\n      return drawObjects.invoke(\"draw\", canvas);\n    });\n  });\n  return {};\n};\n\n/**\nA Game State that loads the map for a given level and transitions into the level.\n\n@see GameState\n@name LevelState\n@constructor\n@param {Number} duration Amount of time in frames it takes to fade into the level\n@param {String} level name of the map to load\n*/\n\n\n/**\nFades in the current level and loads the map.\n\n@name enter\n@methodOf LevelState#\n@event\n*/\n\n\nthis.LevelState = function(I) {\n  var self;\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    duration: 10,\n    level: 'level1'\n  });\n  self = GameState(I);\n  self.bind(\"enter\", function() {\n    engine.fadeIn({\n      duration: I.duration\n    });\n    return engine.loadMap(I.level, function() {\n      return engine.I.transitioning = false;\n    });\n  });\n  return self;\n};\n\n/**\nThe Movable module automatically updates the position and velocity of\nGameObjects based on the velocity and acceleration. It does not check\ncollisions so is probably best suited to particle effect like things.\n\n    player = GameObject\n      x: 0\n      y: 0\n      velocity: Point(0, 0)\n      acceleration: Point(1, 0)\n      maxSpeed: 2\n\n    player.include(Movable)\n\n    # => `velocity is {x: 0, y: 0} and position is {x: 0, y: 0}`\n\n    player.update(1)\n    # => `velocity is {x: 1, y: 0} and position is {x: 1, y: 0}`\n\n    player.update(1)\n    # => `velocity is {x: 2, y: 0} and position is {x: 3, y: 0}`\n\n    # we've hit our maxSpeed so our velocity won't increase\n    player.update(1)\n    # => `velocity is {x: 2, y: 0} and position is {x: 5, y: 0}`\n\n@name Movable\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Movable = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    acceleration: Point(0, 0),\n    velocity: Point(0, 0)\n  });\n  I.acceleration = Point(I.acceleration.x, I.acceleration.y);\n  I.velocity = Point(I.velocity.x, I.velocity.y);\n  self.attrReader(\"velocity\", \"acceleration\");\n  self.unbind(\".Movable\");\n  return self.bind('update.Movable', function(dt) {\n    var currentSpeed;\n    I.velocity = I.velocity.add(I.acceleration.scale(dt));\n    if (I.maxSpeed != null) {\n      currentSpeed = I.velocity.magnitude();\n      if (currentSpeed > I.maxSpeed) {\n        I.velocity = I.velocity.scale(I.maxSpeed / currentSpeed);\n      }\n    }\n    I.x += I.velocity.x * dt;\n    return I.y += I.velocity.y * dt;\n  });\n};\n\n/**\nCreates an oscillator function with the given parameters.\n\n@name Oscillator\n@constructor\n@param {Number} amplitude How much to scale the oscillator function value\n@param {Number} period How fast the osciallator function repeats\n@param {Number} offset How much to offset the created oscillator function. Useful for translating between sin and cosine functions.\n*/\n\n\nthis.Oscillator = function(options) {\n  var amplitude, offset, period;\n  if (options == null) {\n    options = {};\n  }\n  amplitude = options.amplitude, period = options.period, offset = options.offset;\n  if (amplitude == null) {\n    amplitude = 1;\n  }\n  if (period == null) {\n    period = 1;\n  }\n  if (offset == null) {\n    offset = 0;\n  }\n  return function(t) {\n    return amplitude * Math.cos(Math.TAU * t / period + offset);\n  };\n};\n\n/**\n@name ResourceLoader\n@namespace\n\nHelps access the assets in your game.\n*/\n\n\n(function() {\n  var ResourceLoader, typeTable;\n  typeTable = {\n    images: \"png\",\n    data: \"json\",\n    tilemaps: \"tilemap\"\n  };\n  ResourceLoader = {\n    /**\n    Return the url for a particular asset.\n    \n        ResourceLoader.urlFor(\"images\", \"player\")\n        # => This returns the url for the file \"player.png\" in your images directory.\n    \n    @name urlFor\n    @methodOf ResourceLoader#\n    @param {String} directory The directory your file is in.\n    @param {String} name The name of the file.\n    @returns {String} The full url of your asset\n    */\n\n    urlFor: function(directory, name) {\n      var type, _ref;\n      directory = (typeof App !== \"undefined\" && App !== null ? (_ref = App.directories) != null ? _ref[directory] : void 0 : void 0) || directory;\n      type = typeTable[directory];\n      return \"\" + BASE_URL + \"/\" + directory + \"/\" + name + \".\" + type + \"?\" + MTIME;\n    }\n  };\n  return (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"ResourceLoader\"] = ResourceLoader;\n})();\n\n/**\nThe Rotatable module rotates the object\nbased on its rotational velocity.\n\n    player = GameObject\n      x: 0\n      y: 0\n      rotationalVelocity: Math.PI / 64\n\n    player.I.rotation\n    # => 0\n\n    player.update(1)\n\n    player.I.rotation\n    # => 0.04908738521234052 # Math.PI / 64\n\n    player.update(1)\n\n    player.I.rotation\n    # => 0.09817477042468103 # 2 * (Math.PI / 64)\n\n@name Rotatable\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Rotatable = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    rotation: 0,\n    rotationalVelocity: 0\n  });\n  self.bind('update', function(dt) {\n    return I.rotation += I.rotationalVelocity * dt;\n  });\n  return {};\n};\n\n/**\nThe Sprite class provides a way to load images for use in games.\n\nBy default, images are loaded asynchronously. A proxy object is\nreturned immediately. Even though it has a draw method it will not\ndraw anything to the screen until the image has been loaded.\n\n@name Sprite\n@constructor\n*/\n\n\n(function() {\n  var LoaderProxy, Sprite, spriteCache;\n  LoaderProxy = function() {\n    return {\n      draw: function() {},\n      fill: function() {},\n      frame: function() {},\n      update: function() {},\n      width: null,\n      height: null,\n      image: null\n    };\n  };\n  spriteCache = {};\n  Sprite = function(image, sourceX, sourceY, width, height) {\n    sourceX || (sourceX = 0);\n    sourceY || (sourceY = 0);\n    width || (width = image.width);\n    height || (height = image.height);\n    return {\n      /**\n      Draw this sprite on the given canvas at the given position.\n      \n      @name draw\n      @methodOf Sprite#\n      @param {PowerCanvas} canvas Reference to the canvas to draw the sprite on\n      @param {Number} x Position on the x axis to draw the sprite\n      @param {Number} y Position on the y axis to draw the sprite\n      */\n\n      draw: function(canvas, x, y) {\n        return canvas.drawImage(image, sourceX, sourceY, width, height, x, y, width, height);\n      },\n      /**\n      Draw this sprite on the given canvas tiled to the x, y,\n      width, and height dimensions specified.\n      \n      @name fill\n      @methodOf Sprite#\n      @param {PowerCanvas} canvas Reference to the canvas to draw the sprite on\n      @param {Number} x Position on the x axis to draw the sprite\n      @param {Number} y Position on the y axis to draw the sprite\n      @param {Number} width How far to tile the sprite on the x-axis\n      @param {Number} height How far to tile the sprite on the y-axis\n      @param {String} repeat Repeat options. Can be `repeat-x`, `repeat-y`, `no-repeat`, or `repeat`. Defaults to `repeat`\n      */\n\n      fill: function(canvas, x, y, width, height, repeat) {\n        var pattern;\n        if (repeat == null) {\n          repeat = \"repeat\";\n        }\n        pattern = canvas.createPattern(image, repeat);\n        return canvas.drawRect({\n          x: x,\n          y: y,\n          width: width,\n          height: height,\n          color: pattern\n        });\n      },\n      width: width,\n      height: height,\n      image: image\n    };\n  };\n  /**\n  Loads all sprites from a sprite sheet found in\n  your images directory, specified by the name passed in.\n  \n  @name loadSheet\n  @methodOf Sprite\n  @param {String} name Name of the spriteSheet image in your images directory\n  @param {Number} tileWidth Width of each sprite in the sheet\n  @param {Number} tileHeight Height of each sprite in the sheet\n  @returns {Array} An array of sprite objects\n  */\n\n  Sprite.loadSheet = function(name, tileWidth, tileHeight) {\n    var image, sprites, url;\n    url = ResourceLoader.urlFor(\"images\", name);\n    sprites = [];\n    image = new Image();\n    image.onload = function() {\n      var imgElement;\n      imgElement = this;\n      return (image.height / tileHeight).times(function(row) {\n        return (image.width / tileWidth).times(function(col) {\n          return sprites.push(Sprite(imgElement, col * tileWidth, row * tileHeight, tileWidth, tileHeight));\n        });\n      });\n    };\n    image.src = url;\n    return sprites;\n  };\n  /**\n  Loads a sprite from a given url.\n  \n  @name load\n  @methodOf Sprite\n  @param {String} url\n  @param {Function} [loadedCallback]\n  @returns {Sprite} A sprite object\n  */\n\n  Sprite.load = function(url, loadedCallback) {\n    var img, proxy, sprite;\n    if (sprite = spriteCache[url]) {\n      if (loadedCallback != null) {\n        loadedCallback.defer(sprite);\n      }\n      return sprite;\n    }\n    img = new Image();\n    proxy = LoaderProxy();\n    img.onload = function() {\n      spriteCache[url] = Object.extend(proxy, Sprite(this));\n      return typeof loadedCallback === \"function\" ? loadedCallback(proxy) : void 0;\n    };\n    img.src = url;\n    return proxy;\n  };\n  /**\n  Loads a sprite with the given pixie id.\n  \n  @name fromPixieId\n  @methodOf Sprite\n  @param {Number} id Pixie Id of the sprite to load\n  @param {Function} [callback] Function to execute once the image is loaded. The sprite proxy data is passed to this as a parameter.\n  @returns {Sprite}\n  */\n\n  Sprite.fromPixieId = function(id, callback) {\n    return Sprite.load(\"http://pixieengine.com/s3/sprites/\" + id + \"/original.png\", callback);\n  };\n  /**\n  A sprite that draws nothing.\n  \n  @name EMPTY\n  @fieldOf Sprite\n  @constant\n  @returns {Sprite}\n  */\n\n  /**\n  A sprite that draws nothing.\n  \n  @name NONE\n  @fieldOf Sprite\n  @constant\n  @returns {Sprite}\n  */\n\n  Sprite.EMPTY = Sprite.NONE = LoaderProxy();\n  /**\n  Loads a sprite from a given url.\n  \n  @name fromURL\n  @methodOf Sprite\n  @param {String} url The url where the image to load is located\n  @param {Function} [callback] Function to execute once the image is loaded. The sprite proxy data is passed to this as a parameter.\n  @returns {Sprite}\n  */\n\n  Sprite.fromURL = Sprite.load;\n  /**\n  Loads a sprite with the given name.\n  \n  @name loadByName\n  @methodOf Sprite\n  @param {String} name The name of the image in your images directory\n  @param {Function} [callback] Function to execute once the image is loaded. The sprite proxy data is passed to this as a parameter.\n  @returns {Sprite}\n  */\n\n  Sprite.loadByName = function(name, callback) {\n    return Sprite.load(ResourceLoader.urlFor(\"images\", name), callback);\n  };\n  return (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"Sprite\"] = Sprite;\n})();\n\n/**\nThe Text Effect class provides a method to display moving text onscreen, fading out the text over the effect duration.\n\n    # adds a TextEffect to the engine at (60, 100)\n    engine.add 'TextEffect'\n      x: 60\n      y: 100\n\n@name TextEffect\n@constructor\n*/\n\n\n/**\nUpdates the position of the text based on the effect velocity. Updates the\nalpha based on the elapsed time since the effect creation.\n\n@name update\n@methodOf TextEffect#\n@event\n*/\n\n\n/**\nDraws text from `I.textShadow` `I.text`.\n\n@name draw\n@methodOf TextEffect#\n@param {PixieCanvas} canvas\n@event\n*/\n\n\nthis.TextEffect = function(I) {\n  var self;\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    color: Color('green'),\n    duration: -1,\n    font: '20px Helvetica',\n    text: '100',\n    textShadow: Color('black'),\n    alpha: 1,\n    rotation: 0,\n    velocity: Point(0, 0)\n  });\n  self = GameObject(I);\n  self.bind(\"update\", function() {\n    if (I.rotationalVelocity != null) {\n      I.rotation += I.rotationalVelocity;\n    }\n    return I.alpha = (1 - (I.age / I.duration)).clamp(0, 1);\n  });\n  self.unbind(\"draw\");\n  self.bind(\"draw\", function(canvas) {\n    if (!I.color.channels) {\n      I.color = Color(I.color);\n    }\n    if (!I.textShadow.channels) {\n      I.textShadow = Color(I.textShadow);\n    }\n    I.color.a = I.alpha;\n    I.textShadow.a = I.alpha;\n    I.width = canvas.measureText(I.text);\n    canvas.font(I.font);\n    canvas.drawText({\n      color: I.textShadow,\n      x: 1 - I.width,\n      y: 1,\n      text: I.text\n    });\n    return canvas.drawText({\n      color: I.color,\n      x: 0 - I.width,\n      y: 0,\n      text: I.text\n    });\n  });\n  return self;\n};\n\n/**\n`TextEffect.Floating` is a simple subclass of `TextEffect`. It provides some defaults\nto move the text upward and fade it out over 0.5 seconds.\n\n    # adds a FloatingTextEffect to the engine\n    # at (50, 50). This effect will float upward\n    # at 90 pixels/sec and will fadeOut over 0.5 seconds\n    engine.add 'TextEffect.Floating'\n      x: 50\n      y: 50\n\n@see TextEffect\n@name Floating\n@fieldOf TextEffect\n@constructor\n*/\n\n\nTextEffect.Floating = function(I) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    duration: 0.5,\n    velocity: Point(0, -90)\n  });\n  return TextEffect(I);\n};\n\n/**\nThe Text Screen class is a GameState that provides convenience methods for drawing text to screen.\n\n@name TextScreen\n@constructor\n*/\n\n\nthis.TextScreen = function(I) {\n  var self;\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    font: 'Helvetica',\n    fontSize: 24,\n    fontColor: 'white',\n    yPosition: App.height / 2\n  });\n  return self = GameState(I).extend({\n    /**\n    Draw center aligned text at the given y position.\n    \n        screen = TextScreen()\n        screen.centerText canvas, 'Centering text is easy'\n    \n    @name centerText\n    @methodOf TextScreen#\n    @param {PixieCanvas} canvas The canvas to draw on\n    @param {String} text The text to draw\n    @param {Object} options These include font, size, color, and yPosition\n    */\n\n    centerText: function(canvas, text, options) {\n      var color, font, size, yPosition;\n      if (options == null) {\n        options = {};\n      }\n      font = options.font || I.font;\n      size = options.size || I.fontSize;\n      color = options.color || I.fontColor;\n      yPosition = options.y || I.yPosition;\n      canvas.font(\"\" + size + \"px \" + font);\n      return canvas.centerText({\n        y: yPosition,\n        text: text,\n        color: color\n      });\n    }\n  });\n};\n\n(function() {\n  var Map, Tilemap, loadByName;\n  Map = function(data, entityCallback) {\n    var entity, loadEntities, spriteLookup, tileHeight, tileWidth, uuid, _ref;\n    tileHeight = data.tileHeight;\n    tileWidth = data.tileWidth;\n    spriteLookup = {};\n    _ref = App.entities;\n    for (uuid in _ref) {\n      entity = _ref[uuid];\n      spriteLookup[uuid] = Sprite.fromURL(entity.tileSrc);\n    }\n    loadEntities = function() {\n      if (!entityCallback) {\n        return;\n      }\n      return data.layers.each(function(layer, layerIndex) {\n        var instance, instanceData, instances, x, y, _i, _len, _results;\n        if (instances = layer.instances) {\n          _results = [];\n          for (_i = 0, _len = instances.length; _i < _len; _i++) {\n            instance = instances[_i];\n            x = instance.x, y = instance.y, uuid = instance.uuid;\n            instanceData = Object.extend({\n              layer: layerIndex,\n              sprite: spriteLookup[uuid],\n              x: x + tileWidth / 2,\n              y: y + tileHeight / 2\n            }, App.entities[uuid], instance.properties);\n            _results.push(entityCallback(instanceData));\n          }\n          return _results;\n        }\n      });\n    };\n    loadEntities();\n    return data;\n  };\n  Tilemap = function(name, callback, entityCallback) {\n    return fromPixieId(App.Tilemaps[name], callback, entityCallback);\n  };\n  loadByName = function(name, callback, entityCallback) {\n    var proxy, url;\n    url = ResourceLoader.urlFor(\"tilemaps\", name);\n    proxy = {};\n    $.getJSON(url, function(data) {\n      Object.extend(proxy, Map(data, entityCallback));\n      return typeof callback === \"function\" ? callback(proxy) : void 0;\n    });\n    return proxy;\n  };\n  Tilemap.load = function(options) {\n    if (options.pixieId) {\n      return fromPixieId(options.pixieId, options.complete, options.entity);\n    } else if (options.name) {\n      return loadByName(options.name, options.complete, options.entity);\n    }\n  };\n  return (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"Tilemap\"] = Tilemap;\n})();\n\n/**\nThe TimedEvents module allows arbitrary code to be executed at set intervals. <code>GameObject</code> includes this module by default\n\nTimedEvents module\n@name TimedEvents\n@module\n@constructor\n@param {Object} I Instance variables\n*/\n\n\nthis.TimedEvents = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    everyEvents: [],\n    delayEvents: []\n  });\n  self.bind(\"update\", function(elapsedTime) {\n    var event, firingEvents, fn, period, _i, _len, _ref, _ref1;\n    _ref = I.everyEvents;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      event = _ref[_i];\n      fn = event.fn, period = event.period;\n      while (event.lastFired < I.age + elapsedTime) {\n        self.sendOrApply(fn);\n        event.lastFired += period;\n      }\n    }\n    _ref1 = I.delayEvents.partition(function(event) {\n      return (event.delay -= elapsedTime) >= 0;\n    }), I.delayEvents = _ref1[0], firingEvents = _ref1[1];\n    return firingEvents.each(function(event) {\n      return self.sendOrApply(event.fn);\n    });\n  });\n  return {\n    /**\n    Execute <code>fn</code> every <code>n</code> frames.\n    \n        player = GameObject()\n    \n        player.include TimedEvents\n    \n        # doSomething is called every 4 seconds\n        player.every 4, ->\n          doSomething()\n    \n    @name every\n    @methodOf TimedEvents#\n    @param {Number} n Number of frames to wait before executing the callback\n    @param {Function} fn Code to execute after <code>n</code> frames has passed\n    */\n\n    every: function(period, fn) {\n      if (!(period > 0)) {\n        return;\n      }\n      return I.everyEvents.push({\n        fn: fn,\n        period: period,\n        lastFired: I.age\n      });\n      /**\n        Execute a callback after a number of seconds have passed.\n      \n        self.delay 5, ->\n          engine.add\n            class: \"Ghost\"\n      \n        @name delay\n        @methodOf TimedEvents#\n        @param {Number} steps The number of steps to wait before executing the callback\n        @param {Function} callback The callback to be executed.\n      \n        @returns {Engine} self\n      */\n\n    },\n    delay: function(seconds, fn) {\n      I.delayEvents.push({\n        delay: seconds,\n        fn: fn\n      });\n      return self;\n    },\n    sendOrApply: function() {\n      var args, fn;\n      fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      if (typeof fn === \"function\") {\n        return fn.apply(self, args);\n      } else {\n        return self.send.apply(self, [fn].concat(__slice.call(args)));\n      }\n    }\n  };\n};\n\n/**\nThe Title Screen class sets up a simple game title screen using <code>App.name</code>\n\n@see TextScreen\n@name TitleScreen\n@constructor\n*/\n\n\n/**\nGoes to the next level on any user input.\n\n@name update\n@methodOf TitleScreen#\n@event\n*/\n\n\n/**\nOverlays the title text in the middle of the screen. Uses <code>App.name</code>\n\n@name overlay\n@methodOf TitleScreen#\n@param {PixieCanvas} canvas\n@event\n*/\n\n\nthis.TitleScreen = function(I) {\n  var self;\n  if (I == null) {\n    I = {};\n  }\n  self = TextScreen(I);\n  self.bind('update', function() {\n    if (justPressed.any) {\n      return engine.nextLevel();\n    }\n  });\n  self.bind(\"overlay\", function(canvas) {\n    self.centerText(canvas, App.name);\n    return self.centerText(canvas, \"Press any key to start\", {\n      size: 12,\n      y: App.height / 2 + 30\n    });\n  });\n  return self;\n};\n\n/**\nThe <code>Tween</code> module provides a method to tween object properties.\n\n@name Tween\n@module\n@constructor\n@param {Object} I Instance variables\n@param {Core} self Reference to including object\n*/\n\n\nthis.Tween = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  Object.reverseMerge(I, {\n    activeTweens: {}\n  });\n  self.bind(\"update\", function(elapsedTime) {\n    var data, easingFunction, property, t, _base, _base1, _ref, _results;\n    t = I.age + elapsedTime;\n    _ref = I.activeTweens;\n    _results = [];\n    for (property in _ref) {\n      data = _ref[property];\n      if (t >= data.endTime) {\n        I[property] = data.end;\n        if (typeof (_base = I.activeTweens[property]).complete === \"function\") {\n          _base.complete();\n        }\n        _results.push(delete I.activeTweens[property]);\n      } else {\n        if (typeof (_base1 = data.easing).isString === \"function\" ? _base1.isString() : void 0) {\n          easingFunction = Easing[data.easing](data.start, data.end);\n        } else {\n          easingFunction = data.easing;\n        }\n        _results.push(I[property] = easingFunction((t - data.startTime) / data.duration));\n      }\n    }\n    return _results;\n  });\n  return {\n    /**\n    Modify the object's properties over time.\n    \n        player = GameObject()\n    \n        player.tween 30,\n          x: 50\n          y: 50\n          easing: \"quadratic\"\n    \n        player = GameObject()\n    \n        player.tween 30,\n          x: 150\n          y: 150\n          complete: ->\n            player.dance()\n    \n    @name tween\n    @methodOf Tween#\n    @param {Number} duration How long (in frames) until the object's properties reach their final values.\n    @param {Object} properties Which properties to tween. Set the `easing` property to specify the easing function.\n    */\n\n    tween: function(duration, properties) {\n      var complete, easing, property, target, _results;\n      properties = Object.extend({}, properties);\n      easing = properties.easing || \"linear\";\n      complete = properties.complete;\n      delete properties.easing;\n      delete properties.complete;\n      _results = [];\n      for (property in properties) {\n        target = properties[property];\n        _results.push(I.activeTweens[property] = {\n          complete: complete,\n          end: target,\n          start: I[property],\n          easing: easing,\n          duration: duration,\n          startTime: I.age,\n          endTime: I.age + duration\n        });\n      }\n      return _results;\n    }\n  };\n};\n","filename":"gamelib.js"},"intro.haml":{"content":".intro(style=\"background-image: url(http://a2.pixiecdn.com/9756865efbcd9ea98cdc0c8636a1fa76343891d1)\")\n  .content-wrap\n    .content\n      %h1 Trash Robots\n\n      %p Build your robot dream team in 10 seconds from garbage.\n\n      %button Start\n        - on \"click\", ->\n          - console.log \"clicked\"\n          - goToSetup()\n","filename":"intro.haml"},"log.coffee":{"content":"[\"log\", \"info\", \"error\", \"warn\"].each (name) ->\n  window[name] = (args...)->\n    console[name](args...) if console?\n","filename":"log.coffee"},"main.coffee":{"content":"{$root, gist} = ENV\n\nappRoot = $ \"<div>\",\n  class: \"app\"\n\n$root.append(appRoot)\n$root = appRoot\n\n# HACK: Load JS Libs\nObject.keys(gist.files).each (name) ->\n  # Load all js files except build\n  if name.extension() is \"js\" and name.withoutExtension() != \"build\"\n    Function(gist.files[name].content)()\n\n# Apply our styles\nif styleContent = gist.files[\"style.css\"]?.content\n  $root.append $(\"<style>\",\n    html: styleContent\n  )\n\n$root.append HAMLjr.templates.arena()\n$root.append HAMLjr.templates.intro()\n\ncountdownInterval = null\nsetupTimeLimit = 10\n\n@goToSetup = ->\n  $(\".setup\").remove()\n  setupConfig = Setup()\n  $root.append HAMLjr.templates.setup(setupConfig)\n  \n  $(\".intro\").hide()\n  # TODO: Stop game if playing\n  \n  setupStartedAt = +new Date\n  \n  clearInterval countdownInterval\n  countdownInterval = setInterval ->\n    time = (setupStartedAt + setupTimeLimit * 1000 - (+new Date)) / 1000\n\n    size = (time % 1) * 20 + 40\n    color = \"lime\"\n    color = \"yellow\" if time < 6\n    color = \"red\" if time < 3\n\n    if time < 0\n      clearInterval countdownInterval\n      startGame(setupConfig)\n    else\n      $(\".setup .time\")\n        .text(time.toFixed(2))\n        .css\n          fontSize: size\n          color: color\n  , 15\n\ncanvas = $root.children(\"canvas\").pixieCanvas()\n\ncanvas.fill(\"gray\")\n\n@engine = Engine\n  canvas: canvas\n  FPS: 60\n\nstartGame = (config) ->\n  $(\".setup\").hide()\n  $(\".intro\").hide()\n\n  engine.start()\n\n  config.robots.each (data, i) ->\n    y = (i + 1) * App.height/4\n    engine.add \"Robot\", Object.extend(data,\n      y: y\n    )\n\n    engine.add \"Robot\",\n      color: \"red\"\n      x: App.width\n      y: y\n      headingInitial: 0.5.turns\n      team: 1\n\nengine.on \"overlay\", (canvas) ->\n  canvas.drawText\n    x: 10\n    y: 20\n    color: \"white\"\n    text: engine.objects().length\n\nobjectCollision = (a, b) -> \n  Collision.circular(a.circle(), b.circle())\n\nengine.on \"update\", (dt) ->\n  Collision.collide \"Missile\", \"Robot\", (missile, robot) ->\n    # Can't hit ourselves\n    return if missile.I.source is robot\n\n    missile.destroy()\n  , objectCollision\n\n  Collision.collide \"Explosion, Blade, Flame\", \"Robot\", (explosion, robot) ->\n    explosion.hit(robot, dt)\n  , objectCollision\n\n  Collision.collide \"Explosion\", \"Missile\", (explosion, missile) ->\n    missile.destroy()\n  , objectCollision\n\n  engine.find(\"Missile\").eachPair (a, b) ->\n    if objectCollision(a, b)\n      a.destroy()\n      b.destroy()\n","filename":"main.coffee"},"missile.coffee":{"content":"@Missile = (I={}) ->\n  Object.defaults I,\n    speed: 250\n    heading: 0\n    radius: 10\n\n  self = GameObject(I)\n  \n  self.on \"destroy\", ->\n    engine.add \"Explosion\",\n      x: I.x\n      y: I.y\n  \n  self.on \"update\", ->\n    I.velocity = Point.fromAngle(I.heading).scale(I.speed)\n\n    # Explode if outside arena\n    if I.x <= 0 or I.x >= App.width or I.y <= 0 or I.y >= App.height\n      self.I.x = self.I.x.clamp(0, App.width)\n      self.I.y = self.I.y.clamp(0, App.height)\n      self.destroy()\n  \n  return self\n","filename":"missile.coffee"},"motor.coffee":{"content":"@Motor = (I={}) ->\n  Object.defaults I,\n    phaseOffset: 0 # Seconds\n    type: \"constant\"\n    switchCooldown: 0\n    switchDelay: 0.5\n    lastPower: 0\n\n  self = GameObject(I).extend\n    power: ->\n      if I.switchCooldown\n        # Don't switch\n        lastPower\n      else\n        I.switchCooldown += I.switchDelay\n\n      lastPower = switch I.type\n        when \"periodic\"\n          Math.sin((I.age + I.phaseOffset) * Math.TAU) + 0.5\n        when \"jittery\"\n          rand() * 0.5\n        when \"slow\"\n          0.5\n        else # constant\n          1\n\n  self.cooldown \"switchCooldown\"\n\n  return self\n\n@Motor.random = ->\n  [\n    {type: \"slow\"}\n    {type: \"constant\"}\n    {type: \"jittery\"}\n    {type: \"periodic\", phaseOffset: rand(), switchDelay: 0}\n  ].rand()\n","filename":"motor.coffee"},"navigation.coffee":{"content":"@Navigation = (I={}) ->\n  Object.defaults I,\n    type: \"facing\"\n    switchDelay: 2\n    switchCooldown: 0\n\n  self = GameObject(I).extend\n    navigate: (source) ->\n      if I.switchCooldown\n        # Don't switch\n      else\n        I.switchCooldown += I.switchDelay\n\n        switch I.type\n          when \"random\"\n            rand() * Math.TAU\n          when \"spiral\"\n            10 * Math.log(source.I.age/10 + 1) + source.I.headingInitial\n          when \"strafe\"\n            if rand() > 0.5\n              source.I.facing + 0.25.turns\n            else\n              source.I.facing - 0.25.turns\n          else # facing\n            source.I.facing\n\n  self.cooldown \"switchCooldown\"\n\n  return self\n\n@Navigation.random = ->\n  [\n    {type: \"facing\"}\n    {type: \"spiral\", switchDelay: 0.25}\n    {type: \"random\"}\n    {type: \"strafe\"}\n  ].rand()\n","filename":"navigation.coffee"},"pixie.json":{"content":"{\n  \"width\": 800,\n  \"height\": 450\n}\n","filename":"pixie.json"},"pixie_canvas.coffee":{"content":"`!function(){var __slice=[].slice;!function($){Number.prototype.clamp=function(min,max){return Math.min(Math.max(min,this),max)};Math.TAU=2*Math.PI;return $.fn.pixieCanvas=function(options){var $canvas,canvas,canvasAttrAccessor,context,contextAttrAccessor;if(options==null){options={}}canvas=this.get(0);context=void 0;$canvas=$.extend($(canvas),{withTransform:function(matrix,block){context.save();context.transform(matrix.a,matrix.b,matrix.c,matrix.d,matrix.tx,matrix.ty);try{block(this)}finally{context.restore()}return this},clear:function(_arg){var height,width,x,y,_ref;_ref=_arg!=null?_arg:{},x=_ref.x,y=_ref.y,width=_ref.width,height=_ref.height;if(x==null){x=0}if(y==null){y=0}if(width==null){width=canvas.width}if(height==null){height=canvas.height}context.clearRect(x,y,width,height);return this},fill:function(color){var bounds,height,width,x,y,_ref;if(color==null){color={}}if(!(typeof color===\"string\"||color.channels)){_ref=color,x=_ref.x,y=_ref.y,width=_ref.width,height=_ref.height,bounds=_ref.bounds,color=_ref.color}if(bounds){x=bounds.x,y=bounds.y,width=bounds.width,height=bounds.height}x||(x=0);y||(y=0);if(width==null){width=canvas.width}if(height==null){height=canvas.height}this.fillColor(color);context.fillRect(x,y,width,height);return this},drawImage:function(){var args;args=1<=arguments.length?__slice.call(arguments,0):[];context.drawImage.apply(context,args);return this},drawCircle:function(_arg){var circle,color,position,radius,stroke,x,y;x=_arg.x,y=_arg.y,radius=_arg.radius,position=_arg.position,color=_arg.color,stroke=_arg.stroke,circle=_arg.circle;if(circle){x=circle.x,y=circle.y,radius=circle.radius}if(position){x=position.x,y=position.y}radius=radius.clamp(0,Infinity);context.beginPath();context.arc(x,y,radius,0,Math.TAU,true);context.closePath();if(color){this.fillColor(color);context.fill()}if(stroke){this.strokeColor(stroke.color);this.lineWidth(stroke.width);context.stroke()}return this},drawRect:function(_arg){var bounds,color,height,position,stroke,width,x,y;x=_arg.x,y=_arg.y,width=_arg.width,height=_arg.height,position=_arg.position,bounds=_arg.bounds,color=_arg.color,stroke=_arg.stroke;if(bounds){x=bounds.x,y=bounds.y,width=bounds.width,height=bounds.height}if(position){x=position.x,y=position.y}if(color){this.fillColor(color);context.fillRect(x,y,width,height)}if(stroke){this.strokeColor(stroke.color);this.lineWidth(stroke.width);context.strokeRect(x,y,width,height)}return this},drawLine:function(_arg){var color,direction,end,length,start,width;start=_arg.start,end=_arg.end,width=_arg.width,color=_arg.color,direction=_arg.direction,length=_arg.length;width||(width=3);if(direction){end=direction.norm(length).add(start)}this.lineWidth(width);this.strokeColor(color);context.beginPath();context.moveTo(start.x,start.y);context.lineTo(end.x,end.y);context.closePath();context.stroke();return this},drawPoly:function(_arg){var color,points,stroke;points=_arg.points,color=_arg.color,stroke=_arg.stroke;context.beginPath();points.forEach(function(point,i){if(i===0){return context.moveTo(point.x,point.y)}else{return context.lineTo(point.x,point.y)}});context.lineTo(points[0].x,points[0].y);if(color){this.fillColor(color);context.fill()}if(stroke){this.strokeColor(stroke.color);this.lineWidth(stroke.width);context.stroke()}return this},drawRoundRect:function(_arg){var bounds,color,height,position,radius,stroke,width,x,y;x=_arg.x,y=_arg.y,width=_arg.width,height=_arg.height,radius=_arg.radius,position=_arg.position,bounds=_arg.bounds,color=_arg.color,stroke=_arg.stroke;if(radius==null){radius=5}if(bounds){x=bounds.x,y=bounds.y,width=bounds.width,height=bounds.height}if(position){x=position.x,y=position.y}context.beginPath();context.moveTo(x+radius,y);context.lineTo(x+width-radius,y);context.quadraticCurveTo(x+width,y,x+width,y+radius);context.lineTo(x+width,y+height-radius);context.quadraticCurveTo(x+width,y+height,x+width-radius,y+height);context.lineTo(x+radius,y+height);context.quadraticCurveTo(x,y+height,x,y+height-radius);context.lineTo(x,y+radius);context.quadraticCurveTo(x,y,x+radius,y);context.closePath();if(color){this.fillColor(color);context.fill()}if(stroke){this.lineWidth(stroke.width);this.strokeColor(stroke.color);context.stroke()}return this},drawText:function(_arg){var color,font,position,text,x,y;x=_arg.x,y=_arg.y,text=_arg.text,position=_arg.position,color=_arg.color,font=_arg.font;if(position){x=position.x,y=position.y}this.fillColor(color);if(font){this.font(font)}context.fillText(text,x,y);return this},centerText:function(_arg){var color,font,position,text,textWidth,x,y;text=_arg.text,x=_arg.x,y=_arg.y,position=_arg.position,color=_arg.color,font=_arg.font;if(position){x=position.x,y=position.y}if(x==null){x=canvas.width/2}textWidth=this.measureText(text);return this.drawText({text:text,color:color,font:font,x:x-textWidth/2,y:y})},fillColor:function(color){if(color){if(color.channels){context.fillStyle=color.toString()}else{context.fillStyle=color}return this}else{return context.fillStyle}},strokeColor:function(color){if(color){if(color.channels){context.strokeStyle=color.toString()}else{context.strokeStyle=color}return this}else{return context.strokeStyle}},measureText:function(text){return context.measureText(text).width},putImageData:function(){var args;args=1<=arguments.length?__slice.call(arguments,0):[];context.putImageData.apply(context,args);return this},context:function(){return context},element:function(){return canvas},createPattern:function(image,repitition){return context.createPattern(image,repitition)},clip:function(x,y,width,height){context.beginPath();context.rect(x,y,width,height);context.clip();return this}});contextAttrAccessor=function(){var attrs;attrs=1<=arguments.length?__slice.call(arguments,0):[];return attrs.forEach(function(attr){return $canvas[attr]=function(newVal){if(newVal!=null){context[attr]=newVal;return this}else{return context[attr]}}})};contextAttrAccessor(\"font\",\"globalAlpha\",\"globalCompositeOperation\",\"lineWidth\",\"textAlign\");canvasAttrAccessor=function(){var attrs;attrs=1<=arguments.length?__slice.call(arguments,0):[];return attrs.forEach(function(attr){return $canvas[attr]=function(newVal){if(newVal!=null){canvas[attr]=newVal;return this}else{return canvas[attr]}}})};canvasAttrAccessor(\"height\",\"width\");if(canvas!=null?canvas.getContext:void 0){context=canvas.getContext(\"2d\");if(options.init){options.init($canvas)}return $canvas}}}(typeof jQuery!==\"undefined\"&&jQuery!==null?jQuery:Zepto)}.call(this);`","filename":"pixie_canvas.coffee"},"point_defense.coffee":{"content":"@PointDefense = (I={}) ->\n  Object.defaults I,\n    color: \"purple\"\n    duration: 0.5\n    range: 300\n\n  self = GameObject(I)\n  \n  self.on \"update\", ->\n    closest = engine.find(\"Missile\").select (missile) ->      \n      missile.I.source.I.team != I.source.I.team\n      \n    .map (missile) ->\n      {\n        distance: Point.distance(self.position(), missile.position())\n        object: missile\n      }\n    .sort ({distance:a}, {distance:b}) ->\n      b - a\n    .first()\n    \n    if closest and closest.distance <= I.range\n      I.target = closest.object\n      \n      I.target.destroy()\n      self.destroy()\n\n  self.on \"destroy\", ->\n    engine.add \"Ray\",\n      start: I.source.position()\n      end: I.target.position()\n      color: I.color\n\n  return self\n","filename":"point_defense.coffee"},"ray.coffee":{"content":"@Ray = (I={}) ->\n  Object.defaults I,\n    duration: 0.25\n    \n  self = GameObject(I)\n  \n  self.on \"update\", ->\n    I.alpha = 1 - I.age / I.duration\n  \n  self.unbind \"draw\"\n  \n  self.bind \"draw\", (canvas) ->\n    canvas.drawLine\n      start: I.start\n      end: I.end\n      color: I.color\n\n  return self\n","filename":"ray.coffee"},"robot.coffee":{"content":"@Robot = (I={}) ->\n  Object.defaults I,\n    color: \"blue\"\n    width: 50\n    height: 50\n    speed: 100\n    name: \"Robot\"\n    heading: 0\n    headingInitial: 0\n    facing: 0\n    facingInitial: 0\n    health: 100\n    healthMax: 100\n    radius: 25 # For explosion collisions\n    team: 0\n    motors: [\n      Motor.random()\n    ]\n    navigation: Navigation.random()\n    targetting: Targetting.random()\n    weapons: [\n      Weapon.random()\n    ]\n\n  # Serializability\n  weapons = I.weapons.map Weapon\n  motors = I.motors.map Motor\n  navigation = Navigation I.navigation\n  targetting = Targetting I.targetting\n\n  self = GameObject(I)\n  \n  self.clampToBounds()\n    \n  meter = ->\n    healthRatio = I.health / I.healthMax\n    if healthRatio > 0.5\n      color = Color.mix(Color(\"green\"), Color(\"yellow\"), (healthRatio - 0.5) * 2)\n    else\n      color = Color.mix(Color(\"yellow\"), Color(\"red\"), healthRatio * 2)\n\n    self.meter \"health\",\n      color: color\n      x: I.x - I.width/2\n      y: I.y - I.height/2 - 20\n      width: I.width\n  \n  self.on \"update\", (elapsedTime) ->    \n    if I.health <= 0\n      self.destroy()\n\n    # Health Meter\n    meter()\n    \n    # Navigation\n    navigation.update(elapsedTime)\n    I.heading = navigation.navigate(self) or I.heading\n    \n    # Targetting\n    targetting.update(elapsedTime)\n    I.facing = targetting.target(self) or I.facing\n\n    # Motor\n    motors.invoke(\"update\", elapsedTime)\n    I.power = motors.invoke(\"power\").sum().clamp(0, 2)\n\n    # Weapons\n    # Apply cooldowns and fire\n    weapons.invoke(\"update\", elapsedTime)\n    weapons.invoke(\"fire\", self, elapsedTime) # TODO: Pass additional info?\n\n    # Apply Movement\n    I.velocity = Point.fromAngle(I.heading).scale(I.speed * I.power)\n\n  self.on \"afterUpdate\", (elapsedTime) ->\n    motors.invoke(\"trigger\", \"afterUpdate\", elapsedTime)\n\n  drawDebug = (canvas) ->\n    p = self.position()\n    \n    end = p.add(Point.fromAngle(I.facing).scale(40))\n    canvas.drawLine\n      start: p\n      end: end\n      color: \"rgb(255, 0, 255)\"\n      \n    end = p.add(Point.fromAngle(I.heading).scale(40))\n    canvas.drawLine\n      start: p\n      end: end\n      color: \"rgb(0, 255, 0)\"\n  \n  self.on \"draw\", (canvas) ->\n    canvas.font(\"bold 16px consolas, 'Courier New', 'andale mono', 'lucida console', monospace\")\n\n    canvas.centerText\n      color: \"white\"\n      x: 0\n      y: -I.height/2\n      text: I.name\n  \n  self.on \"overlay\", drawDebug\n\n  self.on \"destroy\", ->\n    engine.add \"Explosion\",\n      x: I.x\n      y: I.y\n\n  return self\n","filename":"robot.coffee"},"setup.coffee":{"content":"randomName = ->\n  prefix = [\n    \"Mr. \"\n    \"Dr. \"\n    \"Ms. \"\n    \"Mrs. \"\n    \"The \"\n    \"\"\n    \"\"\n    \"\"\n    \"\"\n    \"El \"\n    \"Lord \"\n    \"Lady \"\n    \"Duke \"\n    \"Duchess \"\n  ].rand()\n  \n  name = [\n    \"Donuts\"\n    \"BMO\"\n    \"Bacon\"\n    \"Duder\"\n    \"Dude\"\n    \"Hotdog\"\n    \"Squirtle\"\n    \"Killer\"\n    \"Ronnie\"\n    \"Joe\"\n    \"Stalin\"\n    \"Reginald\"\n    \"Toast\"\n    \"Margarine\"\n    \"Juice\"\n    \"Q\"\n    \"DP\"\n    \"Obama\"\n    \"Hitler\"\n    \"YOLO\"\n  ].rand()\n  \n  suffix = [\n    \" Jr\"\n    \" II\"\n    \" Sr\"\n    \" III\"\n    \" IV\"\n    \" of Death\"\n    \"\"\n    \"\"\n    \"\"\n    \"\"\n    \"\"\n    \"\"\n    \"\"\n    \"\"\n  ].rand()\n\n  \"#{prefix}#{name}#{suffix}\"\n\ndefaultBot = ->\n  bot = {name: randomName(), motors: [], weapons: [], targetting: null, navigation: null}\n\n  # TODO: OMG this blows\n  bot.oNavigation = Observable(\"\")\n  bot.oWeapons = Observable(\"\")\n  bot.oMotors = Observable(\"\")\n\n  return bot\n\ndefaultItem = ->\n  {type: \"default\"}\n\n@Setup = (I={}) ->\n  Object.defaults I,\n    robots: [\n      defaultBot()\n      defaultBot()\n      defaultBot()\n    ]\n    motors: [\n      Motor.random()\n      Motor.random()\n      Motor.random()\n      Motor.random()\n    ]\n    weapons: [\n      Weapon.random()\n      Weapon.random()\n      Weapon.random()\n      Weapon.random()\n    ]\n    targetting: [\n      Targetting.random()\n      Targetting.random()\n    ]\n    navigation: [\n      Navigation.random()\n      Navigation.random()\n      Navigation.random()\n    ]\n\n  activeRobot = I.robots.first()\n\n  removeFromArray = (item, slot) ->\n    I.robots.each (robot) ->\n      self[slot].remove(item)\n\n  add = (robot, item, slot) ->\n    if slot.lastIndexOf('s') is slot.length - 1\n      if robot[slot].length < 2\n        removeFromArray(item, slot)\n        robot[slot].push item\n    else\n      if robot[slot] is null\n        removeFromArray(item, slot)\n        robot[slot] = item\n\n    # Update stuff\n    I.robots.each (robot) ->      \n      robot.oMotors(robot.motors.map((m)->m.type.titleize()).join(\",\"))\n      robot.oWeapons(robot.weapons.map((w)->w.projectile.underscore().titleize()).join(\",\"))\n      robot.oNavigation(robot.navigation?.type.titleize() or \"\")\n\n  self = Model(I).extend\n    chooseItem: (item, slot) ->\n      add(activeRobot, item, slot)\n    chooseRobot: (robot) ->\n      activeRobot = robot\n  \n  self.observeAll()\n\n  return self\n","filename":"setup.coffee"},"setup.haml":{"content":".setup(style=\"background-image: url(http://a3.pixiecdn.com/f433296ce7b90ad0ccf61705b5eda754bb04af83)\")\n  .content-wrap\n    .content\n      .time 10.0\n\n      - {chooseRobot, chooseItem} = this\n\n      %ul.robots\n        - each @robots, (robot) ->\n          %li\n            %h3.name= robot.name\n            .weapons\n              %h4 Weapons\n              = robot.oWeapons\n            .motors\n              %h3 Motors\n              = robot.oMotors\n            .navigation\n              %h3 Navigation\n              = robot.oNavigation\n\n            - on \"click\", (e) ->\n              - $(\".robots li\").removeClass(\"selected\")\n              - $(e.currentTarget).addClass(\"selected\")\n              - chooseRobot(robot)\n\n      %ul.weapons\n        %li \n          %h3 Weapons\n        - each @weapons, (item) ->\n          %li\n            %button= item.projectile.underscore().titleize()\n              - on \"click\", ->\n                - chooseItem(item, \"weapons\")\n\n      %ul.motors\n        %li\n          %h3 Motors\n        - each @motors, (item) ->\n          %li\n            %button= item.type.titleize()\n              - on \"click\", ->\n                - chooseItem(item, \"motors\")\n\n      %ul.navigation\n        %li \n          %h3 Navigation\n        - each @navigation, (item) ->\n          %li\n            %button= item.type\n              - on \"click\", ->\n                - chooseItem(item, \"navigation\")\n","filename":"setup.haml"},"shank.js":{"content":"// Generated by CoffeeScript 1.6.3\n/**\nThe <code>Gamepads</code> module gives the engine access to gamepads.\n\n    # First you need to add the `Gamepads` module to the engine\n    Engine.defaultModules.push \"Gamepads\"\n    \n    window.engine = Engine\n      ...\n    \n    # Then you need to get a controller reference\n    # id = 0 for player 1, etc.\n    controller = engine.controller(id)\n    \n    # Point indicating direction primary axis is held\n    direction = controller.position()\n    \n    # Check if buttons are held\n    controller.actionDown(\"A\")\n    controller.actionDown(\"B\")\n    controller.actionDown(\"X\")\n    controller.actionDown(\"Y\")\n\n@name Gamepads\n@fieldOf Engine\n@module\n\n@param {Object} I Instance variables\n@param {Object} self Reference to the engine\n*/\n\n\n(function() {\n  var Gamepads,\n    __slice = [].slice;\n\n  Engine.Gamepads = function(I, self) {\n    var gamepads;\n    gamepads = Gamepads();\n    self.bind(\"beforeUpdate\", function() {\n      return gamepads.update();\n    });\n    return {\n      /**\n      Get a controller for a given id.\n      \n      @name controller\n      @methodOf Engine.Gamepads#\n      \n      @param {Number} index The index to get a controller for.\n      */\n\n      controller: function(index) {\n        return gamepads.controller(index);\n      }\n    };\n  };\n\n  /**\n  This error handler captures any runtime errors and reports them to the IDE\n  if present.\n  */\n\n\n  window.onerror = function(message, url, lineNumber) {\n    var errorContext;\n    errorContext = $('script').last().text().split('\\n').slice(lineNumber - 5, +(lineNumber + 4) + 1 || 9e9);\n    errorContext[4] = \"<b style='font-weight: bold; text-decoration: underline;'>\" + errorContext[4] + \"</b>\";\n    return typeof displayRuntimeError === \"function\" ? displayRuntimeError(\"<code>\" + message + \"</code> <br /><br />(Sometimes this context may be wrong.)<br /><code><pre>\" + (errorContext.join('\\n')) + \"</pre></code>\") : void 0;\n  };\n\n  Gamepads = function(I) {\n    var controllers, snapshot, state;\n    if (I == null) {\n      I = {};\n    }\n    state = {};\n    controllers = [];\n    snapshot = function() {\n      return Array.prototype.map.call(navigator.webkitGamepads || (typeof navigator.webkitGetGamepads === \"function\" ? navigator.webkitGetGamepads() : void 0) || [], function(x) {\n        return {\n          axes: x.axes,\n          buttons: x.buttons\n        };\n      });\n    };\n    return {\n      controller: function(index) {\n        var controller, gamepad, gamepadIndex, keyboardController;\n        if (index == null) {\n          index = 0;\n        }\n        if (controller = controllers[index]) {\n          return controller;\n        }\n        gamepadIndex = index;\n        gamepad = Gamepads.Controller({\n          index: gamepadIndex,\n          state: state\n        });\n        if (index === 0) {\n          keyboardController = Gamepads.KeyboardController();\n          return controllers[index] || (controllers[index] = Gamepads.CombinedController(gamepad, keyboardController));\n        } else {\n          return controllers[index] || (controllers[index] = gamepad);\n        }\n      },\n      update: function() {\n        state.previous = state.current;\n        state.current = snapshot();\n        return controllers.each(function(controller) {\n          return controller != null ? controller.update() : void 0;\n        });\n      }\n    };\n  };\n\n  Gamepads.CombinedController = function() {\n    var self, sources;\n    sources = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return self = Core().extend({\n      buttonDown: function() {\n        var buttons;\n        buttons = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return sources.inject(false, function(memo, source) {\n          return memo || source.buttonDown.apply(source, buttons);\n        });\n      },\n      buttonPressed: function(button) {\n        return sources.inject(false, function(memo, source) {\n          return memo || source.buttonPressed(button);\n        });\n      },\n      buttonReleased: function(button) {\n        return sources.inject(false, function(memo, source) {\n          return memo || source.buttonPressed(button);\n        });\n      },\n      position: function(stick) {\n        var raw;\n        if (stick == null) {\n          stick = 0;\n        }\n        raw = sources.inject(Point(0, 0), function(point, source) {\n          return point.add(source.position(stick));\n        });\n        if (raw.length() > 1) {\n          return raw.norm();\n        } else {\n          return raw;\n        }\n      },\n      tap: function() {\n        var raw;\n        raw = sources.inject(Point(0, 0), function(point, source) {\n          return point.add(source.tap());\n        });\n        return Point(raw.x.sign(), raw.y.sign());\n      },\n      update: function() {\n        return sources.invoke(\"update\");\n      },\n      drawDebug: function(canvas) {\n        return sources.invoke(\"drawDebug\", canvas);\n      }\n    });\n  };\n\n  Gamepads.Controller = function(I) {\n    var AXIS_MAX, BUTTON_THRESHOLD, DEAD_ZONE, MAX_BUFFER, TRIP_HIGH, TRIP_LOW, axisTrips, buttonMapping, currentState, previousState, processTaps, self, tap;\n    if (I == null) {\n      I = {};\n    }\n    Object.reverseMerge(I, {\n      debugColor: \"#000\"\n    });\n    MAX_BUFFER = 0.03;\n    AXIS_MAX = 1 - MAX_BUFFER;\n    DEAD_ZONE = AXIS_MAX * 0.25;\n    TRIP_HIGH = AXIS_MAX * 0.75;\n    TRIP_LOW = AXIS_MAX * 0.5;\n    BUTTON_THRESHOLD = 0.5;\n    buttonMapping = {\n      \"A\": 0,\n      \"B\": 1,\n      \"X\": 2,\n      \"Y\": 3,\n      \"LB\": 4,\n      \"RB\": 5,\n      \"LT\": 6,\n      \"RT\": 7,\n      \"SELECT\": 8,\n      \"BACK\": 8,\n      \"START\": 9,\n      \"TL\": 10,\n      \"TR\": 11,\n      \"HOME\": 16\n    };\n    currentState = function() {\n      var _ref;\n      return (_ref = I.state.current) != null ? _ref[I.index] : void 0;\n    };\n    previousState = function() {\n      var _ref;\n      return (_ref = I.state.previous) != null ? _ref[I.index] : void 0;\n    };\n    axisTrips = [];\n    tap = Point(0, 0);\n    processTaps = function() {\n      var x, y, _ref;\n      _ref = [0, 1].map(function(n) {\n        if (!axisTrips[n] && self.axis(n).abs() > TRIP_HIGH) {\n          axisTrips[n] = true;\n          return self.axis(n).sign();\n        }\n        if (axisTrips[n] && self.axis(n).abs() < TRIP_LOW) {\n          axisTrips[n] = false;\n        }\n        return 0;\n      }), x = _ref[0], y = _ref[1];\n      return tap = Point(x, y);\n    };\n    return self = Core().include(Bindable).extend({\n      buttonDown: function() {\n        var buttons, state;\n        buttons = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        if (state = currentState()) {\n          return buttons.inject(false, function(down, button) {\n            return down || (button === \"ANY\" ? state.buttons.inject(false, function(down, button) {\n              return down || (button > BUTTON_THRESHOLD);\n            }) : state.buttons[buttonMapping[button]] > BUTTON_THRESHOLD);\n          });\n        } else {\n          return false;\n        }\n      },\n      buttonPressed: function(button) {\n        var buttonId, _ref;\n        buttonId = buttonMapping[button];\n        return (self.buttons()[buttonId] > BUTTON_THRESHOLD) && !(((_ref = previousState()) != null ? _ref.buttons[buttonId] : void 0) > BUTTON_THRESHOLD);\n      },\n      buttonReleased: function(button) {\n        var buttonId, _ref;\n        buttonId = buttonMapping[button];\n        return !(self.buttons()[buttonId] > BUTTON_THRESHOLD) && (((_ref = previousState()) != null ? _ref.buttons[buttonId] : void 0) > BUTTON_THRESHOLD);\n      },\n      position: function(stick) {\n        var magnitude, p, ratio, state;\n        if (stick == null) {\n          stick = 0;\n        }\n        if (state = currentState()) {\n          p = Point(self.axis(2 * stick), self.axis(2 * stick + 1));\n          magnitude = p.magnitude();\n          if (magnitude > AXIS_MAX) {\n            return p.norm();\n          } else if (magnitude < DEAD_ZONE) {\n            return Point(0, 0);\n          } else {\n            ratio = magnitude / AXIS_MAX;\n            return p.scale(ratio / AXIS_MAX);\n          }\n        } else {\n          return Point(0, 0);\n        }\n      },\n      axis: function(n) {\n        return self.axes()[n] || 0;\n      },\n      axes: function() {\n        var state;\n        if (state = currentState()) {\n          return state.axes;\n        } else {\n          return [];\n        }\n      },\n      buttons: function() {\n        var state;\n        if (state = currentState()) {\n          return state.buttons;\n        } else {\n          return [];\n        }\n      },\n      tap: function() {\n        return tap;\n      },\n      update: function() {\n        return processTaps();\n      },\n      drawDebug: function(canvas) {\n        var lineHeight;\n        lineHeight = 18;\n        self.axes().each(function(axis, i) {\n          return canvas.drawText({\n            color: I.debugColor,\n            text: axis,\n            x: 0,\n            y: (i + 1) * lineHeight\n          });\n        });\n        return self.buttons().each(function(button, i) {\n          canvas.drawText({\n            color: I.debugColor,\n            text: \"\" + i + \":\",\n            x: 230,\n            y: (i + 1) * lineHeight\n          });\n          return canvas.drawText({\n            color: I.debugColor,\n            text: button,\n            x: 250,\n            y: (i + 1) * lineHeight\n          });\n        });\n      }\n    });\n  };\n\n  Gamepads.KeyboardController = function(I) {\n    var buttonKeys, buttonValues, processTaps, self, tap;\n    if (I == null) {\n      I = {};\n    }\n    Object.reverseMerge(I, {\n      axisMapping: [[\"left\", \"right\"], [\"up\", \"down\"]],\n      buttonMapping: {\n        \"A\": 'z',\n        \"B\": 'x',\n        \"C\": 'c',\n        \"D\": 'v',\n        \"X\": 'c',\n        \"Y\": 'v',\n        \"SELECT\": \"shift\",\n        \"START\": \"return\"\n      },\n      debugColor: \"#000\"\n    });\n    tap = Point(0, 0);\n    buttonKeys = Object.keys(I.buttonMapping);\n    buttonValues = buttonKeys.map(function(key) {\n      return I.buttonMapping[key];\n    });\n    I.axisMapping.each(function(axis) {\n      return axis.each(function(key) {\n        return keydown[key] = false;\n      });\n    });\n    buttonKeys.each(function(key) {\n      return keydown[key] = false;\n    });\n    processTaps = function() {\n      var x, y, _ref;\n      _ref = I.axisMapping.map(function(_arg) {\n        var negative, positive;\n        negative = _arg[0], positive = _arg[1];\n        return justPressed[positive] - justPressed[negative];\n      }), x = _ref[0], y = _ref[1];\n      return tap = Point(x, y);\n    };\n    return self = Core().include(Bindable).extend({\n      buttonDown: function() {\n        var buttons;\n        buttons = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return buttons.inject(false, function(down, button) {\n          return down || (button === \"ANY\" ? buttonValues.inject(false, function(down, button) {\n            return down || keydown[button];\n          }) : keydown[I.buttonMapping[button]]);\n        });\n      },\n      buttonPressed: function(button) {\n        var keyname;\n        keyname = I.buttonMapping[button];\n        return justPressed[keyname];\n      },\n      buttonReleased: function(button) {\n        var keyname;\n        keyname = I.buttonMapping[button];\n        return justReleased[keyname];\n      },\n      position: function(stick) {\n        var x, y, _ref;\n        if (stick == null) {\n          stick = 0;\n        }\n        _ref = I.axisMapping.map(function(_arg) {\n          var negative, positive;\n          negative = _arg[0], positive = _arg[1];\n          return keydown[positive] - keydown[negative];\n        }), x = _ref[0], y = _ref[1];\n        return tap = Point(x, y);\n      },\n      tap: function() {\n        return tap;\n      },\n      update: function() {\n        return processTaps();\n      },\n      drawDebug: function(canvas) {\n        var lineHeight, p;\n        lineHeight = 18;\n        p = self.position();\n        [\"x\", \"y\"].each(function(key, i) {\n          return canvas.drawText({\n            color: I.debugColor,\n            text: p[key],\n            x: 0,\n            y: i * lineHeight\n          });\n        });\n        return buttonKeys.each(function(button, i) {\n          return canvas.drawText({\n            color: I.debugColor,\n            text: self.buttonDown(button),\n            x: 250,\n            y: i * lineHeight\n          });\n        });\n      }\n    });\n  };\n\n  document.oncontextmenu = function() {\n    return false;\n  };\n\n  $(document).bind(\"keydown\", function(event) {\n    if (!$(event.target).is(\"input\")) {\n      return event.preventDefault();\n    }\n  });\n\n  /**\n  jQuery Hotkeys Plugin\n  Copyright 2010, John Resig\n  Dual licensed under the MIT or GPL Version 2 licenses.\n  \n  Based upon the plugin by Tzury Bar Yochay:\n  http://github.com/tzuryby/hotkeys\n  \n  Original idea by:\n  Binny V A, http://www.openjs.com/scripts/events/keyboard_shortcuts/\n  */\n\n\n  (function(jQuery) {\n    var isFunctionKey, isTextAcceptingInput, keyHandler;\n    isTextAcceptingInput = function(element) {\n      return /textarea|select/i.test(element.nodeName) || element.type === \"text\" || element.type === \"password\";\n    };\n    isFunctionKey = function(event) {\n      var _ref;\n      return (event.type !== \"keypress\") && ((112 <= (_ref = event.which) && _ref <= 123));\n    };\n    jQuery.hotkeys = {\n      version: \"0.8\",\n      specialKeys: {\n        8: \"backspace\",\n        9: \"tab\",\n        13: \"return\",\n        16: \"shift\",\n        17: \"ctrl\",\n        18: \"alt\",\n        19: \"pause\",\n        20: \"capslock\",\n        27: \"esc\",\n        32: \"space\",\n        33: \"pageup\",\n        34: \"pagedown\",\n        35: \"end\",\n        36: \"home\",\n        37: \"left\",\n        38: \"up\",\n        39: \"right\",\n        40: \"down\",\n        45: \"insert\",\n        46: \"del\",\n        96: \"0\",\n        97: \"1\",\n        98: \"2\",\n        99: \"3\",\n        100: \"4\",\n        101: \"5\",\n        102: \"6\",\n        103: \"7\",\n        104: \"8\",\n        105: \"9\",\n        106: \"*\",\n        107: \"+\",\n        109: \"-\",\n        110: \".\",\n        111: \"/\",\n        112: \"f1\",\n        113: \"f2\",\n        114: \"f3\",\n        115: \"f4\",\n        116: \"f5\",\n        117: \"f6\",\n        118: \"f7\",\n        119: \"f8\",\n        120: \"f9\",\n        121: \"f10\",\n        122: \"f11\",\n        123: \"f12\",\n        144: \"numlock\",\n        145: \"scroll\",\n        186: \";\",\n        187: \"=\",\n        188: \",\",\n        189: \"-\",\n        190: \".\",\n        191: \"/\",\n        219: \"[\",\n        220: \"\\\\\",\n        221: \"]\",\n        222: \"'\",\n        224: \"meta\"\n      },\n      shiftNums: {\n        \"`\": \"~\",\n        \"1\": \"!\",\n        \"2\": \"@\",\n        \"3\": \"#\",\n        \"4\": \"$\",\n        \"5\": \"%\",\n        \"6\": \"^\",\n        \"7\": \"&\",\n        \"8\": \"*\",\n        \"9\": \"(\",\n        \"0\": \")\",\n        \"-\": \"_\",\n        \"=\": \"+\",\n        \";\": \":\",\n        \"'\": \"\\\"\",\n        \",\": \"<\",\n        \".\": \">\",\n        \"/\": \"?\",\n        \"\\\\\": \"|\"\n      }\n    };\n    keyHandler = function(handleObj) {\n      var keys, origHandler;\n      if (typeof handleObj.data !== \"string\") {\n        return;\n      }\n      origHandler = handleObj.handler;\n      keys = handleObj.data.toLowerCase().split(\" \");\n      return handleObj.handler = function(event) {\n        var character, key, modif, possible, special, target, _i, _len;\n        special = event.type !== \"keypress\" && jQuery.hotkeys.specialKeys[event.which];\n        character = String.fromCharCode(event.which).toLowerCase();\n        modif = \"\";\n        possible = {};\n        target = event.target;\n        if (event.altKey && special !== \"alt\") {\n          modif += \"alt+\";\n        }\n        if (event.ctrlKey && special !== \"ctrl\") {\n          modif += \"ctrl+\";\n        }\n        if (event.metaKey && !event.ctrlKey && special !== \"meta\") {\n          modif += \"meta+\";\n        }\n        if (this !== target) {\n          if (isTextAcceptingInput(target) && !modif && !isFunctionKey(event)) {\n            return;\n          }\n        }\n        if (event.shiftKey && special !== \"shift\") {\n          modif += \"shift+\";\n        }\n        if (special) {\n          possible[modif + special] = true;\n        } else {\n          possible[modif + character] = true;\n          possible[modif + jQuery.hotkeys.shiftNums[character]] = true;\n          if (modif === \"shift+\") {\n            possible[jQuery.hotkeys.shiftNums[character]] = true;\n          }\n        }\n        for (_i = 0, _len = keys.length; _i < _len; _i++) {\n          key = keys[_i];\n          if (possible[key]) {\n            return origHandler.apply(this, arguments);\n          }\n        }\n      };\n    };\n    return jQuery.each([\"keydown\", \"keyup\", \"keypress\"], function() {\n      return jQuery.event.special[this] = {\n        add: keyHandler\n      };\n    });\n  })(jQuery);\n\n  $(function() {\n    /**\n    The global keydown property lets your query the status of keys.\n    \n    <code><pre>\n    if keydown.left\n      moveLeft()\n    \n    if keydown.a or keydown.space\n      attack()\n    \n    if keydown.return\n      confirm()\n    \n    if keydown.esc\n      cancel()\n    </pre></code>\n    \n    @name keydown\n    @namespace\n    */\n\n    /**\n    The global justPressed property lets your query the status of keys. However,\n    unlike keydown it will only trigger once for each time the key is pressed.\n    \n    <code><pre>\n    if justPressed.left\n      moveLeft()\n    \n    if justPressed.a or justPressed.space\n      attack()\n    \n    if justPressed.return\n      confirm()\n    \n    if justPressed.esc\n      cancel()\n    </pre></code>\n    \n    @name justPressed\n    @namespace\n    */\n\n    var keyName, prevKeysDown;\n    window.keydown = {};\n    window.justPressed = {};\n    window.justReleased = {};\n    prevKeysDown = {};\n    keyName = function(event) {\n      return jQuery.hotkeys.specialKeys[event.which] || String.fromCharCode(event.which).toLowerCase();\n    };\n    $(document).bind(\"keydown\", function(event) {\n      var key;\n      key = keyName(event);\n      return keydown[key] = true;\n    });\n    $(document).bind(\"keyup\", function(event) {\n      var key;\n      key = keyName(event);\n      return keydown[key] = false;\n    });\n    return window.updateKeys = function() {\n      var key, value, _results;\n      window.justPressed = {};\n      window.justReleased = {};\n      keydown.any = false;\n      for (key in keydown) {\n        value = keydown[key];\n        justPressed[key] = value && !prevKeysDown[key];\n        justReleased[key] = !value && prevKeysDown[key];\n        if (justPressed[key] || mousePressed.left || mousePressed.right) {\n          justPressed.any = true;\n        }\n        if (value || mouseDown.left || mouseDown.right) {\n          keydown.any = true;\n        }\n      }\n      prevKeysDown = {};\n      _results = [];\n      for (key in keydown) {\n        value = keydown[key];\n        _results.push(prevKeysDown[key] = value);\n      }\n      return _results;\n    };\n  });\n\n  $(function() {\n    /**\n    The global mouseDown property lets your query the status of mouse buttons.\n    \n    <code><pre>\n    if mouseDown.left\n      moveLeft()\n    \n    if mouseDown.right\n      attack()\n    </pre></code>\n    \n    @name mouseDown\n    @namespace\n    */\n\n    /**\n    The global mousePressed property lets your query the status of mouse buttons.\n    However, unlike mouseDown it will only trigger the first time the button\n    pressed.\n    \n    <code><pre>\n    if mousePressed.left\n      moveLeft()\n    \n    if mousePressed.right\n      attack()\n    </pre></code>\n    \n    @name mousePressed\n    @namespace\n    */\n\n    var buttonName, buttonNames, prevButtonsDown;\n    window.mouseDown = {};\n    window.mousePressed = {};\n    window.mouseReleased = {};\n    window.mousePosition = Point(0, 0);\n    prevButtonsDown = {};\n    buttonNames = {\n      1: \"left\",\n      2: \"middle\",\n      3: \"right\"\n    };\n    buttonName = function(event) {\n      return buttonNames[event.which];\n    };\n    $(document).bind(\"mousemove\", function(event) {\n      var offset;\n      offset = $(\"canvas\").offset();\n      mousePosition.x = event.pageX - offset.left;\n      return mousePosition.y = event.pageY - offset.top;\n    });\n    $(document).bind(\"mousedown\", function(event) {\n      return mouseDown[buttonName(event)] = true;\n    });\n    $(document).bind(\"mouseup\", function(event) {\n      return mouseDown[buttonName(event)] = false;\n    });\n    return window.updateMouse = function() {\n      var button, value, _results;\n      window.mousePressed = {};\n      window.mouseReleased = {};\n      for (button in mouseDown) {\n        value = mouseDown[button];\n        if (!prevButtonsDown[button]) {\n          mousePressed[button] = value;\n        }\n      }\n      for (button in mouseDown) {\n        value = mouseDown[button];\n        if (prevButtonsDown[button]) {\n          mouseReleased[button] = !value;\n        }\n      }\n      prevButtonsDown = {};\n      _results = [];\n      for (button in mouseDown) {\n        value = mouseDown[button];\n        _results.push(prevButtonsDown[button] = value);\n      }\n      return _results;\n    };\n  });\n\n  (function($) {\n    return $.fn.pixieCanvas = function(options) {\n      var $canvas, canvas, canvasAttrAccessor, context, contextAttrAccessor;\n      if (options == null) {\n        options = {};\n      }\n      canvas = this.get(0);\n      context = void 0;\n      /**\n      PixieCanvas provides a convenient wrapper for working with Context2d.\n      \n      Methods try to be as flexible as possible as to what arguments they take.\n      \n      Non-getter methods return `this` for method chaining.\n      \n      @name PixieCanvas\n      @constructor\n      */\n\n      $canvas = $(canvas).extend({\n        /**\n        Passes this canvas to the block with the given matrix transformation\n        applied. All drawing methods called within the block will draw\n        into the canvas with the transformation applied. The transformation\n        is removed at the end of the block, even if the block throws an error.\n        \n        @name withTransform\n        @methodOf PixieCanvas#\n        \n        @param {Matrix} matrix\n        @param {Function} block\n        \n        @returns {PixieCanvas} this\n        */\n\n        withTransform: function(matrix, block) {\n          context.save();\n          context.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n          try {\n            block(this);\n          } finally {\n            context.restore();\n          }\n          return this;\n        },\n        /**\n        Clear the canvas (or a portion of it).\n        \n        Clear the entire canvas\n        \n        <code><pre>\n        canvas.clear()\n        </pre></code>\n        \n        Clear a portion of the canvas\n        \n        <code class=\"run\"><pre>\n        # Set up: Fill canvas with blue\n        canvas.fill(\"blue\")\n        \n        # Clear a portion of the canvas\n        canvas.clear\n          x: 50\n          y: 50\n          width: 50\n          height: 50\n        </pre></code>\n        \n        You can also clear the canvas by passing x, y, width height as\n        unnamed parameters:\n        \n        <code><pre>\n        canvas.clear(25, 25, 50, 50)\n        </pre></code>\n        \n        @name clear\n        @methodOf PixieCanvas#\n        \n        @param {Number} [x] where to start clearing on the x axis\n        @param {Number} [y] where to start clearing on the y axis\n        @param {Number} [width] width of area to clear\n        @param {Number} [height] height of area to clear\n        \n        @returns {PixieCanvas} this\n        */\n\n        clear: function(x, y, width, height) {\n          var _ref;\n          if (x == null) {\n            x = {};\n          }\n          if (y == null) {\n            _ref = x, x = _ref.x, y = _ref.y, width = _ref.width, height = _ref.height;\n          }\n          x || (x = 0);\n          y || (y = 0);\n          if (width == null) {\n            width = canvas.width;\n          }\n          if (height == null) {\n            height = canvas.height;\n          }\n          context.clearRect(x, y, width, height);\n          return this;\n        },\n        /**\n        Fills the entire canvas (or a specified section of it) with\n        the given color.\n        \n        <code class=\"run\"><pre>\n        # Paint the town (entire canvas) red\n        canvas.fill \"red\"\n        \n        # Fill a section of the canvas white (#FFF)\n        canvas.fill\n          x: 50\n          y: 50\n          width: 50\n          height: 50\n          color: \"#FFF\"\n        </pre></code>\n        \n        @name fill\n        @methodOf PixieCanvas#\n        \n        @param {Number} [x=0] Optional x position to fill from\n        @param {Number} [y=0] Optional y position to fill from\n        @param {Number} [width=canvas.width] Optional width of area to fill\n        @param {Number} [height=canvas.height] Optional height of area to fill\n        @param {Bounds} [bounds] bounds object to fill\n        @param {String|Color} [color] color of area to fill\n        \n        @returns {PixieCanvas} this\n        */\n\n        fill: function(color) {\n          var bounds, height, width, x, y, _ref;\n          if (color == null) {\n            color = {};\n          }\n          if (!((typeof color.isString === \"function\" ? color.isString() : void 0) || color.channels)) {\n            _ref = color, x = _ref.x, y = _ref.y, width = _ref.width, height = _ref.height, bounds = _ref.bounds, color = _ref.color;\n          }\n          if (bounds) {\n            x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height;\n          }\n          x || (x = 0);\n          y || (y = 0);\n          if (width == null) {\n            width = canvas.width;\n          }\n          if (height == null) {\n            height = canvas.height;\n          }\n          this.fillColor(color);\n          context.fillRect(x, y, width, height);\n          return this;\n        },\n        /**\n        A direct map to the Context2d draw image. `GameObject`s\n        that implement drawable will have this wrapped up nicely,\n        so there is a good chance that you will not have to deal with\n        it directly.\n        \n        @name drawImage\n        @methodOf PixieCanvas#\n        \n        @param image\n        @param {Number} sx\n        @param {Number} sy\n        @param {Number} sWidth\n        @param {Number} sHeight\n        @param {Number} dx\n        @param {Number} dy\n        @param {Number} dWidth\n        @param {Number} dHeight\n        \n        @returns {PixieCanvas} this\n        */\n\n        drawImage: function(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {\n          context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n          return this;\n        },\n        /**\n        Draws a circle at the specified position with the specified\n        radius and color.\n        \n        <code class=\"run\"><pre>\n        # Draw a large orange circle\n        canvas.drawCircle\n          radius: 30\n          position: Point(100, 75)\n          color: \"orange\"\n        \n        # Draw a blue circle with radius 10 at (25, 50)\n        # and a red stroke\n        canvas.drawCircle\n          x: 25\n          y: 50\n          radius: 10\n          color: \"blue\"\n          stroke:\n            color: \"red\"\n            width: 1\n        \n        # Create a circle object to set up the next examples\n        circle =\n          radius: 20\n          x: 50\n          y: 50\n        \n        # Draw a given circle in yellow\n        canvas.drawCircle\n          circle: circle\n          color: \"yellow\"\n        \n        # Draw the circle in green at a different position\n        canvas.drawCircle\n          circle: circle\n          position: Point(25, 75)\n          color: \"green\"\n        \n        # Draw an outline circle in purple.\n        canvas.drawCircle\n          x: 50\n          y: 75\n          radius: 10\n          stroke:\n            color: \"purple\"\n            width: 2\n        </pre></code>\n        \n        @name drawCircle\n        @methodOf PixieCanvas#\n        \n        @param {Number} [x] location on the x axis to start drawing\n        @param {Number} [y] location on the y axis to start drawing\n        @param {Point} [position] position object of location to start drawing. This will override x and y values passed\n        @param {Number} [radius] length of the radius of the circle\n        @param {Color|String} [color] color of the circle\n        @param {Circle} [circle] circle object that contains position and radius. Overrides x, y, and radius if passed\n        @param {Stroke} [stroke] stroke object that specifies stroke color and stroke width\n        \n        @returns {PixieCanvas} this\n        */\n\n        drawCircle: function(_arg) {\n          var circle, color, position, radius, stroke, x, y;\n          x = _arg.x, y = _arg.y, radius = _arg.radius, position = _arg.position, color = _arg.color, stroke = _arg.stroke, circle = _arg.circle;\n          if (circle) {\n            x = circle.x, y = circle.y, radius = circle.radius;\n          }\n          if (position) {\n            x = position.x, y = position.y;\n          }\n          radius = radius.clamp(0, Infinity);\n          context.beginPath();\n          context.arc(x, y, radius, 0, Math.TAU, true);\n          context.closePath();\n          if (color) {\n            this.fillColor(color);\n            context.fill();\n          }\n          if (stroke) {\n            this.strokeColor(stroke.color);\n            this.lineWidth(stroke.width);\n            context.stroke();\n          }\n          return this;\n        },\n        /**\n        Draws a rectangle at the specified position with given\n        width and height. Optionally takes a position, bounds\n        and color argument.\n        \n        <code class=\"run\"><pre>\n        # Draw a red rectangle using x, y, width and height\n        canvas.drawRect\n          x: 50\n          y: 50\n          width: 50\n          height: 50\n          color: \"#F00\"\n        \n        # Draw a blue rectangle using position, width and height\n        # and throw in a stroke for good measure\n        canvas.drawRect\n          position: Point(0, 0)\n          width: 50\n          height: 50\n          color: \"blue\"\n          stroke:\n            color: \"orange\"\n            width: 3\n        \n        # Set up a bounds object for the next examples\n        bounds =\n          x: 100\n          y: 0\n          width: 100\n          height: 100\n        \n        # Draw a purple rectangle using bounds\n        canvas.drawRect\n          bounds: bounds\n          color: \"green\"\n        \n        # Draw the outline of the same bounds, but at a different position\n        canvas.drawRect\n          bounds: bounds\n          position: Point(0, 50)\n          stroke:\n            color: \"purple\"\n            width: 2\n        </pre></code>\n        \n        @name drawRect\n        @methodOf PixieCanvas#\n        \n        @param {Number} [x] location on the x axis to start drawing\n        @param {Number} [y] location on the y axis to start drawing\n        @param {Number} [width] width of rectangle to draw\n        @param {Number} [height] height of rectangle to draw\n        @param {Point} [position] position to start drawing. Overrides x and y if passed\n        @param {Color|String} [color] color of rectangle\n        @param {Bounds} [bounds] bounds of rectangle. Overrides x, y, width, height if passed\n        @param {Stroke} [stroke] stroke object that specifies stroke color and stroke width\n        \n        @returns {PixieCanvas} this\n        */\n\n        drawRect: function(_arg) {\n          var bounds, color, height, position, stroke, width, x, y;\n          x = _arg.x, y = _arg.y, width = _arg.width, height = _arg.height, position = _arg.position, bounds = _arg.bounds, color = _arg.color, stroke = _arg.stroke;\n          if (bounds) {\n            x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height;\n          }\n          if (position) {\n            x = position.x, y = position.y;\n          }\n          if (color) {\n            this.fillColor(color);\n            context.fillRect(x, y, width, height);\n          }\n          if (stroke) {\n            this.strokeColor(stroke.color);\n            this.lineWidth(stroke.width);\n            context.strokeRect(x, y, width, height);\n          }\n          return this;\n        },\n        /**\n        Draw a line from `start` to `end`.\n        \n        <code class=\"run\"><pre>\n        # Draw a sweet diagonal\n        canvas.drawLine\n          start: Point(0, 0)\n          end: Point(200, 200)\n          color: \"purple\"\n        \n        # Draw another sweet diagonal\n        canvas.drawLine\n          start: Point(200, 0)\n          end: Point(0, 200)\n          color: \"red\"\n          width: 6\n        \n        # Now draw a sweet horizontal with a direction and a length\n        canvas.drawLine\n          start: Point(0, 100)\n          length: 200\n          direction: Point(1, 0)\n          color: \"orange\"\n        \n        </pre></code>\n        \n        @name drawLine\n        @methodOf PixieCanvas#\n        \n        @param {Point} start position to start drawing from\n        @param {Point} [end] position to stop drawing\n        @param {Number} [width] width of the line\n        @param {String|Color} [color] color of the line\n        \n        @returns {PixieCanvas} this\n        */\n\n        drawLine: function(_arg) {\n          var color, direction, end, length, start, width;\n          start = _arg.start, end = _arg.end, width = _arg.width, color = _arg.color, direction = _arg.direction, length = _arg.length;\n          width || (width = 3);\n          if (direction) {\n            end = direction.norm(length).add(start);\n          }\n          this.lineWidth(width);\n          this.strokeColor(color);\n          context.beginPath();\n          context.moveTo(start.x, start.y);\n          context.lineTo(end.x, end.y);\n          context.closePath();\n          context.stroke();\n          return this;\n        },\n        /**\n        Draw a polygon.\n        \n        <code class=\"run\"><pre>\n        # Draw a sweet rhombus\n        canvas.drawPoly\n          points: [\n            Point(50, 25)\n            Point(75, 50)\n            Point(50, 75)\n            Point(25, 50)\n          ]\n          color: \"purple\"\n          stroke:\n            color: \"red\"\n            width: 2\n        </pre></code>\n        \n        @name drawPoly\n        @methodOf PixieCanvas#\n        \n        @param {Point[]} [points] collection of points that define the vertices of the polygon\n        @param {String|Color} [color] color of the polygon\n        @param {Stroke} [stroke] stroke object that specifies stroke color and stroke width\n        \n        @returns {PixieCanvas} this\n        */\n\n        drawPoly: function(_arg) {\n          var color, points, stroke;\n          points = _arg.points, color = _arg.color, stroke = _arg.stroke;\n          context.beginPath();\n          points.each(function(point, i) {\n            if (i === 0) {\n              return context.moveTo(point.x, point.y);\n            } else {\n              return context.lineTo(point.x, point.y);\n            }\n          });\n          context.lineTo(points[0].x, points[0].y);\n          if (color) {\n            this.fillColor(color);\n            context.fill();\n          }\n          if (stroke) {\n            this.strokeColor(stroke.color);\n            this.lineWidth(stroke.width);\n            context.stroke();\n          }\n          return this;\n        },\n        /**\n        Draw a rounded rectangle.\n        \n        Adapted from http://js-bits.blogspot.com/2010/07/canvas-rounded-corner-rectangles.html\n        \n        <code class=\"run\"><pre>\n        # Draw a purple rounded rectangle with a red outline\n        canvas.drawRoundRect\n          position: Point(25, 25)\n          radius: 10\n          width: 150\n          height: 100\n          color: \"purple\"\n          stroke:\n            color: \"red\"\n            width: 2\n        </pre></code>\n        \n        @name drawRoundRect\n        @methodOf PixieCanvas#\n        \n        @param {Number} [x] location on the x axis to start drawing\n        @param {Number} [y] location on the y axis to start drawing\n        @param {Number} [width] width of the rounded rectangle\n        @param {Number} [height] height of the rounded rectangle\n        @param {Number} [radius=5] radius to round the rectangle corners\n        @param {Point} [position] position to start drawing. Overrides x and y if passed\n        @param {Color|String} [color] color of the rounded rectangle\n        @param {Bounds} [bounds] bounds of the rounded rectangle. Overrides x, y, width, and height if passed\n        @param {Stroke} [stroke] stroke object that specifies stroke color and stroke width\n        \n        @returns {PixieCanvas} this\n        */\n\n        drawRoundRect: function(_arg) {\n          var bounds, color, height, position, radius, stroke, width, x, y;\n          x = _arg.x, y = _arg.y, width = _arg.width, height = _arg.height, radius = _arg.radius, position = _arg.position, bounds = _arg.bounds, color = _arg.color, stroke = _arg.stroke;\n          if (radius == null) {\n            radius = 5;\n          }\n          if (bounds) {\n            x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height;\n          }\n          if (position) {\n            x = position.x, y = position.y;\n          }\n          context.beginPath();\n          context.moveTo(x + radius, y);\n          context.lineTo(x + width - radius, y);\n          context.quadraticCurveTo(x + width, y, x + width, y + radius);\n          context.lineTo(x + width, y + height - radius);\n          context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n          context.lineTo(x + radius, y + height);\n          context.quadraticCurveTo(x, y + height, x, y + height - radius);\n          context.lineTo(x, y + radius);\n          context.quadraticCurveTo(x, y, x + radius, y);\n          context.closePath();\n          if (color) {\n            this.fillColor(color);\n            context.fill();\n          }\n          if (stroke) {\n            this.lineWidth(stroke.width);\n            this.strokeColor(stroke.color);\n            context.stroke();\n          }\n          return this;\n        },\n        /**\n        Draws text on the canvas at the given position, in the given color.\n        If no color is given then the previous fill color is used.\n        \n        <code class=\"run\"><pre>\n        # Fill canvas to indicate bounds\n        canvas.fill\n          color: '#eee'\n        \n        # A line to indicate the baseline\n        canvas.drawLine\n          start: Point(25, 50)\n          end: Point(125, 50)\n          color: \"#333\"\n          width: 1\n        \n        # Draw some text, note the position of the baseline\n        canvas.drawText\n          position: Point(25, 50)\n          color: \"red\"\n          text: \"It's dangerous to go alone\"\n        \n        </pre></code>\n        \n        @name drawText\n        @methodOf PixieCanvas#\n        \n        @param {Number} [x] location on x axis to start printing\n        @param {Number} [y] location on y axis to start printing\n        @param {String} text text to print\n        @param {Point} [position] position to start printing. Overrides x and y if passed\n        @param {String|Color} [color] color of text to start printing\n        @param {String} [font] font of text to print\n        \n        @returns {PixieCanvas} this\n        */\n\n        drawText: function(_arg) {\n          var color, font, position, text, x, y;\n          x = _arg.x, y = _arg.y, text = _arg.text, position = _arg.position, color = _arg.color, font = _arg.font;\n          if (position) {\n            x = position.x, y = position.y;\n          }\n          this.fillColor(color);\n          if (font) {\n            this.font(font);\n          }\n          context.fillText(text, x, y);\n          return this;\n        },\n        /**\n        Centers the given text on the canvas at the given y position. An x position\n        or point position can also be given in which case the text is centered at the\n        x, y or position value specified.\n        \n        <code class=\"run\"><pre>\n        # Fill canvas to indicate bounds\n        canvas.fill\n          color: \"#eee\"\n        \n        # A line to indicate the baseline\n        canvas.drawLine\n          start: Point(25, 25)\n          end: Point(125, 25)\n          color: \"#333\"\n          width: 1\n        \n        # Center text on the screen at y value 25\n        canvas.centerText\n          y: 25\n          color: \"red\"\n          text: \"It's dangerous to go alone\"\n        \n        # Center text at point (75, 75)\n        canvas.centerText\n          position: Point(75, 75)\n          color: \"green\"\n          text: \"take this\"\n        \n        </pre></code>\n        \n        @name centerText\n        @methodOf PixieCanvas#\n        \n        @param {String} text Text to print\n        @param {Number} [y] location on the y axis to start printing\n        @param {Number} [x] location on the x axis to start printing. Overrides the default centering behavior if passed\n        @param {Point} [position] position to start printing. Overrides x and y if passed\n        @param {String|Color} [color] color of text to print\n        @param {String} [font] font of text to print\n        \n        @returns {PixieCanvas} this\n        */\n\n        centerText: function(_arg) {\n          var color, font, position, text, textWidth, x, y;\n          text = _arg.text, x = _arg.x, y = _arg.y, position = _arg.position, color = _arg.color, font = _arg.font;\n          if (position) {\n            x = position.x, y = position.y;\n          }\n          if (x == null) {\n            x = canvas.width / 2;\n          }\n          textWidth = this.measureText(text);\n          return this.drawText({\n            text: text,\n            color: color,\n            font: font,\n            x: x - textWidth / 2,\n            y: y\n          });\n        },\n        /**\n        A getter / setter method to set the canvas fillColor.\n        \n        <code><pre>\n        # Set the fill color\n        canvas.fillColor('#FF0000')\n        \n        # Passing no arguments returns the fillColor\n        canvas.fillColor()\n        # => '#FF0000'\n        \n        # You can also pass a Color object\n        canvas.fillColor(Color('sky blue'))\n        </pre></code>\n        \n        @name fillColor\n        @methodOf PixieCanvas#\n        \n        @param {String|Color} [color] color to make the canvas fillColor\n        \n        @returns {PixieCanvas} this\n        */\n\n        fillColor: function(color) {\n          if (color) {\n            if (color.channels) {\n              context.fillStyle = color.toString();\n            } else {\n              context.fillStyle = color;\n            }\n            return this;\n          } else {\n            return context.fillStyle;\n          }\n        },\n        /**\n        A getter / setter method to set the canvas strokeColor.\n        \n        <code><pre>\n        # Set the stroke color\n        canvas.strokeColor('#FF0000')\n        \n        # Passing no arguments returns the strokeColor\n        canvas.strokeColor()\n        # => '#FF0000'\n        \n        # You can also pass a Color object\n        canvas.strokeColor(Color('sky blue'))\n        </pre></code>\n        \n        @name strokeColor\n        @methodOf PixieCanvas#\n        \n        @param {String|Color} [color] color to make the canvas strokeColor\n        \n        @returns {PixieCanvas} this\n        */\n\n        strokeColor: function(color) {\n          if (color) {\n            if (color.channels) {\n              context.strokeStyle = color.toString();\n            } else {\n              context.strokeStyle = color;\n            }\n            return this;\n          } else {\n            return context.strokeStyle;\n          }\n        },\n        /**\n        Determine how wide some text is.\n        \n        <code><pre>\n        canvas.measureText('Hello World!')\n        # => 55\n        </pre></code>\n        \n        @name measureText\n        @methodOf PixieCanvas#\n        \n        @param {String} [text] the text to measure\n        \n        @returns {PixieCanvas} this\n        */\n\n        measureText: function(text) {\n          return context.measureText(text).width;\n        },\n        putImageData: function(imageData, x, y) {\n          context.putImageData(imageData, x, y);\n          return this;\n        },\n        context: function() {\n          return context;\n        },\n        element: function() {\n          return canvas;\n        },\n        createPattern: function(image, repitition) {\n          return context.createPattern(image, repitition);\n        },\n        clip: function(x, y, width, height) {\n          context.beginPath();\n          context.rect(x, y, width, height);\n          context.clip();\n          return this;\n        }\n      });\n      contextAttrAccessor = function() {\n        var attrs;\n        attrs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return attrs.each(function(attr) {\n          return $canvas[attr] = function(newVal) {\n            if (newVal != null) {\n              context[attr] = newVal;\n              return this;\n            } else {\n              return context[attr];\n            }\n          };\n        });\n      };\n      canvasAttrAccessor = function() {\n        var attrs;\n        attrs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return attrs.each(function(attr) {\n          return $canvas[attr] = function(newVal) {\n            if (newVal != null) {\n              canvas[attr] = newVal;\n              return this;\n            } else {\n              return canvas[attr];\n            }\n          };\n        });\n      };\n      contextAttrAccessor(\"font\", \"globalAlpha\", \"globalCompositeOperation\", \"lineWidth\", \"textAlign\");\n      canvasAttrAccessor(\"height\", \"width\");\n      if (canvas != null ? canvas.getContext : void 0) {\n        context = canvas.getContext('2d');\n        if (options.init) {\n          options.init($canvas);\n        }\n        return $canvas;\n      }\n    };\n  })(jQuery);\n\n  /**\n  A browser polyfill so you can consistently \n  call requestAnimationFrame. Using \n  requestAnimationFrame is preferred to \n  setInterval for main game loops.\n  \n  http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n  \n  @name requestAnimationFrame\n  @namespace\n  */\n\n\n  window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {\n    return window.setTimeout(function() {\n      return callback(+new Date());\n    }, 1000 / 60);\n  });\n\n  (function() {\n    /**\n    A wrapper on the Local Storage API \n    \n    @name Local\n    @namespace\n    */\n\n    /**\n    Store an object in local storage.\n    \n    <code><pre>\n    # you can store strings\n    Local.set('name', 'Matt')\n    \n    # and numbers\n    Local.set('age', 26)\n    \n    # and even objects\n    Local.set('person', {name: 'Matt', age: 26})\n    </pre></code>\n    \n    @name set\n    @methodOf Local\n    \n    @param {String} key string used to identify the object you are storing\n    @param {Object} value value of the object you are storing\n    \n    @returns {Object} value\n    */\n\n    var retrieve, store;\n    store = function(key, value) {\n      localStorage[key] = JSON.stringify(value);\n      return value;\n    };\n    /**\n    Retrieve an object from local storage.\n    \n    <code><pre>\n    Local.get('name')\n    # => 'Matt'\n    \n    Local.get('age')\n    # => 26\n    \n    Local.get('person')\n    # => { age: 26, name: 'Matt' }\n    </pre></code>\n    \n    @name get\n    @methodOf Local\n    \n    @param {String} key string that identifies the stored object\n    \n    @returns {Object} The object that was stored or undefined if no object was stored.\n    */\n\n    retrieve = function(key) {\n      var value;\n      value = localStorage[key];\n      if (value != null) {\n        return JSON.parse(value);\n      }\n    };\n    return (typeof exports !== \"undefined\" && exports !== null ? exports : this)[\"Local\"] = {\n      get: retrieve,\n      set: store,\n      put: store,\n      /**\n      Access an instance of Local with a specified prefix.\n      \n      @name new\n      @methodOf Local\n      \n      @param {String} prefix \n      @returns {Local} An interface to local storage with the given prefix applied.\n      */\n\n      \"new\": function(prefix) {\n        prefix || (prefix = \"\");\n        return {\n          get: function(key) {\n            return retrieve(\"\" + prefix + \"_\" + key);\n          },\n          set: function(key, value) {\n            return store(\"\" + prefix + \"_\" + key, value);\n          },\n          put: function(key, value) {\n            return store(\"\" + prefix + \"_\" + key, value);\n          }\n        };\n      }\n    };\n  })();\n\n}).call(this);\n","filename":"shank.js"},"style.styl":{"content":"body\n  background-color: black\n  margin: 0\n  overflow: hidden\n  font-family: helvetica\n  font-size: 16px\n\nul\n  list-style-type: none\n\nbutton\n  cursor: pointer\n\n.app\n  width: 800px\n  height: 450px\n  margin: auto\n  position: relative\n\n.setup, .intro\n  box-sizing: border-box\n  width: 100%\n  height: 100%\n  position: absolute\n  top: 0\n  left: 0\n  padding: 2em 4em\n  \n.intro button\n  display: block\n  width: 200px\n  height: 40px\n  position: absolute\n  bottom: 1em\n  left: 0\n  right: 0\n  font-size: 30px\n  font-weight: bold\n  margin: auto\n\n.content-wrap\n  box-sizing: border-box\n  width: 100%\n  height: 100%\n  background-color: rgba(0, 0, 0, 0.75)\n  color: white\n  padding: 1em\n  position: relative\n\nh1\n  margin-top: 0\n\n.time\n  position: absolute\n  bottom: 0\n  left: 0\n  right: 0\n  margin: auto\n  text-align: center\n  font-weight: bold\n  font-family: \"Lucida Console\", Monaco, monospace\n  height: 80px\n  font-size: 40px\n\nh3, h4\n  margin: 0\n\nul\n  display: inline-block\n  width: 33%\n  box-sizing: border-box\n  margin: 0\n  padding: 0\n  vertical-align: top\n  \n  &.robots\n    width: 100%\n    display: block\n    clear: both\n    overflow: auto\n    \n    li\n      cursor: pointer\n      box-sizing: border-box\n      padding-left: 88px\n      vertical-align: top\n      width: 33%\n      height: 140px\n      display: inline-block\n      background-position: top left\n      background-repeat: no-repeat\n      \n      &:nth-child(1)\n        background-image: url(http://a2.pixiecdn.com/82fcca0104779a4cb2a6b3da022bbcc5e5519c83)\n\n      &:nth-child(2)\n        background-image: url(http://a1.pixiecdn.com/500ba6b2a40368ca4786fce1a81c3870c7c471dc)\n      \n      &:nth-child(3)\n        background-image: url(http://a2.pixiecdn.com/383b39e44e31aed2cfadf37c37aabd5462a99590)\n\nli.selected\n  color: lime\n  background-color: rgba(255, 255, 255, 0.25)","filename":"style.styl"},"targetting.coffee":{"content":"@Targetting = (I={}) ->\n  Object.defaults I,\n    type: \"nearest\"\n    switchDelay: 2\n    switchCooldown: 0\n    \n  target = null\n\n  self = GameObject(I).extend\n    target: (source) ->\n      # NOTE: Only works for two teams\n      selector = \"Robot.team=#{+!source.I.team}\"\n      \n      if target and I.switchCooldown\n        # Don't switch target\n      else\n        I.switchCooldown += I.switchDelay\n\n        switch I.type\n          when \"random\"\n            target =\n              position: ->\n                Point(rand(App.width), rand(App.height))\n                \n          when \"randomEnemy\"\n            target = engine.find(selector).rand()\n          else # Nearest Enemy\n            target = engine.closest(selector, source.position())\n\n      if target\n        return Point.direction(source.position(), target.position())\n\n  self.cooldown \"switchCooldown\"\n\n  return self\n\n@Targetting.random = ->\n  [\n    {type: \"random\"}\n    {type: \"randomEnemy\"}\n    {type: \"nearestEnemy\"}\n  ].rand()\n","filename":"targetting.coffee"},"TODO.md":{"content":"Screens\n=======\n\nIntro\n\nConfig View\n\nArena View\n\nRobot Behavior\n==============\n\nMovement\n--------\nConstant\nSquare Wave\nSine Wave\n\nNavigation\n----------\nTarget Enemy\nRandom Shifts\n\nWeapons\n-------\nTeleporter\nGun\nSaw","filename":"TODO.md"},"weapon.coffee":{"content":"@Weapon = (I={}) ->\n  Object.defaults I,\n    delay: 1\n    cooldown: 1\n    projectile: \"Missile\"\n    spread: 0.05.turns\n\n  self = GameObject(I).extend\n    fire: (source, dt) ->\n      if I.cooldown is 0\n        I.cooldown = I.delay\n        facing = source.I.facing\n        \n        p = source.position()\n          .add(source.velocity().scale(dt))\n          .add(Point.fromAngle(facing).scale(40))\n        \n        engine.add I.projectile,\n          x: p.x\n          y: p.y\n          heading: facing + rand() * I.spread - I.spread/2\n          source: source\n\n  self.cooldown \"cooldown\"\n  \n  return self\n\n@Weapon.random = ->\n  [\n    {projectile: \"Missile\", cooldown: rand() + 1}\n    {projectile: \"Blade\", delay: 0.05, cooldown: 0}\n    {projectile: \"PointDefense\"}\n    {projectile: \"Teleporter\", delay: 4, cooldown: 2 + 2 * rand()}\n    {projectile: \"Flame\", delay: 0.25}\n    {projectile: \"Laser\", delay: 0.6, cooldown: 1 + rand()}\n  ].rand()\n","filename":"weapon.coffee"},"teleporter.coffee":{"content":"@Teleporter = (I={}) ->\n  Object.defaults I,\n    color: \"lime\"\n\n  self = GameObject(I)\n  \n  self.on \"update\", ->\n    if I.age > 1\n      self.destroy()\n      I.source.I.x = rand(App.width)\n      I.source.I.y = rand(App.height)\n\n  return self\n","filename":"teleporter.coffee"},"flame.coffee":{"content":"@Flame = (I={}) ->\n  Object.defaults I,\n    damage: 10 # Per second\n    duration: 3\n    radiusMax: 50\n    radius: 0\n    speed: 150\n    opacity: 0.5\n    selfDamage: true\n\n  self = GameObject(I)\n  \n  self.include \"Damager\"\n\n  self.unbind \"draw\"\n  self.on \"draw\", (canvas) ->\n    canvas.drawCircle\n      x: 0\n      y: 0\n      radius: I.radius\n      color: \"orange\"\n  \n  self.on \"update\", ->\n    I.velocity = Point.fromAngle(I.heading).scale(I.speed)\n\n    I.radius = I.radiusMax * I.age / I.duration\n  \n  return self\n","filename":"flame.coffee"},"laser.coffee":{"content":"@Laser = (I={}) ->\n  Object.defaults I,\n    color: \"cyan\"\n    duration: 0.5\n    damage: 2\n\n  self = GameObject(I)\n  \n  self.on \"update\", ->\n    closest = engine.closest(\"Robot.team=#{+!I.source.I.team}\", self.position())\n    \n    if closest\n      I.target = closest\n      \n      I.target.I.health -= I.damage\n      \n      self.destroy()\n\n  self.on \"destroy\", ->\n    engine.add \"Ray\",\n      start: I.source.position()\n      end: I.target.position()\n      color: I.color\n\n  return self\n","filename":"laser.coffee"},"build.js":{"filename":"build.js","content":"(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"arena\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"canvas\");\n      __push(__element);\n      __attribute(__element, \"width\", 800);\n      __attribute(__element, \"height\", 450);\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"intro\"] = function(data) {\n    return (function() {\n      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"intro\");\n      __attribute(__element, \"style\", \"background-image: url(http://a2.pixiecdn.com/9756865efbcd9ea98cdc0c8636a1fa76343891d1)\");\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"content-wrap\");\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"content\");\n      __element = document.createElement(\"h1\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"Trash Robots\\n\");\n      __push(__element);\n      __pop();\n      __pop();\n      __element = document.createElement(\"p\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"Build your robot dream team in 10 seconds from garbage.\\n\");\n      __push(__element);\n      __pop();\n      __pop();\n      __element = document.createElement(\"button\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"Start\\n\");\n      __push(__element);\n      __pop();\n      __on(\"click\", function() {\n        console.log(\"clicked\");\n        return goToSetup();\n      });\n      __pop();\n      __pop();\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  var _base;\n\n  this.HAMLjr || (this.HAMLjr = {});\n\n  (_base = this.HAMLjr).templates || (_base.templates = {});\n\n  this.HAMLjr.templates[\"setup\"] = function(data) {\n    return (function() {\n      var chooseItem, chooseRobot, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n      __push(document.createDocumentFragment());\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"setup\");\n      __attribute(__element, \"style\", \"background-image: url(http://a3.pixiecdn.com/f433296ce7b90ad0ccf61705b5eda754bb04af83)\");\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"content-wrap\");\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"content\");\n      __element = document.createElement(\"div\");\n      __push(__element);\n      __attribute(__element, \"class\", \"time\");\n      __element = document.createTextNode('');\n      __text(__element, \"10.0\\n\");\n      __push(__element);\n      __pop();\n      __pop();\n      chooseRobot = this.chooseRobot, chooseItem = this.chooseItem;\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"robots\");\n      __each(this.robots, function(robot) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createElement(\"h3\");\n        __push(__element);\n        __attribute(__element, \"class\", \"name\");\n        __element = document.createTextNode('');\n        __text(__element, robot.name);\n        __push(__element);\n        __pop();\n        __pop();\n        __element = document.createElement(\"div\");\n        __push(__element);\n        __attribute(__element, \"class\", \"weapons\");\n        __element = document.createElement(\"h4\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, \"Weapons\\n\");\n        __push(__element);\n        __pop();\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, robot.oWeapons);\n        __push(__element);\n        __pop();\n        __pop();\n        __element = document.createElement(\"div\");\n        __push(__element);\n        __attribute(__element, \"class\", \"motors\");\n        __element = document.createElement(\"h3\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, \"Motors\\n\");\n        __push(__element);\n        __pop();\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, robot.oMotors);\n        __push(__element);\n        __pop();\n        __pop();\n        __element = document.createElement(\"div\");\n        __push(__element);\n        __attribute(__element, \"class\", \"navigation\");\n        __element = document.createElement(\"h3\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, \"Navigation\\n\");\n        __push(__element);\n        __pop();\n        __pop();\n        __element = document.createTextNode('');\n        __text(__element, robot.oNavigation);\n        __push(__element);\n        __pop();\n        __pop();\n        __on(\"click\", function(e) {\n          $(\".robots li\").removeClass(\"selected\");\n          $(e.currentTarget).addClass(\"selected\");\n          return chooseRobot(robot);\n        });\n        return __pop();\n      });\n      __pop();\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"weapons\");\n      __element = document.createElement(\"li\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"\\n\");\n      __push(__element);\n      __pop();\n      __element = document.createElement(\"h3\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"Weapons\\n\");\n      __push(__element);\n      __pop();\n      __pop();\n      __pop();\n      __each(this.weapons, function(item) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, item.projectile.underscore().titleize());\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return chooseItem(item, \"weapons\");\n        });\n        __pop();\n        return __pop();\n      });\n      __pop();\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"motors\");\n      __element = document.createElement(\"li\");\n      __push(__element);\n      __element = document.createElement(\"h3\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"Motors\\n\");\n      __push(__element);\n      __pop();\n      __pop();\n      __pop();\n      __each(this.motors, function(item) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, item.type.titleize());\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return chooseItem(item, \"motors\");\n        });\n        __pop();\n        return __pop();\n      });\n      __pop();\n      __element = document.createElement(\"ul\");\n      __push(__element);\n      __attribute(__element, \"class\", \"navigation\");\n      __element = document.createElement(\"li\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"\\n\");\n      __push(__element);\n      __pop();\n      __element = document.createElement(\"h3\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, \"Navigation\\n\");\n      __push(__element);\n      __pop();\n      __pop();\n      __pop();\n      __each(this.navigation, function(item) {\n        __element = document.createElement(\"li\");\n        __push(__element);\n        __element = document.createElement(\"button\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, item.type);\n        __push(__element);\n        __pop();\n        __on(\"click\", function() {\n          return chooseItem(item, \"navigation\");\n        });\n        __pop();\n        return __pop();\n      });\n      __pop();\n      __pop();\n      __pop();\n      __pop();\n      return __pop();\n    }).call(data);\n  };\n\n}).call(this);\n\n(function() {\n  this.App = {\n    width: 800,\n    height: 450\n  };\n\n}).call(this);\n\n(function() {\n  this.Blade = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      color: \"white\",\n      damage: 100,\n      duration: 0.05,\n      radius: 10\n    });\n    self = GameObject(I);\n    self.include(\"Damager\");\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Damager = function(I, self) {\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      selfDamage: false\n    });\n    return {\n      hit: function(target, dt) {\n        if ((target === I.source) && !I.selfDamage) {\n          return;\n        }\n        return target.I.health -= I.damage * dt;\n      }\n    };\n  };\n\n}).call(this);\n\n(function() {\n  this.Explosion = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      damage: 50,\n      duration: 0.3,\n      radiusMax: 100,\n      radius: 0\n    });\n    self = GameObject(I);\n    self.include(\"Damager\");\n    self.unbind(\"draw\");\n    self.on(\"draw\", function(canvas) {\n      return canvas.drawCircle({\n        x: 0,\n        y: 0,\n        radius: I.radius,\n        color: \"yellow\"\n      });\n    });\n    self.on(\"update\", function() {\n      return I.radius = I.radiusMax * I.age / I.duration;\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  var __slice = [].slice;\n\n  [\"log\", \"info\", \"error\", \"warn\"].each(function(name) {\n    return window[name] = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (typeof console !== \"undefined\" && console !== null) {\n        return console[name].apply(console, args);\n      }\n    };\n  });\n\n}).call(this);\n\n(function() {\n  this.Missile = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      speed: 250,\n      heading: 0,\n      radius: 10\n    });\n    self = GameObject(I);\n    self.on(\"destroy\", function() {\n      return engine.add(\"Explosion\", {\n        x: I.x,\n        y: I.y\n      });\n    });\n    self.on(\"update\", function() {\n      I.velocity = Point.fromAngle(I.heading).scale(I.speed);\n      if (I.x <= 0 || I.x >= App.width || I.y <= 0 || I.y >= App.height) {\n        self.I.x = self.I.x.clamp(0, App.width);\n        self.I.y = self.I.y.clamp(0, App.height);\n        return self.destroy();\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Motor = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      phaseOffset: 0,\n      type: \"constant\",\n      switchCooldown: 0,\n      switchDelay: 0.5,\n      lastPower: 0\n    });\n    self = GameObject(I).extend({\n      power: function() {\n        var lastPower;\n        if (I.switchCooldown) {\n          lastPower;\n        } else {\n          I.switchCooldown += I.switchDelay;\n        }\n        return lastPower = (function() {\n          switch (I.type) {\n            case \"periodic\":\n              return Math.sin((I.age + I.phaseOffset) * Math.TAU) + 0.5;\n            case \"jittery\":\n              return rand() * 0.5;\n            case \"slow\":\n              return 0.5;\n            default:\n              return 1;\n          }\n        })();\n      }\n    });\n    self.cooldown(\"switchCooldown\");\n    return self;\n  };\n\n  this.Motor.random = function() {\n    return [\n      {\n        type: \"slow\"\n      }, {\n        type: \"constant\"\n      }, {\n        type: \"jittery\"\n      }, {\n        type: \"periodic\",\n        phaseOffset: rand(),\n        switchDelay: 0\n      }\n    ].rand();\n  };\n\n}).call(this);\n\n(function() {\n  this.Navigation = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      type: \"facing\",\n      switchDelay: 2,\n      switchCooldown: 0\n    });\n    self = GameObject(I).extend({\n      navigate: function(source) {\n        if (I.switchCooldown) {\n\n        } else {\n          I.switchCooldown += I.switchDelay;\n          switch (I.type) {\n            case \"random\":\n              return rand() * Math.TAU;\n            case \"spiral\":\n              return 10 * Math.log(source.I.age / 10 + 1) + source.I.headingInitial;\n            case \"strafe\":\n              if (rand() > 0.5) {\n                return source.I.facing + 0.25.turns;\n              } else {\n                return source.I.facing - 0.25.turns;\n              }\n              break;\n            default:\n              return source.I.facing;\n          }\n        }\n      }\n    });\n    self.cooldown(\"switchCooldown\");\n    return self;\n  };\n\n  this.Navigation.random = function() {\n    return [\n      {\n        type: \"facing\"\n      }, {\n        type: \"spiral\",\n        switchDelay: 0.25\n      }, {\n        type: \"random\"\n      }, {\n        type: \"strafe\"\n      }\n    ].rand();\n  };\n\n}).call(this);\n\n(function() {\n  !function(){var __slice=[].slice;!function($){Number.prototype.clamp=function(min,max){return Math.min(Math.max(min,this),max)};Math.TAU=2*Math.PI;return $.fn.pixieCanvas=function(options){var $canvas,canvas,canvasAttrAccessor,context,contextAttrAccessor;if(options==null){options={}}canvas=this.get(0);context=void 0;$canvas=$.extend($(canvas),{withTransform:function(matrix,block){context.save();context.transform(matrix.a,matrix.b,matrix.c,matrix.d,matrix.tx,matrix.ty);try{block(this)}finally{context.restore()}return this},clear:function(_arg){var height,width,x,y,_ref;_ref=_arg!=null?_arg:{},x=_ref.x,y=_ref.y,width=_ref.width,height=_ref.height;if(x==null){x=0}if(y==null){y=0}if(width==null){width=canvas.width}if(height==null){height=canvas.height}context.clearRect(x,y,width,height);return this},fill:function(color){var bounds,height,width,x,y,_ref;if(color==null){color={}}if(!(typeof color===\"string\"||color.channels)){_ref=color,x=_ref.x,y=_ref.y,width=_ref.width,height=_ref.height,bounds=_ref.bounds,color=_ref.color}if(bounds){x=bounds.x,y=bounds.y,width=bounds.width,height=bounds.height}x||(x=0);y||(y=0);if(width==null){width=canvas.width}if(height==null){height=canvas.height}this.fillColor(color);context.fillRect(x,y,width,height);return this},drawImage:function(){var args;args=1<=arguments.length?__slice.call(arguments,0):[];context.drawImage.apply(context,args);return this},drawCircle:function(_arg){var circle,color,position,radius,stroke,x,y;x=_arg.x,y=_arg.y,radius=_arg.radius,position=_arg.position,color=_arg.color,stroke=_arg.stroke,circle=_arg.circle;if(circle){x=circle.x,y=circle.y,radius=circle.radius}if(position){x=position.x,y=position.y}radius=radius.clamp(0,Infinity);context.beginPath();context.arc(x,y,radius,0,Math.TAU,true);context.closePath();if(color){this.fillColor(color);context.fill()}if(stroke){this.strokeColor(stroke.color);this.lineWidth(stroke.width);context.stroke()}return this},drawRect:function(_arg){var bounds,color,height,position,stroke,width,x,y;x=_arg.x,y=_arg.y,width=_arg.width,height=_arg.height,position=_arg.position,bounds=_arg.bounds,color=_arg.color,stroke=_arg.stroke;if(bounds){x=bounds.x,y=bounds.y,width=bounds.width,height=bounds.height}if(position){x=position.x,y=position.y}if(color){this.fillColor(color);context.fillRect(x,y,width,height)}if(stroke){this.strokeColor(stroke.color);this.lineWidth(stroke.width);context.strokeRect(x,y,width,height)}return this},drawLine:function(_arg){var color,direction,end,length,start,width;start=_arg.start,end=_arg.end,width=_arg.width,color=_arg.color,direction=_arg.direction,length=_arg.length;width||(width=3);if(direction){end=direction.norm(length).add(start)}this.lineWidth(width);this.strokeColor(color);context.beginPath();context.moveTo(start.x,start.y);context.lineTo(end.x,end.y);context.closePath();context.stroke();return this},drawPoly:function(_arg){var color,points,stroke;points=_arg.points,color=_arg.color,stroke=_arg.stroke;context.beginPath();points.forEach(function(point,i){if(i===0){return context.moveTo(point.x,point.y)}else{return context.lineTo(point.x,point.y)}});context.lineTo(points[0].x,points[0].y);if(color){this.fillColor(color);context.fill()}if(stroke){this.strokeColor(stroke.color);this.lineWidth(stroke.width);context.stroke()}return this},drawRoundRect:function(_arg){var bounds,color,height,position,radius,stroke,width,x,y;x=_arg.x,y=_arg.y,width=_arg.width,height=_arg.height,radius=_arg.radius,position=_arg.position,bounds=_arg.bounds,color=_arg.color,stroke=_arg.stroke;if(radius==null){radius=5}if(bounds){x=bounds.x,y=bounds.y,width=bounds.width,height=bounds.height}if(position){x=position.x,y=position.y}context.beginPath();context.moveTo(x+radius,y);context.lineTo(x+width-radius,y);context.quadraticCurveTo(x+width,y,x+width,y+radius);context.lineTo(x+width,y+height-radius);context.quadraticCurveTo(x+width,y+height,x+width-radius,y+height);context.lineTo(x+radius,y+height);context.quadraticCurveTo(x,y+height,x,y+height-radius);context.lineTo(x,y+radius);context.quadraticCurveTo(x,y,x+radius,y);context.closePath();if(color){this.fillColor(color);context.fill()}if(stroke){this.lineWidth(stroke.width);this.strokeColor(stroke.color);context.stroke()}return this},drawText:function(_arg){var color,font,position,text,x,y;x=_arg.x,y=_arg.y,text=_arg.text,position=_arg.position,color=_arg.color,font=_arg.font;if(position){x=position.x,y=position.y}this.fillColor(color);if(font){this.font(font)}context.fillText(text,x,y);return this},centerText:function(_arg){var color,font,position,text,textWidth,x,y;text=_arg.text,x=_arg.x,y=_arg.y,position=_arg.position,color=_arg.color,font=_arg.font;if(position){x=position.x,y=position.y}if(x==null){x=canvas.width/2}textWidth=this.measureText(text);return this.drawText({text:text,color:color,font:font,x:x-textWidth/2,y:y})},fillColor:function(color){if(color){if(color.channels){context.fillStyle=color.toString()}else{context.fillStyle=color}return this}else{return context.fillStyle}},strokeColor:function(color){if(color){if(color.channels){context.strokeStyle=color.toString()}else{context.strokeStyle=color}return this}else{return context.strokeStyle}},measureText:function(text){return context.measureText(text).width},putImageData:function(){var args;args=1<=arguments.length?__slice.call(arguments,0):[];context.putImageData.apply(context,args);return this},context:function(){return context},element:function(){return canvas},createPattern:function(image,repitition){return context.createPattern(image,repitition)},clip:function(x,y,width,height){context.beginPath();context.rect(x,y,width,height);context.clip();return this}});contextAttrAccessor=function(){var attrs;attrs=1<=arguments.length?__slice.call(arguments,0):[];return attrs.forEach(function(attr){return $canvas[attr]=function(newVal){if(newVal!=null){context[attr]=newVal;return this}else{return context[attr]}}})};contextAttrAccessor(\"font\",\"globalAlpha\",\"globalCompositeOperation\",\"lineWidth\",\"textAlign\");canvasAttrAccessor=function(){var attrs;attrs=1<=arguments.length?__slice.call(arguments,0):[];return attrs.forEach(function(attr){return $canvas[attr]=function(newVal){if(newVal!=null){canvas[attr]=newVal;return this}else{return canvas[attr]}}})};canvasAttrAccessor(\"height\",\"width\");if(canvas!=null?canvas.getContext:void 0){context=canvas.getContext(\"2d\");if(options.init){options.init($canvas)}return $canvas}}}(typeof jQuery!==\"undefined\"&&jQuery!==null?jQuery:Zepto)}.call(this);;\n\n\n}).call(this);\n\n(function() {\n  this.PointDefense = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      color: \"purple\",\n      duration: 0.5,\n      range: 300\n    });\n    self = GameObject(I);\n    self.on(\"update\", function() {\n      var closest;\n      closest = engine.find(\"Missile\").select(function(missile) {\n        return missile.I.source.I.team !== I.source.I.team;\n      }).map(function(missile) {\n        return {\n          distance: Point.distance(self.position(), missile.position()),\n          object: missile\n        };\n      }).sort(function(_arg, _arg1) {\n        var a, b;\n        a = _arg.distance;\n        b = _arg1.distance;\n        return b - a;\n      }).first();\n      if (closest && closest.distance <= I.range) {\n        I.target = closest.object;\n        I.target.destroy();\n        return self.destroy();\n      }\n    });\n    self.on(\"destroy\", function() {\n      return engine.add(\"Ray\", {\n        start: I.source.position(),\n        end: I.target.position(),\n        color: I.color\n      });\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Ray = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      duration: 0.25\n    });\n    self = GameObject(I);\n    self.on(\"update\", function() {\n      return I.alpha = 1 - I.age / I.duration;\n    });\n    self.unbind(\"draw\");\n    self.bind(\"draw\", function(canvas) {\n      return canvas.drawLine({\n        start: I.start,\n        end: I.end,\n        color: I.color\n      });\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Robot = function(I) {\n    var drawDebug, meter, motors, navigation, self, targetting, weapons;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      color: \"blue\",\n      width: 50,\n      height: 50,\n      speed: 100,\n      name: \"Robot\",\n      heading: 0,\n      headingInitial: 0,\n      facing: 0,\n      facingInitial: 0,\n      health: 100,\n      healthMax: 100,\n      radius: 25,\n      team: 0,\n      motors: [Motor.random()],\n      navigation: Navigation.random(),\n      targetting: Targetting.random(),\n      weapons: [Weapon.random()]\n    });\n    weapons = I.weapons.map(Weapon);\n    motors = I.motors.map(Motor);\n    navigation = Navigation(I.navigation);\n    targetting = Targetting(I.targetting);\n    self = GameObject(I);\n    self.clampToBounds();\n    meter = function() {\n      var color, healthRatio;\n      healthRatio = I.health / I.healthMax;\n      if (healthRatio > 0.5) {\n        color = Color.mix(Color(\"green\"), Color(\"yellow\"), (healthRatio - 0.5) * 2);\n      } else {\n        color = Color.mix(Color(\"yellow\"), Color(\"red\"), healthRatio * 2);\n      }\n      return self.meter(\"health\", {\n        color: color,\n        x: I.x - I.width / 2,\n        y: I.y - I.height / 2 - 20,\n        width: I.width\n      });\n    };\n    self.on(\"update\", function(elapsedTime) {\n      if (I.health <= 0) {\n        self.destroy();\n      }\n      meter();\n      navigation.update(elapsedTime);\n      I.heading = navigation.navigate(self) || I.heading;\n      targetting.update(elapsedTime);\n      I.facing = targetting.target(self) || I.facing;\n      motors.invoke(\"update\", elapsedTime);\n      I.power = motors.invoke(\"power\").sum().clamp(0, 2);\n      weapons.invoke(\"update\", elapsedTime);\n      weapons.invoke(\"fire\", self, elapsedTime);\n      return I.velocity = Point.fromAngle(I.heading).scale(I.speed * I.power);\n    });\n    self.on(\"afterUpdate\", function(elapsedTime) {\n      return motors.invoke(\"trigger\", \"afterUpdate\", elapsedTime);\n    });\n    drawDebug = function(canvas) {\n      var end, p;\n      p = self.position();\n      end = p.add(Point.fromAngle(I.facing).scale(40));\n      canvas.drawLine({\n        start: p,\n        end: end,\n        color: \"rgb(255, 0, 255)\"\n      });\n      end = p.add(Point.fromAngle(I.heading).scale(40));\n      return canvas.drawLine({\n        start: p,\n        end: end,\n        color: \"rgb(0, 255, 0)\"\n      });\n    };\n    self.on(\"draw\", function(canvas) {\n      canvas.font(\"bold 16px consolas, 'Courier New', 'andale mono', 'lucida console', monospace\");\n      return canvas.centerText({\n        color: \"white\",\n        x: 0,\n        y: -I.height / 2,\n        text: I.name\n      });\n    });\n    self.on(\"overlay\", drawDebug);\n    self.on(\"destroy\", function() {\n      return engine.add(\"Explosion\", {\n        x: I.x,\n        y: I.y\n      });\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  var defaultBot, defaultItem, randomName;\n\n  randomName = function() {\n    var name, prefix, suffix;\n    prefix = [\"Mr. \", \"Dr. \", \"Ms. \", \"Mrs. \", \"The \", \"\", \"\", \"\", \"\", \"El \", \"Lord \", \"Lady \", \"Duke \", \"Duchess \"].rand();\n    name = [\"Donuts\", \"BMO\", \"Bacon\", \"Duder\", \"Dude\", \"Hotdog\", \"Squirtle\", \"Killer\", \"Ronnie\", \"Joe\", \"Stalin\", \"Reginald\", \"Toast\", \"Margarine\", \"Juice\", \"Q\", \"DP\", \"Obama\", \"Hitler\", \"YOLO\"].rand();\n    suffix = [\" Jr\", \" II\", \" Sr\", \" III\", \" IV\", \" of Death\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"].rand();\n    return \"\" + prefix + name + suffix;\n  };\n\n  defaultBot = function() {\n    var bot;\n    bot = {\n      name: randomName(),\n      motors: [],\n      weapons: [],\n      targetting: null,\n      navigation: null\n    };\n    bot.oNavigation = Observable(\"\");\n    bot.oWeapons = Observable(\"\");\n    bot.oMotors = Observable(\"\");\n    return bot;\n  };\n\n  defaultItem = function() {\n    return {\n      type: \"default\"\n    };\n  };\n\n  this.Setup = function(I) {\n    var activeRobot, add, removeFromArray, self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      robots: [defaultBot(), defaultBot(), defaultBot()],\n      motors: [Motor.random(), Motor.random(), Motor.random(), Motor.random()],\n      weapons: [Weapon.random(), Weapon.random(), Weapon.random(), Weapon.random()],\n      targetting: [Targetting.random(), Targetting.random()],\n      navigation: [Navigation.random(), Navigation.random(), Navigation.random()]\n    });\n    activeRobot = I.robots.first();\n    removeFromArray = function(item, slot) {\n      return I.robots.each(function(robot) {\n        return self[slot].remove(item);\n      });\n    };\n    add = function(robot, item, slot) {\n      if (slot.lastIndexOf('s') === slot.length - 1) {\n        if (robot[slot].length < 2) {\n          removeFromArray(item, slot);\n          robot[slot].push(item);\n        }\n      } else {\n        if (robot[slot] === null) {\n          removeFromArray(item, slot);\n          robot[slot] = item;\n        }\n      }\n      return I.robots.each(function(robot) {\n        var _ref;\n        robot.oMotors(robot.motors.map(function(m) {\n          return m.type.titleize();\n        }).join(\",\"));\n        robot.oWeapons(robot.weapons.map(function(w) {\n          return w.projectile.underscore().titleize();\n        }).join(\",\"));\n        return robot.oNavigation(((_ref = robot.navigation) != null ? _ref.type.titleize() : void 0) || \"\");\n      });\n    };\n    self = Model(I).extend({\n      chooseItem: function(item, slot) {\n        return add(activeRobot, item, slot);\n      },\n      chooseRobot: function(robot) {\n        return activeRobot = robot;\n      }\n    });\n    self.observeAll();\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Targetting = function(I) {\n    var self, target;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      type: \"nearest\",\n      switchDelay: 2,\n      switchCooldown: 0\n    });\n    target = null;\n    self = GameObject(I).extend({\n      target: function(source) {\n        var selector;\n        selector = \"Robot.team=\" + (+(!source.I.team));\n        if (target && I.switchCooldown) {\n\n        } else {\n          I.switchCooldown += I.switchDelay;\n          switch (I.type) {\n            case \"random\":\n              target = {\n                position: function() {\n                  return Point(rand(App.width), rand(App.height));\n                }\n              };\n              break;\n            case \"randomEnemy\":\n              target = engine.find(selector).rand();\n              break;\n            default:\n              target = engine.closest(selector, source.position());\n          }\n        }\n        if (target) {\n          return Point.direction(source.position(), target.position());\n        }\n      }\n    });\n    self.cooldown(\"switchCooldown\");\n    return self;\n  };\n\n  this.Targetting.random = function() {\n    return [\n      {\n        type: \"random\"\n      }, {\n        type: \"randomEnemy\"\n      }, {\n        type: \"nearestEnemy\"\n      }\n    ].rand();\n  };\n\n}).call(this);\n\n(function() {\n  this.Weapon = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      delay: 1,\n      cooldown: 1,\n      projectile: \"Missile\",\n      spread: 0.05.turns\n    });\n    self = GameObject(I).extend({\n      fire: function(source, dt) {\n        var facing, p;\n        if (I.cooldown === 0) {\n          I.cooldown = I.delay;\n          facing = source.I.facing;\n          p = source.position().add(source.velocity().scale(dt)).add(Point.fromAngle(facing).scale(40));\n          return engine.add(I.projectile, {\n            x: p.x,\n            y: p.y,\n            heading: facing + rand() * I.spread - I.spread / 2,\n            source: source\n          });\n        }\n      }\n    });\n    self.cooldown(\"cooldown\");\n    return self;\n  };\n\n  this.Weapon.random = function() {\n    return [\n      {\n        projectile: \"Missile\",\n        cooldown: rand() + 1\n      }, {\n        projectile: \"Blade\",\n        delay: 0.05,\n        cooldown: 0\n      }, {\n        projectile: \"PointDefense\"\n      }, {\n        projectile: \"Teleporter\",\n        delay: 4,\n        cooldown: 2 + 2 * rand()\n      }, {\n        projectile: \"Flame\",\n        delay: 0.25\n      }, {\n        projectile: \"Laser\",\n        delay: 0.6,\n        cooldown: 1 + rand()\n      }\n    ].rand();\n  };\n\n}).call(this);\n\n(function() {\n  this.Teleporter = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      color: \"lime\"\n    });\n    self = GameObject(I);\n    self.on(\"update\", function() {\n      if (I.age > 1) {\n        self.destroy();\n        I.source.I.x = rand(App.width);\n        return I.source.I.y = rand(App.height);\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Flame = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      damage: 10,\n      duration: 3,\n      radiusMax: 50,\n      radius: 0,\n      speed: 150,\n      opacity: 0.5,\n      selfDamage: true\n    });\n    self = GameObject(I);\n    self.include(\"Damager\");\n    self.unbind(\"draw\");\n    self.on(\"draw\", function(canvas) {\n      return canvas.drawCircle({\n        x: 0,\n        y: 0,\n        radius: I.radius,\n        color: \"orange\"\n      });\n    });\n    self.on(\"update\", function() {\n      I.velocity = Point.fromAngle(I.heading).scale(I.speed);\n      return I.radius = I.radiusMax * I.age / I.duration;\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  this.Laser = function(I) {\n    var self;\n    if (I == null) {\n      I = {};\n    }\n    Object.defaults(I, {\n      color: \"cyan\",\n      duration: 0.5,\n      damage: 2\n    });\n    self = GameObject(I);\n    self.on(\"update\", function() {\n      var closest;\n      closest = engine.closest(\"Robot.team=\" + (+(!I.source.I.team)), self.position());\n      if (closest) {\n        I.target = closest;\n        I.target.I.health -= I.damage;\n        return self.destroy();\n      }\n    });\n    self.on(\"destroy\", function() {\n      return engine.add(\"Ray\", {\n        start: I.source.position(),\n        end: I.target.position(),\n        color: I.color\n      });\n    });\n    return self;\n  };\n\n}).call(this);\n\n(function() {\n  var $root, appRoot, canvas, countdownInterval, gist, objectCollision, setupTimeLimit, startGame, styleContent, _ref;\n\n  $root = ENV.$root, gist = ENV.gist;\n\n  appRoot = $(\"<div>\", {\n    \"class\": \"app\"\n  });\n\n  $root.append(appRoot);\n\n  $root = appRoot;\n\n  Object.keys(gist.files).each(function(name) {\n    if (name.extension() === \"js\" && name.withoutExtension() !== \"build\") {\n      return Function(gist.files[name].content)();\n    }\n  });\n\n  if (styleContent = (_ref = gist.files[\"style.css\"]) != null ? _ref.content : void 0) {\n    $root.append($(\"<style>\", {\n      html: styleContent\n    }));\n  }\n\n  $root.append(HAMLjr.templates.arena());\n\n  $root.append(HAMLjr.templates.intro());\n\n  countdownInterval = null;\n\n  setupTimeLimit = 10;\n\n  this.goToSetup = function() {\n    var setupConfig, setupStartedAt;\n    $(\".setup\").remove();\n    setupConfig = Setup();\n    $root.append(HAMLjr.templates.setup(setupConfig));\n    $(\".intro\").hide();\n    setupStartedAt = +(new Date);\n    clearInterval(countdownInterval);\n    return countdownInterval = setInterval(function() {\n      var color, size, time;\n      time = (setupStartedAt + setupTimeLimit * 1000 - (+(new Date))) / 1000;\n      size = (time % 1) * 20 + 40;\n      color = \"lime\";\n      if (time < 6) {\n        color = \"yellow\";\n      }\n      if (time < 3) {\n        color = \"red\";\n      }\n      if (time < 0) {\n        clearInterval(countdownInterval);\n        return startGame(setupConfig);\n      } else {\n        return $(\".setup .time\").text(time.toFixed(2)).css({\n          fontSize: size,\n          color: color\n        });\n      }\n    }, 15);\n  };\n\n  canvas = $root.children(\"canvas\").pixieCanvas();\n\n  canvas.fill(\"gray\");\n\n  this.engine = Engine({\n    canvas: canvas,\n    FPS: 60\n  });\n\n  startGame = function(config) {\n    $(\".setup\").hide();\n    $(\".intro\").hide();\n    engine.start();\n    return config.robots.each(function(data, i) {\n      var y;\n      y = (i + 1) * App.height / 4;\n      engine.add(\"Robot\", Object.extend(data, {\n        y: y\n      }));\n      return engine.add(\"Robot\", {\n        color: \"red\",\n        x: App.width,\n        y: y,\n        headingInitial: 0.5.turns,\n        team: 1\n      });\n    });\n  };\n\n  engine.on(\"overlay\", function(canvas) {\n    return canvas.drawText({\n      x: 10,\n      y: 20,\n      color: \"white\",\n      text: engine.objects().length\n    });\n  });\n\n  objectCollision = function(a, b) {\n    return Collision.circular(a.circle(), b.circle());\n  };\n\n  engine.on(\"update\", function(dt) {\n    Collision.collide(\"Missile\", \"Robot\", function(missile, robot) {\n      if (missile.I.source === robot) {\n        return;\n      }\n      return missile.destroy();\n    }, objectCollision);\n    Collision.collide(\"Explosion, Blade, Flame\", \"Robot\", function(explosion, robot) {\n      return explosion.hit(robot, dt);\n    }, objectCollision);\n    Collision.collide(\"Explosion\", \"Missile\", function(explosion, missile) {\n      return missile.destroy();\n    }, objectCollision);\n    return engine.find(\"Missile\").eachPair(function(a, b) {\n      if (objectCollision(a, b)) {\n        a.destroy();\n        return b.destroy();\n      }\n    });\n  });\n\n}).call(this);\n"},"style.css":{"filename":"style.css","content":"body {\n  background-color: black;\n  margin: 0;\n  overflow: hidden;\n  font-family: helvetica;\n  font-size: 16px;\n}\n\nul {\n  list-style-type: none;\n}\n\nbutton {\n  cursor: pointer;\n}\n\n.app {\n  width: 800px;\n  height: 450px;\n  margin: auto;\n  position: relative;\n}\n\n.setup,\n.intro {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  padding: 2em 4em;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.intro button {\n  display: block;\n  width: 200px;\n  height: 40px;\n  position: absolute;\n  bottom: 1em;\n  left: 0;\n  right: 0;\n  font-size: 30px;\n  font-weight: bold;\n  margin: auto;\n}\n\n.content-wrap {\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.75);\n  color: white;\n  padding: 1em;\n  position: relative;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\nh1 {\n  margin-top: 0;\n}\n\n.time {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  margin: auto;\n  text-align: center;\n  font-weight: bold;\n  font-family: \"Lucida Console\", Monaco, monospace;\n  height: 80px;\n  font-size: 40px;\n}\n\nh3,\nh4 {\n  margin: 0;\n}\n\nul {\n  display: inline-block;\n  width: 33%;\n  margin: 0;\n  padding: 0;\n  vertical-align: top;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\nul.robots li:nth-child(1) {\n  background-image: url(http://a2.pixiecdn.com/82fcca0104779a4cb2a6b3da022bbcc5e5519c83);\n}\n\nul.robots li:nth-child(2) {\n  background-image: url(http://a1.pixiecdn.com/500ba6b2a40368ca4786fce1a81c3870c7c471dc);\n}\n\nul.robots li:nth-child(3) {\n  background-image: url(http://a2.pixiecdn.com/383b39e44e31aed2cfadf37c37aabd5462a99590);\n}\n\nul.robots li {\n  cursor: pointer;\n  padding-left: 88px;\n  vertical-align: top;\n  width: 33%;\n  height: 140px;\n  display: inline-block;\n  background-position: top left;\n  background-repeat: no-repeat;\n  -ms-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\nul.robots {\n  width: 100%;\n  display: block;\n  clear: both;\n  overflow: auto;\n}\n\nli.selected {\n  color: lime;\n  background-color: rgba(255, 255, 255, 0.25);\n}\n\n@media all and (-webkit-min-device-pixel-ratio: 1.5) {\n  ul.robots li:nth-child(1) {\n    background-image: url(\"http:/a2.pixiecdn.com/82fcca0104779a4cb2a6b3da022bbcc5e5519c83@2x\");\n    background-size: contain;\n  }\n}\n\n@media all and (-webkit-min-device-pixel-ratio: 1.5) {\n  ul.robots li:nth-child(2) {\n    background-image: url(\"http:/a1.pixiecdn.com/500ba6b2a40368ca4786fce1a81c3870c7c471dc@2x\");\n    background-size: contain;\n  }\n}\n\n@media all and (-webkit-min-device-pixel-ratio: 1.5) {\n  ul.robots li:nth-child(3) {\n    background-image: url(\"http:/a2.pixiecdn.com/383b39e44e31aed2cfadf37c37aabd5462a99590@2x\");\n    background-size: contain;\n  }\n}"}}
    }
  };

  (function() {
  var _base;

  this.HAMLjr || (this.HAMLjr = {});

  (_base = this.HAMLjr).templates || (_base.templates = {});

  this.HAMLjr.templates["arena"] = function(data) {
    return (function() {
      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;
      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;
      __push(document.createDocumentFragment());
      __element = document.createElement("canvas");
      __push(__element);
      __attribute(__element, "width", 800);
      __attribute(__element, "height", 450);
      __pop();
      return __pop();
    }).call(data);
  };

}).call(this);

(function() {
  var _base;

  this.HAMLjr || (this.HAMLjr = {});

  (_base = this.HAMLjr).templates || (_base.templates = {});

  this.HAMLjr.templates["intro"] = function(data) {
    return (function() {
      var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;
      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;
      __push(document.createDocumentFragment());
      __element = document.createElement("div");
      __push(__element);
      __attribute(__element, "class", "intro");
      __attribute(__element, "style", "background-image: url(http://a2.pixiecdn.com/9756865efbcd9ea98cdc0c8636a1fa76343891d1)");
      __element = document.createElement("div");
      __push(__element);
      __attribute(__element, "class", "content-wrap");
      __element = document.createElement("div");
      __push(__element);
      __attribute(__element, "class", "content");
      __element = document.createElement("h1");
      __push(__element);
      __element = document.createTextNode('');
      __text(__element, "Trash Robots\n");
      __push(__element);
      __pop();
      __pop();
      __element = document.createElement("p");
      __push(__element);
      __element = document.createTextNode('');
      __text(__element, "Build your robot dream team in 10 seconds from garbage.\n");
      __push(__element);
      __pop();
      __pop();
      __element = document.createElement("button");
      __push(__element);
      __element = document.createTextNode('');
      __text(__element, "Start\n");
      __push(__element);
      __pop();
      __on("click", function() {
        console.log("clicked");
        return goToSetup();
      });
      __pop();
      __pop();
      __pop();
      __pop();
      return __pop();
    }).call(data);
  };

}).call(this);

(function() {
  var _base;

  this.HAMLjr || (this.HAMLjr = {});

  (_base = this.HAMLjr).templates || (_base.templates = {});

  this.HAMLjr.templates["setup"] = function(data) {
    return (function() {
      var chooseItem, chooseRobot, __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;
      _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;
      __push(document.createDocumentFragment());
      __element = document.createElement("div");
      __push(__element);
      __attribute(__element, "class", "setup");
      __attribute(__element, "style", "background-image: url(http://a3.pixiecdn.com/f433296ce7b90ad0ccf61705b5eda754bb04af83)");
      __element = document.createElement("div");
      __push(__element);
      __attribute(__element, "class", "content-wrap");
      __element = document.createElement("div");
      __push(__element);
      __attribute(__element, "class", "content");
      __element = document.createElement("div");
      __push(__element);
      __attribute(__element, "class", "time");
      __element = document.createTextNode('');
      __text(__element, "10.0\n");
      __push(__element);
      __pop();
      __pop();
      chooseRobot = this.chooseRobot, chooseItem = this.chooseItem;
      __element = document.createElement("ul");
      __push(__element);
      __attribute(__element, "class", "robots");
      __each(this.robots, function(robot) {
        __element = document.createElement("li");
        __push(__element);
        __element = document.createElement("h3");
        __push(__element);
        __attribute(__element, "class", "name");
        __element = document.createTextNode('');
        __text(__element, robot.name);
        __push(__element);
        __pop();
        __pop();
        __element = document.createElement("div");
        __push(__element);
        __attribute(__element, "class", "weapons");
        __element = document.createElement("h4");
        __push(__element);
        __element = document.createTextNode('');
        __text(__element, "Weapons\n");
        __push(__element);
        __pop();
        __pop();
        __element = document.createTextNode('');
        __text(__element, robot.oWeapons);
        __push(__element);
        __pop();
        __pop();
        __element = document.createElement("div");
        __push(__element);
        __attribute(__element, "class", "motors");
        __element = document.createElement("h3");
        __push(__element);
        __element = document.createTextNode('');
        __text(__element, "Motors\n");
        __push(__element);
        __pop();
        __pop();
        __element = document.createTextNode('');
        __text(__element, robot.oMotors);
        __push(__element);
        __pop();
        __pop();
        __element = document.createElement("div");
        __push(__element);
        __attribute(__element, "class", "navigation");
        __element = document.createElement("h3");
        __push(__element);
        __element = document.createTextNode('');
        __text(__element, "Navigation\n");
        __push(__element);
        __pop();
        __pop();
        __element = document.createTextNode('');
        __text(__element, robot.oNavigation);
        __push(__element);
        __pop();
        __pop();
        __on("click", function(e) {
          $(".robots li").removeClass("selected");
          $(e.currentTarget).addClass("selected");
          return chooseRobot(robot);
        });
        return __pop();
      });
      __pop();
      __element = document.createElement("ul");
      __push(__element);
      __attribute(__element, "class", "weapons");
      __element = document.createElement("li");
      __push(__element);
      __element = document.createTextNode('');
      __text(__element, "\n");
      __push(__element);
      __pop();
      __element = document.createElement("h3");
      __push(__element);
      __element = document.createTextNode('');
      __text(__element, "Weapons\n");
      __push(__element);
      __pop();
      __pop();
      __pop();
      __each(this.weapons, function(item) {
        __element = document.createElement("li");
        __push(__element);
        __element = document.createElement("button");
        __push(__element);
        __element = document.createTextNode('');
        __text(__element, item.projectile.underscore().titleize());
        __push(__element);
        __pop();
        __on("click", function() {
          return chooseItem(item, "weapons");
        });
        __pop();
        return __pop();
      });
      __pop();
      __element = document.createElement("ul");
      __push(__element);
      __attribute(__element, "class", "motors");
      __element = document.createElement("li");
      __push(__element);
      __element = document.createElement("h3");
      __push(__element);
      __element = document.createTextNode('');
      __text(__element, "Motors\n");
      __push(__element);
      __pop();
      __pop();
      __pop();
      __each(this.motors, function(item) {
        __element = document.createElement("li");
        __push(__element);
        __element = document.createElement("button");
        __push(__element);
        __element = document.createTextNode('');
        __text(__element, item.type.titleize());
        __push(__element);
        __pop();
        __on("click", function() {
          return chooseItem(item, "motors");
        });
        __pop();
        return __pop();
      });
      __pop();
      __element = document.createElement("ul");
      __push(__element);
      __attribute(__element, "class", "navigation");
      __element = document.createElement("li");
      __push(__element);
      __element = document.createTextNode('');
      __text(__element, "\n");
      __push(__element);
      __pop();
      __element = document.createElement("h3");
      __push(__element);
      __element = document.createTextNode('');
      __text(__element, "Navigation\n");
      __push(__element);
      __pop();
      __pop();
      __pop();
      __each(this.navigation, function(item) {
        __element = document.createElement("li");
        __push(__element);
        __element = document.createElement("button");
        __push(__element);
        __element = document.createTextNode('');
        __text(__element, item.type);
        __push(__element);
        __pop();
        __on("click", function() {
          return chooseItem(item, "navigation");
        });
        __pop();
        return __pop();
      });
      __pop();
      __pop();
      __pop();
      __pop();
      return __pop();
    }).call(data);
  };

}).call(this);

(function() {
  this.App = {
    width: 800,
    height: 450
  };

}).call(this);

(function() {
  this.Blade = function(I) {
    var self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      color: "white",
      damage: 100,
      duration: 0.05,
      radius: 10
    });
    self = GameObject(I);
    self.include("Damager");
    return self;
  };

}).call(this);

(function() {
  this.Damager = function(I, self) {
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      selfDamage: false
    });
    return {
      hit: function(target, dt) {
        if ((target === I.source) && !I.selfDamage) {
          return;
        }
        return target.I.health -= I.damage * dt;
      }
    };
  };

}).call(this);

(function() {
  this.Explosion = function(I) {
    var self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      damage: 50,
      duration: 0.3,
      radiusMax: 100,
      radius: 0
    });
    self = GameObject(I);
    self.include("Damager");
    self.unbind("draw");
    self.on("draw", function(canvas) {
      return canvas.drawCircle({
        x: 0,
        y: 0,
        radius: I.radius,
        color: "yellow"
      });
    });
    self.on("update", function() {
      return I.radius = I.radiusMax * I.age / I.duration;
    });
    return self;
  };

}).call(this);

(function() {
  var __slice = [].slice;

  ["log", "info", "error", "warn"].each(function(name) {
    return window[name] = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (typeof console !== "undefined" && console !== null) {
        return console[name].apply(console, args);
      }
    };
  });

}).call(this);

(function() {
  this.Missile = function(I) {
    var self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      speed: 250,
      heading: 0,
      radius: 10
    });
    self = GameObject(I);
    self.on("destroy", function() {
      return engine.add("Explosion", {
        x: I.x,
        y: I.y
      });
    });
    self.on("update", function() {
      I.velocity = Point.fromAngle(I.heading).scale(I.speed);
      if (I.x <= 0 || I.x >= App.width || I.y <= 0 || I.y >= App.height) {
        self.I.x = self.I.x.clamp(0, App.width);
        self.I.y = self.I.y.clamp(0, App.height);
        return self.destroy();
      }
    });
    return self;
  };

}).call(this);

(function() {
  this.Motor = function(I) {
    var self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      phaseOffset: 0,
      type: "constant",
      switchCooldown: 0,
      switchDelay: 0.5,
      lastPower: 0
    });
    self = GameObject(I).extend({
      power: function() {
        var lastPower;
        if (I.switchCooldown) {
          lastPower;
        } else {
          I.switchCooldown += I.switchDelay;
        }
        return lastPower = (function() {
          switch (I.type) {
            case "periodic":
              return Math.sin((I.age + I.phaseOffset) * Math.TAU) + 0.5;
            case "jittery":
              return rand() * 0.5;
            case "slow":
              return 0.5;
            default:
              return 1;
          }
        })();
      }
    });
    self.cooldown("switchCooldown");
    return self;
  };

  this.Motor.random = function() {
    return [
      {
        type: "slow"
      }, {
        type: "constant"
      }, {
        type: "jittery"
      }, {
        type: "periodic",
        phaseOffset: rand(),
        switchDelay: 0
      }
    ].rand();
  };

}).call(this);

(function() {
  this.Navigation = function(I) {
    var self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      type: "facing",
      switchDelay: 2,
      switchCooldown: 0
    });
    self = GameObject(I).extend({
      navigate: function(source) {
        if (I.switchCooldown) {

        } else {
          I.switchCooldown += I.switchDelay;
          switch (I.type) {
            case "random":
              return rand() * Math.TAU;
            case "spiral":
              return 10 * Math.log(source.I.age / 10 + 1) + source.I.headingInitial;
            case "strafe":
              if (rand() > 0.5) {
                return source.I.facing + 0.25.turns;
              } else {
                return source.I.facing - 0.25.turns;
              }
              break;
            default:
              return source.I.facing;
          }
        }
      }
    });
    self.cooldown("switchCooldown");
    return self;
  };

  this.Navigation.random = function() {
    return [
      {
        type: "facing"
      }, {
        type: "spiral",
        switchDelay: 0.25
      }, {
        type: "random"
      }, {
        type: "strafe"
      }
    ].rand();
  };

}).call(this);

(function() {
  !function(){var __slice=[].slice;!function($){Number.prototype.clamp=function(min,max){return Math.min(Math.max(min,this),max)};Math.TAU=2*Math.PI;return $.fn.pixieCanvas=function(options){var $canvas,canvas,canvasAttrAccessor,context,contextAttrAccessor;if(options==null){options={}}canvas=this.get(0);context=void 0;$canvas=$.extend($(canvas),{withTransform:function(matrix,block){context.save();context.transform(matrix.a,matrix.b,matrix.c,matrix.d,matrix.tx,matrix.ty);try{block(this)}finally{context.restore()}return this},clear:function(_arg){var height,width,x,y,_ref;_ref=_arg!=null?_arg:{},x=_ref.x,y=_ref.y,width=_ref.width,height=_ref.height;if(x==null){x=0}if(y==null){y=0}if(width==null){width=canvas.width}if(height==null){height=canvas.height}context.clearRect(x,y,width,height);return this},fill:function(color){var bounds,height,width,x,y,_ref;if(color==null){color={}}if(!(typeof color==="string"||color.channels)){_ref=color,x=_ref.x,y=_ref.y,width=_ref.width,height=_ref.height,bounds=_ref.bounds,color=_ref.color}if(bounds){x=bounds.x,y=bounds.y,width=bounds.width,height=bounds.height}x||(x=0);y||(y=0);if(width==null){width=canvas.width}if(height==null){height=canvas.height}this.fillColor(color);context.fillRect(x,y,width,height);return this},drawImage:function(){var args;args=1<=arguments.length?__slice.call(arguments,0):[];context.drawImage.apply(context,args);return this},drawCircle:function(_arg){var circle,color,position,radius,stroke,x,y;x=_arg.x,y=_arg.y,radius=_arg.radius,position=_arg.position,color=_arg.color,stroke=_arg.stroke,circle=_arg.circle;if(circle){x=circle.x,y=circle.y,radius=circle.radius}if(position){x=position.x,y=position.y}radius=radius.clamp(0,Infinity);context.beginPath();context.arc(x,y,radius,0,Math.TAU,true);context.closePath();if(color){this.fillColor(color);context.fill()}if(stroke){this.strokeColor(stroke.color);this.lineWidth(stroke.width);context.stroke()}return this},drawRect:function(_arg){var bounds,color,height,position,stroke,width,x,y;x=_arg.x,y=_arg.y,width=_arg.width,height=_arg.height,position=_arg.position,bounds=_arg.bounds,color=_arg.color,stroke=_arg.stroke;if(bounds){x=bounds.x,y=bounds.y,width=bounds.width,height=bounds.height}if(position){x=position.x,y=position.y}if(color){this.fillColor(color);context.fillRect(x,y,width,height)}if(stroke){this.strokeColor(stroke.color);this.lineWidth(stroke.width);context.strokeRect(x,y,width,height)}return this},drawLine:function(_arg){var color,direction,end,length,start,width;start=_arg.start,end=_arg.end,width=_arg.width,color=_arg.color,direction=_arg.direction,length=_arg.length;width||(width=3);if(direction){end=direction.norm(length).add(start)}this.lineWidth(width);this.strokeColor(color);context.beginPath();context.moveTo(start.x,start.y);context.lineTo(end.x,end.y);context.closePath();context.stroke();return this},drawPoly:function(_arg){var color,points,stroke;points=_arg.points,color=_arg.color,stroke=_arg.stroke;context.beginPath();points.forEach(function(point,i){if(i===0){return context.moveTo(point.x,point.y)}else{return context.lineTo(point.x,point.y)}});context.lineTo(points[0].x,points[0].y);if(color){this.fillColor(color);context.fill()}if(stroke){this.strokeColor(stroke.color);this.lineWidth(stroke.width);context.stroke()}return this},drawRoundRect:function(_arg){var bounds,color,height,position,radius,stroke,width,x,y;x=_arg.x,y=_arg.y,width=_arg.width,height=_arg.height,radius=_arg.radius,position=_arg.position,bounds=_arg.bounds,color=_arg.color,stroke=_arg.stroke;if(radius==null){radius=5}if(bounds){x=bounds.x,y=bounds.y,width=bounds.width,height=bounds.height}if(position){x=position.x,y=position.y}context.beginPath();context.moveTo(x+radius,y);context.lineTo(x+width-radius,y);context.quadraticCurveTo(x+width,y,x+width,y+radius);context.lineTo(x+width,y+height-radius);context.quadraticCurveTo(x+width,y+height,x+width-radius,y+height);context.lineTo(x+radius,y+height);context.quadraticCurveTo(x,y+height,x,y+height-radius);context.lineTo(x,y+radius);context.quadraticCurveTo(x,y,x+radius,y);context.closePath();if(color){this.fillColor(color);context.fill()}if(stroke){this.lineWidth(stroke.width);this.strokeColor(stroke.color);context.stroke()}return this},drawText:function(_arg){var color,font,position,text,x,y;x=_arg.x,y=_arg.y,text=_arg.text,position=_arg.position,color=_arg.color,font=_arg.font;if(position){x=position.x,y=position.y}this.fillColor(color);if(font){this.font(font)}context.fillText(text,x,y);return this},centerText:function(_arg){var color,font,position,text,textWidth,x,y;text=_arg.text,x=_arg.x,y=_arg.y,position=_arg.position,color=_arg.color,font=_arg.font;if(position){x=position.x,y=position.y}if(x==null){x=canvas.width/2}textWidth=this.measureText(text);return this.drawText({text:text,color:color,font:font,x:x-textWidth/2,y:y})},fillColor:function(color){if(color){if(color.channels){context.fillStyle=color.toString()}else{context.fillStyle=color}return this}else{return context.fillStyle}},strokeColor:function(color){if(color){if(color.channels){context.strokeStyle=color.toString()}else{context.strokeStyle=color}return this}else{return context.strokeStyle}},measureText:function(text){return context.measureText(text).width},putImageData:function(){var args;args=1<=arguments.length?__slice.call(arguments,0):[];context.putImageData.apply(context,args);return this},context:function(){return context},element:function(){return canvas},createPattern:function(image,repitition){return context.createPattern(image,repitition)},clip:function(x,y,width,height){context.beginPath();context.rect(x,y,width,height);context.clip();return this}});contextAttrAccessor=function(){var attrs;attrs=1<=arguments.length?__slice.call(arguments,0):[];return attrs.forEach(function(attr){return $canvas[attr]=function(newVal){if(newVal!=null){context[attr]=newVal;return this}else{return context[attr]}}})};contextAttrAccessor("font","globalAlpha","globalCompositeOperation","lineWidth","textAlign");canvasAttrAccessor=function(){var attrs;attrs=1<=arguments.length?__slice.call(arguments,0):[];return attrs.forEach(function(attr){return $canvas[attr]=function(newVal){if(newVal!=null){canvas[attr]=newVal;return this}else{return canvas[attr]}}})};canvasAttrAccessor("height","width");if(canvas!=null?canvas.getContext:void 0){context=canvas.getContext("2d");if(options.init){options.init($canvas)}return $canvas}}}(typeof jQuery!=="undefined"&&jQuery!==null?jQuery:Zepto)}.call(this);;


}).call(this);

(function() {
  this.PointDefense = function(I) {
    var self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      color: "purple",
      duration: 0.5,
      range: 300
    });
    self = GameObject(I);
    self.on("update", function() {
      var closest;
      closest = engine.find("Missile").select(function(missile) {
        return missile.I.source.I.team !== I.source.I.team;
      }).map(function(missile) {
        return {
          distance: Point.distance(self.position(), missile.position()),
          object: missile
        };
      }).sort(function(_arg, _arg1) {
        var a, b;
        a = _arg.distance;
        b = _arg1.distance;
        return b - a;
      }).first();
      if (closest && closest.distance <= I.range) {
        I.target = closest.object;
        I.target.destroy();
        return self.destroy();
      }
    });
    self.on("destroy", function() {
      return engine.add("Ray", {
        start: I.source.position(),
        end: I.target.position(),
        color: I.color
      });
    });
    return self;
  };

}).call(this);

(function() {
  this.Ray = function(I) {
    var self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      duration: 0.25
    });
    self = GameObject(I);
    self.on("update", function() {
      return I.alpha = 1 - I.age / I.duration;
    });
    self.unbind("draw");
    self.bind("draw", function(canvas) {
      return canvas.drawLine({
        start: I.start,
        end: I.end,
        color: I.color
      });
    });
    return self;
  };

}).call(this);

(function() {
  this.Robot = function(I) {
    var drawDebug, meter, motors, navigation, self, targetting, weapons;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      color: "blue",
      width: 50,
      height: 50,
      speed: 100,
      name: "Robot",
      heading: 0,
      headingInitial: 0,
      facing: 0,
      facingInitial: 0,
      health: 100,
      healthMax: 100,
      radius: 25,
      team: 0,
      motors: [Motor.random()],
      navigation: Navigation.random(),
      targetting: Targetting.random(),
      weapons: [Weapon.random()]
    });
    weapons = I.weapons.map(Weapon);
    motors = I.motors.map(Motor);
    navigation = Navigation(I.navigation);
    targetting = Targetting(I.targetting);
    self = GameObject(I);
    self.clampToBounds();
    meter = function() {
      var color, healthRatio;
      healthRatio = I.health / I.healthMax;
      if (healthRatio > 0.5) {
        color = Color.mix(Color("green"), Color("yellow"), (healthRatio - 0.5) * 2);
      } else {
        color = Color.mix(Color("yellow"), Color("red"), healthRatio * 2);
      }
      return self.meter("health", {
        color: color,
        x: I.x - I.width / 2,
        y: I.y - I.height / 2 - 20,
        width: I.width
      });
    };
    self.on("update", function(elapsedTime) {
      if (I.health <= 0) {
        self.destroy();
      }
      meter();
      navigation.update(elapsedTime);
      I.heading = navigation.navigate(self) || I.heading;
      targetting.update(elapsedTime);
      I.facing = targetting.target(self) || I.facing;
      motors.invoke("update", elapsedTime);
      I.power = motors.invoke("power").sum().clamp(0, 2);
      weapons.invoke("update", elapsedTime);
      weapons.invoke("fire", self, elapsedTime);
      return I.velocity = Point.fromAngle(I.heading).scale(I.speed * I.power);
    });
    self.on("afterUpdate", function(elapsedTime) {
      return motors.invoke("trigger", "afterUpdate", elapsedTime);
    });
    drawDebug = function(canvas) {
      var end, p;
      p = self.position();
      end = p.add(Point.fromAngle(I.facing).scale(40));
      canvas.drawLine({
        start: p,
        end: end,
        color: "rgb(255, 0, 255)"
      });
      end = p.add(Point.fromAngle(I.heading).scale(40));
      return canvas.drawLine({
        start: p,
        end: end,
        color: "rgb(0, 255, 0)"
      });
    };
    self.on("draw", function(canvas) {
      canvas.font("bold 16px consolas, 'Courier New', 'andale mono', 'lucida console', monospace");
      return canvas.centerText({
        color: "white",
        x: 0,
        y: -I.height / 2,
        text: I.name
      });
    });
    self.on("overlay", drawDebug);
    self.on("destroy", function() {
      return engine.add("Explosion", {
        x: I.x,
        y: I.y
      });
    });
    return self;
  };

}).call(this);

(function() {
  var defaultBot, defaultItem, randomName;

  randomName = function() {
    var name, prefix, suffix;
    prefix = ["Mr. ", "Dr. ", "Ms. ", "Mrs. ", "The ", "", "", "", "", "El ", "Lord ", "Lady ", "Duke ", "Duchess "].rand();
    name = ["Donuts", "BMO", "Bacon", "Duder", "Dude", "Hotdog", "Squirtle", "Killer", "Ronnie", "Joe", "Stalin", "Reginald", "Toast", "Margarine", "Juice", "Q", "DP", "Obama", "Hitler", "YOLO"].rand();
    suffix = [" Jr", " II", " Sr", " III", " IV", " of Death", "", "", "", "", "", "", "", ""].rand();
    return "" + prefix + name + suffix;
  };

  defaultBot = function() {
    var bot;
    bot = {
      name: randomName(),
      motors: [],
      weapons: [],
      targetting: null,
      navigation: null
    };
    bot.oNavigation = Observable("");
    bot.oWeapons = Observable("");
    bot.oMotors = Observable("");
    return bot;
  };

  defaultItem = function() {
    return {
      type: "default"
    };
  };

  this.Setup = function(I) {
    var activeRobot, add, removeFromArray, self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      robots: [defaultBot(), defaultBot(), defaultBot()],
      motors: [Motor.random(), Motor.random(), Motor.random(), Motor.random()],
      weapons: [Weapon.random(), Weapon.random(), Weapon.random(), Weapon.random()],
      targetting: [Targetting.random(), Targetting.random()],
      navigation: [Navigation.random(), Navigation.random(), Navigation.random()]
    });
    activeRobot = I.robots.first();
    removeFromArray = function(item, slot) {
      return I.robots.each(function(robot) {
        return self[slot].remove(item);
      });
    };
    add = function(robot, item, slot) {
      if (slot.lastIndexOf('s') === slot.length - 1) {
        if (robot[slot].length < 2) {
          removeFromArray(item, slot);
          robot[slot].push(item);
        }
      } else {
        if (robot[slot] === null) {
          removeFromArray(item, slot);
          robot[slot] = item;
        }
      }
      return I.robots.each(function(robot) {
        var _ref;
        robot.oMotors(robot.motors.map(function(m) {
          return m.type.titleize();
        }).join(","));
        robot.oWeapons(robot.weapons.map(function(w) {
          return w.projectile.underscore().titleize();
        }).join(","));
        return robot.oNavigation(((_ref = robot.navigation) != null ? _ref.type.titleize() : void 0) || "");
      });
    };
    self = Model(I).extend({
      chooseItem: function(item, slot) {
        return add(activeRobot, item, slot);
      },
      chooseRobot: function(robot) {
        return activeRobot = robot;
      }
    });
    self.observeAll();
    return self;
  };

}).call(this);

(function() {
  this.Targetting = function(I) {
    var self, target;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      type: "nearest",
      switchDelay: 2,
      switchCooldown: 0
    });
    target = null;
    self = GameObject(I).extend({
      target: function(source) {
        var selector;
        selector = "Robot.team=" + (+(!source.I.team));
        if (target && I.switchCooldown) {

        } else {
          I.switchCooldown += I.switchDelay;
          switch (I.type) {
            case "random":
              target = {
                position: function() {
                  return Point(rand(App.width), rand(App.height));
                }
              };
              break;
            case "randomEnemy":
              target = engine.find(selector).rand();
              break;
            default:
              target = engine.closest(selector, source.position());
          }
        }
        if (target) {
          return Point.direction(source.position(), target.position());
        }
      }
    });
    self.cooldown("switchCooldown");
    return self;
  };

  this.Targetting.random = function() {
    return [
      {
        type: "random"
      }, {
        type: "randomEnemy"
      }, {
        type: "nearestEnemy"
      }
    ].rand();
  };

}).call(this);

(function() {
  this.Weapon = function(I) {
    var self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      delay: 1,
      cooldown: 1,
      projectile: "Missile",
      spread: 0.05.turns
    });
    self = GameObject(I).extend({
      fire: function(source, dt) {
        var facing, p;
        if (I.cooldown === 0) {
          I.cooldown = I.delay;
          facing = source.I.facing;
          p = source.position().add(source.velocity().scale(dt)).add(Point.fromAngle(facing).scale(40));
          return engine.add(I.projectile, {
            x: p.x,
            y: p.y,
            heading: facing + rand() * I.spread - I.spread / 2,
            source: source
          });
        }
      }
    });
    self.cooldown("cooldown");
    return self;
  };

  this.Weapon.random = function() {
    return [
      {
        projectile: "Missile",
        cooldown: rand() + 1
      }, {
        projectile: "Blade",
        delay: 0.05,
        cooldown: 0
      }, {
        projectile: "PointDefense"
      }, {
        projectile: "Teleporter",
        delay: 4,
        cooldown: 2 + 2 * rand()
      }, {
        projectile: "Flame",
        delay: 0.25
      }, {
        projectile: "Laser",
        delay: 0.6,
        cooldown: 1 + rand()
      }
    ].rand();
  };

}).call(this);

(function() {
  this.Teleporter = function(I) {
    var self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      color: "lime"
    });
    self = GameObject(I);
    self.on("update", function() {
      if (I.age > 1) {
        self.destroy();
        I.source.I.x = rand(App.width);
        return I.source.I.y = rand(App.height);
      }
    });
    return self;
  };

}).call(this);

(function() {
  this.Flame = function(I) {
    var self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      damage: 10,
      duration: 3,
      radiusMax: 50,
      radius: 0,
      speed: 150,
      opacity: 0.5,
      selfDamage: true
    });
    self = GameObject(I);
    self.include("Damager");
    self.unbind("draw");
    self.on("draw", function(canvas) {
      return canvas.drawCircle({
        x: 0,
        y: 0,
        radius: I.radius,
        color: "orange"
      });
    });
    self.on("update", function() {
      I.velocity = Point.fromAngle(I.heading).scale(I.speed);
      return I.radius = I.radiusMax * I.age / I.duration;
    });
    return self;
  };

}).call(this);

(function() {
  this.Laser = function(I) {
    var self;
    if (I == null) {
      I = {};
    }
    Object.defaults(I, {
      color: "cyan",
      duration: 0.5,
      damage: 2
    });
    self = GameObject(I);
    self.on("update", function() {
      var closest;
      closest = engine.closest("Robot.team=" + (+(!I.source.I.team)), self.position());
      if (closest) {
        I.target = closest;
        I.target.I.health -= I.damage;
        return self.destroy();
      }
    });
    self.on("destroy", function() {
      return engine.add("Ray", {
        start: I.source.position(),
        end: I.target.position(),
        color: I.color
      });
    });
    return self;
  };

}).call(this);

(function() {
  var $root, appRoot, canvas, countdownInterval, gist, objectCollision, setupTimeLimit, startGame, styleContent, _ref;

  $root = ENV.$root, gist = ENV.gist;

  appRoot = $("<div>", {
    "class": "app"
  });

  $root.append(appRoot);

  $root = appRoot;

  Object.keys(gist.files).each(function(name) {
    if (name.extension() === "js" && name.withoutExtension() !== "build") {
      return Function(gist.files[name].content)();
    }
  });

  if (styleContent = (_ref = gist.files["style.css"]) != null ? _ref.content : void 0) {
    $root.append($("<style>", {
      html: styleContent
    }));
  }

  $root.append(HAMLjr.templates.arena());

  $root.append(HAMLjr.templates.intro());

  countdownInterval = null;

  setupTimeLimit = 10;

  this.goToSetup = function() {
    var setupConfig, setupStartedAt;
    $(".setup").remove();
    setupConfig = Setup();
    $root.append(HAMLjr.templates.setup(setupConfig));
    $(".intro").hide();
    setupStartedAt = +(new Date);
    clearInterval(countdownInterval);
    return countdownInterval = setInterval(function() {
      var color, size, time;
      time = (setupStartedAt + setupTimeLimit * 1000 - (+(new Date))) / 1000;
      size = (time % 1) * 20 + 40;
      color = "lime";
      if (time < 6) {
        color = "yellow";
      }
      if (time < 3) {
        color = "red";
      }
      if (time < 0) {
        clearInterval(countdownInterval);
        return startGame(setupConfig);
      } else {
        return $(".setup .time").text(time.toFixed(2)).css({
          fontSize: size,
          color: color
        });
      }
    }, 15);
  };

  canvas = $root.children("canvas").pixieCanvas();

  canvas.fill("gray");

  this.engine = Engine({
    canvas: canvas,
    FPS: 60
  });

  startGame = function(config) {
    $(".setup").hide();
    $(".intro").hide();
    engine.start();
    return config.robots.each(function(data, i) {
      var y;
      y = (i + 1) * App.height / 4;
      engine.add("Robot", Object.extend(data, {
        y: y
      }));
      return engine.add("Robot", {
        color: "red",
        x: App.width,
        y: y,
        headingInitial: 0.5.turns,
        team: 1
      });
    });
  };

  engine.on("overlay", function(canvas) {
    return canvas.drawText({
      x: 10,
      y: 20,
      color: "white",
      text: engine.objects().length
    });
  });

  objectCollision = function(a, b) {
    return Collision.circular(a.circle(), b.circle());
  };

  engine.on("update", function(dt) {
    Collision.collide("Missile", "Robot", function(missile, robot) {
      if (missile.I.source === robot) {
        return;
      }
      return missile.destroy();
    }, objectCollision);
    Collision.collide("Explosion, Blade, Flame", "Robot", function(explosion, robot) {
      return explosion.hit(robot, dt);
    }, objectCollision);
    Collision.collide("Explosion", "Missile", function(explosion, missile) {
      return missile.destroy();
    }, objectCollision);
    return engine.find("Missile").eachPair(function(a, b) {
      if (objectCollision(a, b)) {
        a.destroy();
        return b.destroy();
      }
    });
  });

}).call(this);
;
</script>
</body></html>
